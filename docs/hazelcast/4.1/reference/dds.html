<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Distributed Data Structures Hazelcast Documentation</title>
    <link rel="canonical" href="https://JakeSCahill.github.io/hazelcast/4.1/reference/dds.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://JakeSCahill.github.io">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Use cases</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">GitHub</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../develop/hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploy/installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/wan.html">WAN Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../home/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../home/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../hazelcast_overview.html">Hazelcast IMDG</a></li>
    <li><a href="faq.html">Reference</a></li>
    <li><a href="dds.html">Distributed data structures</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a class="git" href="file:///C:/Users/Jake%20Cahill/Documents/code-playground/docs/hazelcast-docs/modules/reference/pages/dds.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Distributed Data Structures</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>As mentioned in the <a href="#hazelcast-overview">Overview section</a>, Hazelcast offers
distributed implementations of many common data structures. For each of the client
languages, Hazelcast mimics as closely as possible the natural interface of the
structure. So, for example in Java, the map follows <code>java.util.Map</code> semantics.
In the descriptions below, we mention each structure&#8217;s Java equivalent interface.  All of
these structures are usable from Java, .NET, C++, Node.js, Python, and Go.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Standard utility collections</strong></p>
<div class="ulist">
<ul>
<li>
<p><a href="#map">Map</a> is the distributed implementation of <code>java.util.Map</code>.
It lets you read from and write to a Hazelcast map with methods such as
<code>get</code> and <code>put</code>.</p>
</li>
<li>
<p><a href="#queue">Queue</a> is the distributed implementation of <code>java.util.concurrent.BlockingQueue</code>.
You can add an item in one member and remove it from another one.</p>
</li>
<li>
<p><a href="#ringbuffer">Ringbuffer</a> is implemented for reliable eventing system.</p>
</li>
<li>
<p><a href="#set">Set</a> is the distributed and concurrent implementation of <code>java.util.Set</code>.
It does not allow duplicate elements and does not preserve their order.</p>
</li>
<li>
<p><a href="#list">List</a> is similar to Hazelcast Set. The only difference is that it allows
duplicate elements and preserves their order.</p>
</li>
<li>
<p><a href="#multimap">Multimap</a> is a specialized Hazelcast map. It is a distributed data
structure where you can store multiple values for a single key.</p>
</li>
<li>
<p><a href="#replicated-map">Replicated Map</a> does not partition data. It does not spread
data to different cluster members. Instead, it replicates the data to all members.</p>
</li>
<li>
<p><a href="#cardinality-estimator">Cardinality Estimator</a> is a data structure which implements
Flajolet&#8217;s HyperLogLog algorithm.</p>
</li>
</ul>
</div>
</li>
<li>
<p><strong>Topic</strong> is the distributed mechanism for publishing messages that are delivered to
multiple subscribers. It is also known as the publish/subscribe (pub/sub) messaging model.
See the <a href="#topic">Topic section</a> for more information. Hazelcast also has a structure called
Reliable Topic which uses the same interface of Hazelcast Topic. The difference is that it is
backed up by the Ringbuffer data structure. See the <a href="#reliable-topic">Reliable Topic section</a>.</p>
</li>
<li>
<p><strong>Concurrency utilities</strong></p>
<div class="ulist">
<ul>
<li>
<p><a href="#lock">FencedLock</a> is the distributed implementation of <code>java.util.concurrent.locks.Lock</code>.
When you use lock, the critical section that Hazelcast Lock guards is guaranteed to be
executed by only one thread in the entire cluster.</p>
</li>
<li>
<p><a href="#isemaphore">ISemaphore</a> is the distributed implementation of <code>java.util.concurrent.Semaphore</code>.
When performing concurrent activities, semaphores offer permits to control the thread counts.</p>
</li>
<li>
<p><a href="#iatomiclong">IAtomicLong</a> is the distributed implementation of
<code>java.util.concurrent.atomic.AtomicLong</code>. Most of AtomicLong&#8217;s operations are available.
However, these operations involve remote calls and hence their performances differ from
AtomicLong, due to being distributed.</p>
</li>
<li>
<p><a href="#iatomicreference">IAtomicReference</a> is the distributed implementation of
<code>java.util.concurrent.atomic.AtomicReference</code>. When you need to deal with a reference
in a distributed environment, you can use Hazelcast IAtomicReference.</p>
</li>
<li>
<p><a href="#flakeidgenerator">FlakeIdGenerator</a> is used to generate cluster-wide unique identifiers.</p>
</li>
<li>
<p><a href="#icountdownlatch">ICountdownLatch</a> is the distributed implementation of
<code>java.util.concurrent.CountDownLatch</code>. Hazelcast CountDownLatch is a gate keeper for
concurrent activities. It enables the threads to wait for other threads to complete
their operations.</p>
</li>
<li>
<p><a href="#pn-counter">PN counter</a> is a distributed data structure where each Hazelcast instance
can increment and decrement the counter value and these updates are propagated to all replicas.</p>
</li>
</ul>
</div>
</li>
<li>
<p><a href="#event-journal">Event Journal</a> is a distributed data structure that stores the history
of mutation actions on map or cache.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="overview-of-hazelcast-distributed-objects"><a class="anchor" href="#overview-of-hazelcast-distributed-objects"></a>Overview of Hazelcast Distributed Objects</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast has two types of distributed objects in terms of their partitioning strategies:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Data structures where each partition stores a part of the instance,
namely partitioned data structures.</p>
</li>
<li>
<p>Data structures where a single partition stores the whole instance,
namely non-partitioned data structures.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>The following are the partitioned Hazelcast data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Map</p>
</li>
<li>
<p>MultiMap</p>
</li>
<li>
<p>Cache (Hazelcast JCache implementation)</p>
</li>
<li>
<p>Event Journal</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following are the non-partitioned Hazelcast data structures:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Queue</p>
</li>
<li>
<p>Set</p>
</li>
<li>
<p>List</p>
</li>
<li>
<p>Ringbuffer</p>
</li>
<li>
<p>FencedLock</p>
</li>
<li>
<p>ISemaphore</p>
</li>
<li>
<p>IAtomicLong</p>
</li>
<li>
<p>IAtomicReference</p>
</li>
<li>
<p>FlakeIdGenerator</p>
</li>
<li>
<p>ICountdownLatch</p>
</li>
<li>
<p>Cardinality Estimator</p>
</li>
<li>
<p>PN Counter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Besides these, Hazelcast also offers the Replicated Map structure as
explained in the above <strong>Standard utility collections</strong> list.</p>
</div>
<div class="sect2">
<h3 id="loading-and-destroying-a-distributed-object"><a class="anchor" href="#loading-and-destroying-a-distributed-object"></a>Loading and Destroying a Distributed Object</h3>
<div class="paragraph">
<p>Hazelcast offers a <code>get</code> method for most of its distributed objects. To load an object,
first create a Hazelcast instance and then use the related <code>get</code> method on this instance.
Following example code snippet creates an Hazelcast instance and a map on this instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
Map&lt;Integer, String&gt; customers = hazelcastInstance.getMap( "customers" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>As to the configuration of distributed object, Hazelcast uses the default settings
from the file <code>hazelcast.xml</code> that comes with your Hazelcast download. Of course,
you can provide an explicit configuration in this XML or programmatically according
to your needs. See the <a href="#understanding-configuration">Understanding Configuration section</a>.</p>
</div>
<div class="paragraph">
<p>Note that, most of Hazelcast&#8217;s distributed objects are created lazily, i.e., a distributed object
is created once the first operation accesses it.</p>
</div>
<div class="paragraph">
<p>If you want to use an object you loaded in other places, you can safely reload it using its
reference without creating a new Hazelcast instance (<code>customers</code> in the above example).</p>
</div>
<div class="paragraph">
<p>To destroy a Hazelcast distributed object, you can use the method <code>destroy</code>. This method clears
and releases all resources of the object. Therefore, you must use it with care since a reload
with the same object reference after the object is destroyed creates a new data structure without
an error. See the following example code where one of the queues are destroyed and the other
one is accessed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz1 = Hazelcast.newHazelcastInstance();
        HazelcastInstance hz2 = Hazelcast.newHazelcastInstance();
        IQueue&lt;String&gt; q1 = hz1.getQueue("q");
        IQueue&lt;String&gt; q2 = hz2.getQueue("q");
        q1.add("foo");
        System.out.println("q1.size: "+q1.size()+ " q2.size:"+q2.size());
        q1.destroy();
        System.out.println("q1.size: " + q1.size() + " q2.size:" + q2.size());</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you start the <code>Member</code> above, the output is as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">q1.size: 1 q2.size:1
q1.size: 0 q2.size:0</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, no error is generated and a new queue resource is created.</p>
</div>
<div class="paragraph">
<p>Hazelcast is designed to create any distributed data structure whenever it is accessed,
i.e., whenever a call is made to the data structure. Therefore, keep in mind that a
data structure is recreated when you perform an operation on it even after you have destroyed it.</p>
</div>
</div>
<div class="sect2">
<h3 id="controlling-partitions"><a class="anchor" href="#controlling-partitions"></a>Controlling Partitions</h3>
<div class="paragraph">
<p>Hazelcast uses the name of a distributed object to determine which partition it will be put.
Let&#8217;s load two queues as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
IQueue q1 = hazelcastInstance.getQueue("q1");
IQueue q2 = hazelcastInstance.getQueue("q2");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since these queues have different names, they will be placed into different partitions.
If you want to put these two into the same partition, you use the <code>@</code> symbol as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
IQueue q1 = hazelcastInstance.getQueue("q1@foo");
IQueue q2 = hazelcastInstance.getQueue("q2@foo");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, these two queues will be put into the same partition whose partition key is <code>foo</code>.
Note that you can use the method <code>getPartitionKey</code> to learn the partition key of a distributed object.
It may be useful when you want to create an object in the same partition of an existing object.
See its usage as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String partitionKey = q1.getPartitionKey();
IQueue q3 = hazelcastInstance.getQueue("q3@"+partitionKey);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="common-features-of-all-hazelcast-data-structures"><a class="anchor" href="#common-features-of-all-hazelcast-data-structures"></a>Common Features of all Hazelcast Data Structures</h3>
<div class="ulist">
<ul>
<li>
<p>If a member goes down, its backup replica (which holds the same data) dynamically
redistributes the data, including the ownership and locks on them, to the remaining
live members. As a result, there will not be any data loss.</p>
</li>
<li>
<p>There is no single cluster master that can be a single point of failure.
Every member in the cluster has equal rights and responsibilities. No single member is
superior. There is no dependency on an external 'server' or 'master'.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="example-distributed-object-code"><a class="anchor" href="#example-distributed-object-code"></a>Example Distributed Object Code</h3>
<div class="paragraph">
<p>Here is an example of how you can retrieve existing data structure instances
(map, queue, set, topic, etc.) and how you can listen for instance events,
such as an instance being created or destroyed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        ExampleDOL example = new ExampleDOL();
        Config config = new Config();

        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance(config);
        hazelcastInstance.addDistributedObjectListener(example);

        Collection&lt;DistributedObject&gt; distributedObjects = hazelcastInstance.getDistributedObjects();
        for (DistributedObject distributedObject : distributedObjects) {
            System.out.println(distributedObject.getName());
        }
    }

    @Override
    public void distributedObjectCreated(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println("Created " + instance.getName());
    }

    @Override
    public void distributedObjectDestroyed(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println("Destroyed " + instance.getName());
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map"><a class="anchor" href="#map"></a>Map</h3>
<div class="paragraph">
<p>Hazelcast Map (<code>IMap</code>) extends the interface <code>java.util.concurrent.ConcurrentMap</code>
and hence <code>java.util.Map</code>. It is the distributed implementation of Java map. You can
perform operations like reading and writing from/to a Hazelcast map with the well
known get and put methods.</p>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
IMap data structure can also be used by <a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a>
for Real-Time Stream Processing (by enabling the Event Journal on your map) and
Fast Batch Processing. Hazelcast Jet uses IMap as a source (reads data from IMap) and as a sink
(writes data to IMap). See the <a href="https://jet.hazelcast.org/use-cases/fast-batch-processing/" target="_blank" rel="noopener">Fast Batch Processing</a>
and <a href="https://jet.hazelcast.org/use-cases/real-time-stream-processing/" target="_blank" rel="noopener">Real-Time Stream Processing</a>
use cases for Hazelcast Jet. See also <a href="https://jet-start.sh/docs/api/sources-sinks#imap" target="_blank" rel="noopener">here</a>
in the Hazelcast Jet Programming Guide to learn how Jet uses IMap, i.e., how it can read from and write to IMap.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="getting-a-map-and-putting-an-entry"><a class="anchor" href="#getting-a-map-and-putting-an-entry"></a>Getting a Map and Putting an Entry</h3>
<div class="paragraph">
<p>Hazelcast partitions your map entries and their backups, and almost evenly distribute
them onto all Hazelcast members. Each member carries approximately
"number of map entries * 2 * 1/n" entries, where <strong>n</strong> is the number of members in the cluster.
For example, if you have a member with 1000 objects to be stored in the cluster and then you
start a second member, each member will both store 500 objects and back up the 500 objects
in the other member.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s create a Hazelcast instance and fill a map named <code>Capitals</code> with key-value pairs
using the following code. Use the HazelcastInstance <code>getMap</code> method to get the map,
then use the map <code>put</code> method to put an entry into the map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hzInstance = Hazelcast.newHazelcastInstance();
Map&lt;String, String&gt; capitalcities = hzInstance.getMap( "capitals" );
    capitalcities.put( "1", "Tokyo" );
    capitalcities.put( "2", "Paris" );
    capitalcities.put( "3", "Washington" );
    capitalcities.put( "4", "Ankara" );
    capitalcities.put( "5", "Brussels" );
    capitalcities.put( "6", "Amsterdam" );
    capitalcities.put( "7", "New Delhi" );
    capitalcities.put( "8", "London" );
    capitalcities.put( "9", "Berlin" );
    capitalcities.put( "10", "Oslo" );
    capitalcities.put( "11", "Moscow" );
    ...
    capitalcities.put( "120", "Stockholm" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you run this code, a cluster member is created with a map whose entries are
distributed across the members' partitions. See the below illustration. For now,
this is a single member cluster.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/1Node.png" alt="Map Entries in a Single Member"></span></p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please note that some of the partitions do not contain any data entries since
we only have 120 objects and the partition count is 271 by default. This count is
configurable and can be changed using the system property <code>hazelcast.partition.count</code>.
See the <a href="#system-properties">System Properties appendix</a>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="creating-a-member-for-map-backup"><a class="anchor" href="#creating-a-member-for-map-backup"></a>Creating A Member for Map Backup</h3>
<div class="paragraph">
<p>Now let&#8217;s create a second member by running the above code again. This creates a
cluster with two members. This is also where backups of entries are created - remember
the backup partitions mentioned in the <a href="#hazelcast-overview">Hazelcast Overview section</a>.
The following illustration shows two members and how the data and its backup is distributed.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/2Nodes.png" alt="Map Entries with Backups in Two Members"></span></p>
</div>
<div class="paragraph">
<p>As you see, when a new member joins the cluster, it takes ownership and loads some of the
data in the cluster. Eventually, it will carry almost "(1/n <code>*</code> total-data) + backups" of the data,
reducing the load on other members.</p>
</div>
<div class="paragraph">
<p><code>HazelcastInstance.getMap()</code> returns an instance of <code>com.hazelcast.map.IMap</code> which extends
the <code>java.util.concurrent.ConcurrentMap</code> interface. Methods like
<code>ConcurrentMap.putIfAbsent(key,value)</code> and <code>ConcurrentMap.replace(key,value)</code> can be used
on the distributed map, as shown in the example below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class BasicMapOperations {

    private HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

    public Customer getCustomer(String id) {
        ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap("customers");
        Customer customer = customers.get(id);
        if (customer == null) {
            customer = new Customer(id);
            customer = customers.putIfAbsent(id, customer);
        }
        return customer;
    }

    public boolean updateCustomer(Customer customer) {
        ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap("customers");
        return (customers.replace(customer.getId(), customer) != null);
    }

    public boolean removeCustomer(Customer customer) {
        ConcurrentMap&lt;String, Customer&gt; customers = hazelcastInstance.getMap("customers");
        return customers.remove(customer.getId(), customer);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>All <code>ConcurrentMap</code> operations such as <code>put</code> and <code>remove</code> might wait if the key is locked
by another thread in the local or remote JVM. But, they will eventually return with success.
<code>ConcurrentMap</code> operations never throw a <code>java.util.ConcurrentModificationException</code>.</p>
</div>
</div>
<div class="sect2">
<h3 id="backing-up-maps"><a class="anchor" href="#backing-up-maps"></a>Backing Up Maps</h3>
<div class="paragraph">
<p>Hazelcast distributes map entries onto multiple cluster members (JVMs). Each member
holds some portion of the data.</p>
</div>
<div class="paragraph">
<p>Distributed maps have one backup by default. If a member goes down, your data is recovered
using the backups in the cluster. There are two types of backups as described below: <em>sync</em> and <em>async</em>.</p>
</div>
<div class="sect3">
<h4 id="creating-sync-backups"><a class="anchor" href="#creating-sync-backups"></a>Creating Sync Backups</h4>
<div class="paragraph">
<p>To provide data safety, Hazelcast allows you to specify the number of backup copies you
want to have. That way, data on a cluster member is copied onto other member(s).</p>
</div>
<div class="paragraph">
<p>To create synchronous backups, select the number of backup copies using the <code>backup-count</code> property.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this count is 1, a map entry will have its backup on one other member in the cluster.
If you set it to 2, then a map entry will have its backup on two other members.
You can set it to 0 if you do not want your entries to be backed up, e.g., if performance
is more important than backing up. The maximum value for the backup count is 6.</p>
</div>
<div class="paragraph">
<p>Hazelcast supports both synchronous and asynchronous backups. By default, backup operations
are synchronous and configured with <code>backup-count</code>. In this case, backup operations block
operations until backups are successfully copied to backup members (or deleted from backup
members in case of remove) and acknowledgements are received. Therefore, backups are updated
before a <code>write</code>(put, set, remove and their async counterparts) operation is completed,
provided that the cluster is stable. Sync backup operations have a blocking cost which may
lead to latency issues.</p>
</div>
</div>
<div class="sect3">
<h4 id="creating-async-backups"><a class="anchor" href="#creating-async-backups"></a>Creating Async Backups</h4>
<div class="paragraph">
<p>Asynchronous backups, on the other hand, do not block operations. They are fire &amp; forget and
do not require acknowledgements; the backup operations are performed at some point in time.</p>
</div>
<div class="paragraph">
<p>To create asynchronous backups, select the number of async backups with the <code>async-backup-count</code>
property. An example is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      backup-count: 0
      async-backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>See <a href="#consistency-and-replication-model">Consistency and Replication Model</a> for more detail.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Backups increase memory usage since they are also kept in memory.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A map can have both sync and async backups at the same time.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="enabling-backup-reads"><a class="anchor" href="#enabling-backup-reads"></a>Enabling Backup Reads</h4>
<div class="paragraph">
<p>By default, Hazelcast has one sync backup copy. If <code>backup-count</code> is set to more than 1, then
each member will carry both owned entries and backup copies of other members. So for the <code>map.get(key)</code>
call, it is possible that the calling member has a backup copy of that key. By default, <code>map.get(key)</code>
always reads the value from the actual owner of the key for consistency.</p>
</div>
<div class="paragraph">
<p>To enable backup reads (read local backup entries), set the value of the <code>read-backup-data</code> property
to <strong>true</strong>. Its default value is <strong>false</strong> for consistency. Enabling backup reads can improve
performance but on the other hand it can cause stale reads while still preserving monotonic-reads property.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
        &lt;read-backup-data&gt;true&lt;/read-backup-data&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      backup-count: 0
      async-backup-count: 1
      read-backup-data: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>This feature is available when there is at least one sync or async backup.</p>
</div>
<div class="paragraph">
<p>Please note that if you are performing a read from a backup, you should take into account that
your hits to the keys in the backups are not reflected as hits to the original keys on the primary
members. This has an impact on IMap&#8217;s maximum idle seconds or time-to-live seconds expiration.
Therefore, even though there is a hit on a key in backups, your original key on the primary member may expire.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Backup reads that are requested by Hazelcast clients are ignored since this operation
is performed on the local entries.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map-eviction"><a class="anchor" href="#map-eviction"></a>Map Eviction</h3>
<div class="paragraph">
<p>Unless you delete the map entries manually or use an eviction policy, they will remain in the map.
Hazelcast supports policy-based eviction for distributed maps. Currently supported policies are
LRU (Least Recently Used) and LFU (Least Frequently Used).</p>
</div>
<div class="paragraph">
<p>Hazelcast Map uses the same eviction mechanism as the JCache implementation.
See the <a href="#eviction-algorithm">Eviction Algorithm section</a> for details.</p>
</div>
<div class="sect3">
<h4 id="understanding-map-eviction"><a class="anchor" href="#understanding-map-eviction"></a>Understanding Map Eviction</h4>
<div class="paragraph">
<p>Hazelcast Map performs eviction based on partitions. For example, when you specify a size using
the <code>PER_NODE</code> attribute for <code>max-size</code> (see the <a href="#configuring-map-eviction">Configuring Map Eviction section</a>),
Hazelcast internally calculates the maximum size for every partition. Hazelcast uses the following
equation to calculate the maximum size of a partition:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>partition-maximum-size = max-size * member-count / partition-count</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the <code>partition-maximum-size</code> is less than 1 in the equation above, it will be set to 1
(otherwise, the partitions would be emptied immediately by eviction due to the exceedance of
<code>max-size</code> being less than 1).
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The eviction process starts according to this calculated partition maximum size when you try
to put an entry. When entry count in that partition exceeds partition maximum size, eviction
starts on that partition.</p>
</div>
<div class="paragraph">
<p>Assume that you have the following figures as examples:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>partition count: 200</p>
</li>
<li>
<p>entry count for each partition: 100</p>
</li>
<li>
<p><code>max-size</code> (PER_NODE): 20000</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The total number of entries here is 20000 (partition count * entry count for each partition).
This means you are at the eviction threshold since you set the <code>max-size</code> to 20000. When you
try to put an entry:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>the entry goes to the relevant partition</p>
</li>
<li>
<p>the partition checks whether the eviction threshold is reached (<code>max-size</code>)</p>
</li>
<li>
<p>only one entry will be evicted.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>As a result of this eviction process, when you check the size of your map, it is 19999. After
this eviction, subsequent put operations do not trigger the next eviction until the map size
is again close to the <code>max-size</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The above scenario is simply an example that describes how the eviction process works.
Hazelcast finds the most optimum number of entries to be evicted according to your cluster
size and selected policy.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="configuring-map-eviction"><a class="anchor" href="#configuring-map-eviction"></a>Configuring Map Eviction</h4>
<div class="paragraph">
<p>The following is an example declarative configuration for map eviction.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;max-idle-seconds&gt;0&lt;/max-idle-seconds&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="PER_NODE" size="5000"/&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      time-to-live-seconds: 0
      max-idle-seconds: 0
      eviction:
        eviction-policy: LRU
        max-size-policy: PER_NODE
        size: 5000</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the configuration element descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>time-to-live-seconds</code>: Maximum time in seconds for each entry to stay in the map (TTL).
It limits the lifetime of the entries relative to the time of the last write access
performed on them. If it is not 0, the entries whose lifetime exceeds this period
(without any write access performed on them during this period) are expired and
evicted automatically. An individual entry may have its own lifetime limit by
using one of the methods accepting a TTL; see <a href="#evicting-specific-entries">Evicting Specific Entries section</a>.
If there is no TTL value provided for the individual entry, it inherits the value
set for this element. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>.
Its default value is 0, which means infinite (no expiration and eviction). If it is not 0,
entries are evicted regardless of the set <code>eviction-policy</code> described below.</p>
</li>
<li>
<p><code>max-idle-seconds</code>: Maximum time in seconds for each entry to stay idle in
the map. It limits the lifetime of the entries relative to the time of the
last read or write access performed on them. The entries whose idle period
exceeds this limit are expired and evicted automatically. An entry is idle
if no <code>get</code>, <code>put</code>, <code>EntryProcessor.process</code> or <code>containsKey</code> is called on
it. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>.
Its default value is 0, which means infinite.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Setting this property to 1 second expires the entry after 1 second, regardless of
the operations done on that entry in-between, due to the loss of millisecond
resolution on the entry timestamps. Assume that you create a record at time = 1 second
(1000 milliseconds) and access it at wall clock time 1100 milliseconds and
then again at 1400 milliseconds. In this case, the entry is deemed as not touched.
So, setting this property to 1 second is not supported.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Both <code>time-to-live-seconds</code> and <code>max-idle-seconds</code> may be used simultaneously on
the map entries. In that case, the entry is considered expired if at least one of the
policies marks it as expired.
</td>
</tr>
</table>
</div>
</li>
<li>
<p><code>eviction-policy</code>: Eviction policy to be applied when the size of map grows larger than
the value specified by the <code>size</code> element described below.  Valid values are:</p>
<div class="ulist">
<ul>
<li>
<p>NONE: Default policy. If set, no items are evicted and the property <code>size</code> described
below is ignored. You still can combine it with <code>time-to-live-seconds</code> and <code>max-idle-seconds</code>.</p>
</li>
<li>
<p>LRU: Least Recently Used.</p>
</li>
<li>
<p>LFU: Least Frequently Used.</p>
<div class="paragraph">
<p>Apart from the above values, you can also develop and use your own eviction policy.
See the <a href="#custom-eviction-policy">Custom Eviction Policy section</a>.</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>size</code>: Maximum size of the map. When maximum size is reached, the map is evicted
based on the policy defined. Valid values are integers between 0 and <code>Integer.MAX VALUE</code>.
Its default value is 0, which means infinite. If you want <code>size</code> to work, set the
<code>eviction-policy</code> property to a value other than NONE. Its attributes are described below.</p>
<div class="ulist">
<ul>
<li>
<p><code>PER_NODE</code>: Maximum number of map entries in each cluster member. This is the default policy.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="PER_NODE" size="5000"/&gt;</code></p>
</div>
</li>
<li>
<p><code>PER_PARTITION</code>: Maximum number of map entries within each partition. Storage size depends
on the partition count in a cluster member. This attribute should not be used often. For instance,
avoid using this attribute with a small cluster. If the cluster is small, it hosts more partitions,
and therefore map entries, than that of a larger cluster. Thus, for a small cluster, eviction of
the entries decreases performance (the number of entries is large).</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="PER_PARTITION" size="27100" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_HEAP_SIZE</code>: Maximum used heap size in megabytes per map for each Hazelcast instance.
Please note that this policy does not work when <a href="#setting-in-memory-format">in-memory format</a>
is set to <code>OBJECT</code>, since the memory footprint cannot be determined when data is put as <code>OBJECT</code>.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_HEAP_SIZE" size="4096" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_HEAP_PERCENTAGE</code>: Maximum used heap size percentage per map for each Hazelcast instance.
If, for example, a JVM is configured to have 1000 MB and this value is 10, then the map entries
will be evicted when used heap size exceeds 100 MB. Please note that this policy does not work
when <a href="#setting-in-memory-format">in-memory format</a> is set to <code>OBJECT</code>, since the memory footprint
cannot be determined when data is put as <code>OBJECT</code>.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_HEAP_PERCENTAGE" size="10" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_HEAP_SIZE</code>: Minimum free heap size in megabytes for each JVM.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_HEAP_SIZE" size="512" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_HEAP_PERCENTAGE</code>: Minimum free heap size percentage for each JVM. If, for example, a JVM
is configured to have 1000 MB and this value is 10, then the map entries will be evicted when
free heap size is below 100 MB.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_HEAP_PERCENTAGE" size="10" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_SIZE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Maximum used native memory
size in megabytes per map for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_NATIVE_MEMORY_SIZE" size="1024" /&gt;</code></p>
</div>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_PERCENTAGE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Maximum used native
memory size percentage per map for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="USED_NATIVE_MEMORY_PERCENTAGE" size="65" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_SIZE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Minimum free native memory
size in megabytes for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_NATIVE_MEMORY_SIZE" size="256" /&gt;</code></p>
</div>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_PERCENTAGE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) Minimum free native
memory size percentage for each Hazelcast instance.</p>
<div class="paragraph">
<p><code>&lt;eviction max-size-policy="FREE_NATIVE_MEMORY_PERCENTAGE" size="5" /&gt;</code></p>
</div>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>To put it briefly, Hazelcast maps have no restrictions on the size and may grow arbitrarily
large, by default. When it comes to reducing the size of a map, there are two concepts:
expiration and eviction.</p>
</div>
<div class="paragraph">
<p>Expiration puts a limit on the maximum lifetime of an entry stored inside the map.
When the entry expires it cannot be retrieved from the map any longer and at some point
in time it will be cleaned out from the map to free up the memory. Expiration, and hence
the eviction based on the expiration, can be configured using the element <code>time-to-live-seconds</code>
and <code>max-idle-seconds</code> as described above.</p>
</div>
<div class="paragraph">
<p>Eviction puts a limit on the maximum size of the map. If the size of the map grows larger than
the maximum allowed size, an eviction policy decides which item to evict from the map to reduce
its size. The maximum allowed size can be configured using the element <code>size</code> and the
eviction policy can be configured using the element <code>eviction-policy</code> as described above.</p>
</div>
<div class="paragraph">
<p>Eviction and expiration can be used together. In this case, the expiration configurations
(<code>time-to-live-seconds</code> and <code>max-idle-seconds</code>) continue to work as usual cleaning out the
expired entries regardless of the map size. Note that locked map entries are not the subjects
for eviction and expiration.</p>
</div>
<div class="sect4">
<h5 id="example-eviction-configurations"><a class="anchor" href="#example-eviction-configurations"></a>Example Eviction Configurations</h5>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="documents"&gt;
        &lt;eviction eviction-policy="LRU" max-size-policy="PER_NODE" size="10000"/&gt;
        &lt;max-idle-seconds&gt;60&lt;/max-idle-seconds&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    documents:
      eviction:
        eviction-policy: LRU
        max-size-policy: PER_NODE
        size: 10000
      max-idle-seconds: 60</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, <code>documents</code> map starts to evict its entries from a member when the
map size exceeds 10000 in that member. Then the entries least recently used will be evicted.
The entries not used for more than 60 seconds will be evicted as well.</p>
</div>
<div class="paragraph">
<p>And the following is an example eviction configuration for a map having <code>NATIVE</code> as the
in-memory format:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="nativeMap"&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
        &lt;eviction max-size-policy="USED_NATIVE_MEMORY_PERCENTAGE" eviction-policy="LFU" size="99"/&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE
      eviction:
        eviction-policy: LFU
        max-size-policy: USED_NATIVE_MEMORY_PERCENTAGE
        size: 99</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="evicting-specific-entries"><a class="anchor" href="#evicting-specific-entries"></a>Evicting Specific Entries</h4>
<div class="paragraph">
<p>The eviction policies and configurations explained above apply to all the entries of a map.
The entries that meet the specified eviction conditions are evicted.</p>
</div>
<div class="paragraph">
<p>If you want to evict some specific map entries, you can use the <code>ttl</code> and <code>ttlUnit</code> parameters of
the method <code>map.put()</code>. An example code line is given below.</p>
</div>
<div class="paragraph">
<p><code>myMap.put( "1", "John", 50, TimeUnit.SECONDS )</code></p>
</div>
<div class="paragraph">
<p>The map entry with the key "1" will be evicted 50 seconds after it is put into <code>myMap</code>.</p>
</div>
<div class="paragraph">
<p>You may also use <code>map.setTTL</code> method to alter the time-to-live value of an existing entry.
It is done as follows:</p>
</div>
<div class="paragraph">
<p><code>myMap.setTTL( "1", 50, TimeUnit.SECONDS )</code></p>
</div>
<div class="paragraph">
<p>In addition to the <code>ttl</code>, you may also specify a maximum idle timeout for specific map entries
using the <code>maxIdle</code> and <code>maxIdleUnit</code> parameters:</p>
</div>
<div class="paragraph">
<p><code>myMap.put( "1", "John", 50, TimeUnit.SECONDS, 40, TimeUnit.SECONDS )</code></p>
</div>
<div class="paragraph">
<p>Here <code>ttl</code> is set as 50 seconds and <code>maxIdle</code> is set as 40 seconds. The entry is considered to
be evicted if at least one of these policies marks it as expired. If you want to specify only
the <code>maxIdle</code> parameter, you need to set <code>ttl</code> as 0 seconds.</p>
</div>
</div>
<div class="sect3">
<h4 id="evicting-all-entries"><a class="anchor" href="#evicting-all-entries"></a>Evicting All Entries</h4>
<div class="paragraph">
<p>To evict all keys from the map except the locked ones, use the method <code>evictAll()</code>.
If a MapStore is defined for the map, <code>deleteAll</code> is not called by <code>evictAll</code>. If
you want to call the method <code>deleteAll</code>, use <code>clear()</code>.</p>
</div>
<div class="paragraph">
<p>An example is given below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final int numberOfKeysToLock = 4;
        final int numberOfEntriesToAdd = 1000;

        HazelcastInstance node1 = Hazelcast.newHazelcastInstance();
        HazelcastInstance node2 = Hazelcast.newHazelcastInstance();

        IMap&lt;Integer, Integer&gt; map = node1.getMap( "map" );
        for (int i = 0; i &lt; numberOfEntriesToAdd; i++) {
            map.put(i, i);
        }

        for (int i = 0; i &lt; numberOfKeysToLock; i++) {
            map.lock(i);
        }

        // should keep locked keys and evict all others.
        map.evictAll();

        System.out.printf("# After calling evictAll...\n");
        System.out.printf("# Expected map size\t: %d\n", numberOfKeysToLock);
        System.out.printf("# Actual map size\t: %d\n", map.size());</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Only EVICT_ALL event is fired for any registered listeners.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="forced-eviction"><a class="anchor" href="#forced-eviction"></a>Forced Eviction</h4>
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast may use forced eviction in the cases when the eviction
explained in <a href="#understanding-map-eviction">Understanding Map Eviction</a>
is not enough to free up your memory. Note that this is valid if
you are using <strong class="blue">Hazelcast IMDG Enterprise</strong> and you set your
in-memory format to <code>NATIVE</code>.</p>
</div>
<div class="paragraph">
<p>The forced eviction mechanism is explained below as steps in the
given order:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When the normal eviction is not enough, forced eviction is
triggered and first it tries to evict approx. 20% of the entries
from the current partition. It retries this five times.</p>
</li>
<li>
<p>If the result of above step is still not enough, forced eviction
applies the above step to all maps. This time it might perform eviction
from some other partitions too, provided that they are owned by the same
thread.</p>
</li>
<li>
<p>If that is still not enough to free up your memory, it evicts not the
20% but all the entries from the current partition.</p>
</li>
<li>
<p>If that is not enough, it will evict all the entries from the other
data structures; from the partitions owned by the local thread.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Finally, when all the above steps are not enough, Hazelcast throws
a native <code>OutOfMemoryException</code>.</p>
</div>
<div class="paragraph">
<p>When you have an evictable cache/map, you should safely put
entries to it without facing with any memory shortages.
Forced eviction helps to achieve this. Regular eviction
removes one entry at a time while forced eviction can remove
multiple entries, which can even be owned by another caches/maps.</p>
</div>
</div>
<div class="sect3">
<h4 id="custom-eviction-policy"><a class="anchor" href="#custom-eviction-policy"></a>Custom Eviction Policy</h4>
<div class="paragraph">
<p>Apart from the policies such as LRU and LFU, which Hazelcast provides out-of-the-box,
you can develop and use your own eviction policy.</p>
</div>
<div class="paragraph">
<p>To achieve this, you need to provide an implementation of <code>MapEvictionPolicyComparator</code> as in
the following <code>OddEvictor</code> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapCustomEvictionPolicyComparator {

    public static void main(String[] args) {
        Config config = new Config();
        config.getMapConfig("test")
                .getEvictionConfig()
                .setComparator(new OddEvictor())
                .setMaxSizePolicy(PER_NODE)
                .setSize(10000);

        HazelcastInstance instance = Hazelcast.newHazelcastInstance(config);
        IMap&lt;Integer, Integer&gt; map = instance.getMap("test");

        final Queue&lt;Integer&gt; oddKeys = new ConcurrentLinkedQueue&lt;Integer&gt;();
        final Queue&lt;Integer&gt; evenKeys = new ConcurrentLinkedQueue&lt;Integer&gt;();

        map.addEntryListener((EntryEvictedListener&lt;Integer, Integer&gt;) event -&gt; {
            Integer key = event.getKey();
            if (key % 2 == 0) {
                evenKeys.add(key);
            } else {
                oddKeys.add(key);
            }
        }, false);

        // wait some more time to receive evicted-events
        parkNanos(SECONDS.toNanos(5));

        for (int i = 0; i &lt; 15000; i++) {
            map.put(i, i);
        }

        String msg = "IMap uses sampling based eviction. After eviction"
                + " is completed, we are expecting number of evicted-odd-keys"
                + " should be greater than number of evicted-even-keys. \nNumber"
                + " of evicted-odd-keys = %d, number of evicted-even-keys = %d";
        out.println(format(msg, oddKeys.size(), evenKeys.size()));

        instance.shutdown();
    }

    /**
     * Odd evictor tries to evict odd keys first.
     */
    private static class OddEvictor
            implements MapEvictionPolicyComparator&lt;Integer, Integer&gt; {

        @Override
        public int compare(EntryView&lt;Integer, Integer&gt; e1,
                           EntryView&lt;Integer, Integer&gt; e2) {

            Integer key1 = e1.getKey();
            if (key1 % 2 != 0) {
                return -1;
            }

            Integer key2 = e2.getKey();
            if (key2 % 2 != 0) {
                return 1;
            }

            return 0;
        }

    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can enable your policy by setting it via the method
<code>MapConfig.getEvictionConfig().setComparatorClassName()</code>
programmatically or via XML declaratively. Following is the example
declarative configuration for the eviction policy <code>OddEvictor</code> implemented above:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="test"&gt;
        ...
        &lt;eviction comparator-class-name="com.mycompany.OddEvictor"/&gt;
        ...
    &lt;/map&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    test:
      eviction:
        comparator-class-name: com.mycompany.OddEvictor</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you Hazelcast with Spring, you can enable your policy as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:map name="test"&gt;
    &lt;hz:map-eviction comparator-class-name="com.package.OddEvictor"/&gt;
&lt;/hz:map&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setting-in-memory-format"><a class="anchor" href="#setting-in-memory-format"></a>Setting In-Memory Format</h3>
<div class="paragraph">
<p>IMap (and a few other Hazelcast data structures, such as ICache)
has an <code>in-memory-format</code> configuration option. By default, Hazelcast
stores data into memory in binary (serialized) format. Sometimes it can
be efficient to store the entries in their object form, especially in cases
of local processing, such as entry processor and queries.</p>
</div>
<div class="paragraph">
<p>Specify the <code>in-memory-format</code> element in the configuration to set how the
data will be stored in the memory. You have the following format options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>BINARY</code> (default): The data (both the key and value) is stored in serialized
binary format. You can use this option if you mostly perform regular map
operations, such as <code>put</code> and <code>get</code>.</p>
</li>
<li>
<p><code>OBJECT</code>: The data is stored in deserialized form. This configuration is
good for maps where <a href="#entry-processor">entry processing</a> and <a href="#how-distributed-query-works">queries</a> form the majority of all
operations and the objects are complex, making the serialization cost comparatively
high. By storing objects, entry processing does not contain the deserialization
cost. Note that when you use <code>OBJECT</code> as the in-memory format, the key is still
stored in binary format and the value is stored in object format.</p>
</li>
<li>
<p><code>NATIVE</code>: (<strong class="navy">Hazelcast IMDG Enterprise HD</strong>) This format behaves the same as
BINARY, however, instead of heap memory, key and value are stored in the off-heap
memory.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Regular operations like <code>get</code> rely on the object instance. When the <code>OBJECT</code> format
is used and a <code>get</code> is performed, the map does not return the stored instance,
but creates a clone. Therefore, this whole <code>get</code> operation first includes a
serialization on the member owning the instance and then a deserialization on
the member calling the instance. When the <code>BINARY</code> format is used, only a
deserialization is required; <code>BINARY</code> is faster.</p>
</div>
<div class="paragraph">
<p>Similarly, a <code>put</code> operation is faster when the <code>BINARY</code> format is used. If the
format was <code>OBJECT</code>, the map would create a clone of the instance, and there would
first be a serialization and then a deserialization. When BINARY is used, only a
deserialization is needed.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a value is stored in <code>OBJECT</code> format, a change on a returned value does not
affect the stored instance. In this case, the returned instance is not the actual one
but a clone. Therefore, changes made on an object after it is returned will not reflect
on the actual stored data. Similarly, when a value is written to a map and the value is
stored in <code>OBJECT</code> format, it will be a copy of the <code>put</code> value. Therefore, changes made
on the object after it is stored will not reflect on the stored data.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="using-high-density-memory-store-with-map"><a class="anchor" href="#using-high-density-memory-store-with-map"></a>Using High-Density Memory Store with Map</h3>
<div class="paragraph">
<p><strong class="navy">Hazelcast IMDG Enterprise HD</strong></p>
</div>
<div class="paragraph">
<p>Hazelcast instances are Java programs. In case of <code>BINARY</code> and <code>OBJECT</code> in-memory
formats, Hazelcast stores your distributed data into the heap of its server instances.
Java heap is subject to garbage collection (GC). In case of larger heaps, garbage
collection might cause your application to pause for tens of seconds (even minutes
for really large heaps), badly affecting your application performance and response times.</p>
</div>
<div class="paragraph">
<p>As the data gets bigger, you either run the application with larger heap, which would
result in longer GC pauses or run multiple instances with smaller heap which can turn
into an operational nightmare if the number of such instances becomes very high.</p>
</div>
<div class="paragraph">
<p>To overcome this challenge, Hazelcast offers High-Density Memory Store for your maps.
You can configure your map to use High-Density Memory Store by setting the in-memory
format to <code>NATIVE</code>. The following snippet is the declarative configuration example.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="nativeMap"&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE</code></pre>
</div>
</div>
<div class="paragraph">
<p>Keep in mind that you should have already enabled the High-Density Memory Store
usage for your cluster. See the <a href="#configuring-high-density-memory-store">Configuring High-Density Memory Store section</a>.</p>
</div>
<div class="paragraph">
<p>You can also benefit from the persistent memory technologies such as
Intel&#174; Optane&#8482; DC to be used by the High-Density Memory Store. See the
<a href="#using-persistent-memory">Using Persistent Memory section</a>.</p>
</div>
<div class="sect3">
<h4 id="required-configuration-changes-when-using-native"><a class="anchor" href="#required-configuration-changes-when-using-native"></a>Required Configuration Changes When Using NATIVE</h4>
<div class="paragraph">
<p>Note that the eviction mechanism is different for <code>NATIVE</code> in-memory format.
The new eviction algorithm for map with High-Density Memory Store is similar
to that of JCache with High-Density Memory Store and is described <a href="#eviction-algorithm">here</a>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="nativeMap"&gt;
        &lt;in-memory-format&gt;NATIVE&lt;/in-memory-format&gt;
        &lt;eviction-percentage&gt;25&lt;/eviction-percentage&gt; &lt;--! NO IMPACT with NATIVE --&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    nativeMap:
      in-memory-format: NATIVE
      eviction-percentage: 25 # NO IMPACT with NATIVE</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>These IMap eviction policies for <code>size</code> cannot be used: <code>FREE_HEAP_PERCENTAGE</code>,
<code>FREE_HEAP_SIZE</code>, <code>USED_HEAP_PERCENTAGE</code>, <code>USED_HEAP_SIZE</code>.</p>
</li>
<li>
<p>Near Cache eviction policy <code>ENTRY_COUNT</code> cannot be used for
<code>max-size-policy</code>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#high-density-memory-store">High-Density Memory Store section</a>
for more information.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_metadata_policy"><a class="anchor" href="#_metadata_policy"></a>Metadata Policy</h3>
<div class="paragraph">
<p>Hazelcast IMap offers automatic preprocessing of various data types on the
update time to make queries faster. It is currently supported only by the
<a href="#querying-json-strings">HazelcastJsonValue</a> type. When metadata creation
is on, IMap creates additional metadata about the objects of supported types
and uses this metadata during the querying. It does not affect the latency
and throughput of the object of any type except the supported types.</p>
</div>
<div class="paragraph">
<p>This feature is on by default. You can configure it using the <code>metadata-policy</code>
configuration element.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="map-a"&gt;
        &lt;!--
        valid values for metadata-policy are:
          - OFF
          - CREATE_ON_UPDATE (default)
        --&gt;
        &lt;metadata-policy&gt;OFF&lt;/metadata-policy&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    map-a:
    # valid values for metadata-policy are:
    # - OFF
    # - CREATE_ON_UPDATE (default)
      metadata-policy: OFF</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">MapConfig mapConfig = new MapConfig();
mapConfig.setMetadataPolicy(MetadataPolicy.OFF);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="loading-and-storing-persistent-data"><a class="anchor" href="#loading-and-storing-persistent-data"></a>Loading and Storing Persistent Data</h3>
<div class="paragraph">
<p>Hazelcast allows you to load and store the distributed map entries
from/to a persistent data store such as a relational database. To do this,
you can use Hazelcast&#8217;s <code>MapStore</code> and <code>MapLoader</code> interfaces.</p>
</div>
<div class="paragraph">
<p>When you provide a <code>MapLoader</code> implementation and request an entry
(<code>IMap.get()</code>) that does not exist in memory, <code>MapLoader</code>'s <code>load</code>
method loads that entry from the data store. This loaded entry is placed
into the map and will stay there until it is removed or evicted.</p>
</div>
<div class="paragraph">
<p>All loads can be listened via <code>EntryLoadedListener</code>. See the
<a href="#listening-for-map-events">Listening for Map Events section</a>
to learn how you can catch entry-based events.</p>
</div>
<div class="paragraph">
<p>When a <code>MapStore</code> implementation is provided, an entry is also put into a
user defined data store.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Data store needs to be a centralized system that is
accessible from all Hazelcast members. Persistence to a local file system
is not supported.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Also note that the <code>MapStore</code> interface extends the <code>MapLoader</code> interface
as you can see in the interface <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/MapStore.html" target="_blank" rel="noopener">code</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Following is a <code>MapStore</code> example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonMapStore implements MapStore&lt;Long, Person&gt; {

    private final Connection con;
    private final PreparedStatement allKeysStatement;

    public PersonMapStore() {
        try {
            con = DriverManager.getConnection("jdbc:hsqldb:mydatabase", "SA", "");
            con.createStatement().executeUpdate(
                    "create table if not exists person (id bigint not null, name varchar(45), primary key (id))");
            allKeysStatement = con.prepareStatement("select id from person");
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void delete(Long key) {
        System.out.println("Delete:" + key);
        try {
            con.createStatement().executeUpdate(
                    format("delete from person where id = %s", key));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void store(Long key, Person value) {
        try {
            con.createStatement().executeUpdate(
                    format("insert into person values(%s,'%s')", key, value.getName()));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized void storeAll(Map&lt;Long, Person&gt; map) {
        for (Map.Entry&lt;Long, Person&gt; entry : map.entrySet()) {
            store(entry.getKey(), entry.getValue());
        }
    }

    public synchronized void deleteAll(Collection&lt;Long&gt; keys) {
        for (Long key : keys) {
            delete(key);
        }
    }

    public synchronized Person load(Long key) {
        try {
            ResultSet resultSet = con.createStatement().executeQuery(
                    format("select name from person where id =%s", key));
            try {
                if (!resultSet.next()) {
                    return null;
                }
                String name = resultSet.getString(1);
                return new Person(key, name);
            } finally {
                resultSet.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    public synchronized Map&lt;Long, Person&gt; loadAll(Collection&lt;Long&gt; keys) {
        Map&lt;Long, Person&gt; result = new HashMap&lt;Long, Person&gt;();
        for (Long key : keys) {
            result.put(key, load(key));
        }
        return result;
    }

    public Iterable&lt;Long&gt; loadAllKeys() {
        return new StatementIterable&lt;Long&gt;(allKeysStatement);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
During the initial loading process, MapStore uses a thread different from the
partition threads that are used by the ExecutorService. After the initialization is
completed, the <code>map.get</code> method looks up any nonexistent value from the database in
a partition thread, or the <code>map.put</code> method looks up the database to return the previously
associated value for a key also in a partition thread.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Entries loaded by <code>MapLoader</code> do not have a set time-to-live property. Therefore,
they live until evicted or explicitly removed. It is possible to enforce time-to-live
on the entries by using <code>EntryLoader</code>. <code>EntryLoader</code> allows you to set
time-to-live values per key before handing the values to Hazelcast. Therefore, you can store and
load key specific time-to-live values in the external storage.</p>
</div>
<div class="paragraph">
<p>Similar to <code>EntryLoader</code>, in order to store custom expiration times associated
with the entries, you may use <code>EntryStore</code>. <code>EntryStore</code> allows you to
retrieve associated expiration date for each entry. The expiration date is an offset
from an epoch in milliseconds. Epoch is January 1, 1970 UTC which is used by
<code>System.currentTimeMillis()</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Although the expiration date is expressed in milliseconds, IMap has second granularity
when it comes to expiration. Therefore, the expiration date is rounded to the nearest lower
whole second.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>EntryLoader</code> and <code>EntryStore</code> extend from <code>MapLoader</code> and <code>MapStore</code>, respectively.
Therefore, all features and configuration parameters of <code>MapLoader</code> and <code>MapStore</code> apply
to them, too.</p>
</div>
<div class="paragraph">
<p>Following is an <code>EntryStore</code> example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PersonEntryStore implements EntryStore&lt;Long, Person&gt; {

    private final Connection con;
    private final PreparedStatement allKeysStatement;

    public PersonEntryStore() {
        try {
            con = DriverManager.getConnection("jdbc:hsqldb:mydatabase", "SA", "");
            con.createStatement().executeUpdate(
                    "create table if not exists person (id bigint not null, name varchar(45), expiration-date bigint, primary key (id))");
            allKeysStatement = con.prepareStatement("select id from person");
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public synchronized void delete(Long key) {
        System.out.println("Delete:" + key);
        try {
            con.createStatement().executeUpdate(
                    format("delete from person where id = %s", key));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public synchronized void store(Long key, MetadataAwareValue&lt;Person&gt; value) {
        try {
            con.createStatement().executeUpdate(
                    format("insert into person values(%s,'%s', %d)", key, value.getValue().getName(), value.getExpirationTime()));
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public void storeAll(Map&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; map) {
        for (Map.Entry&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; entry : map.entrySet()) {
            store(entry.getKey(), entry.getValue());
        }
    }

    @Override
    public synchronized void deleteAll(Collection&lt;Long&gt; keys) {
        for (Long key : keys) {
            delete(key);
        }
    }

    @Override
    public synchronized MetadataAwareValue&lt;Person&gt; load(Long key) {
        try {
            ResultSet resultSet = con.createStatement().executeQuery(
                    format("select name,expiration-date from person where id =%s", key));
            try {
                if (!resultSet.next()) {
                    return null;
                }
                String name = resultSet.getString(1);
                Long expirationDate = resultSet.getLong(2);
                return new MetadataAwareValue&lt;&gt;(new Person(key, name), expirationDate);
            } finally {
                resultSet.close();
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }

    @Override
    public synchronized Map&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; loadAll(Collection&lt;Long&gt; keys) {
        Map&lt;Long, MetadataAwareValue&lt;Person&gt;&gt; result = new HashMap&lt;&gt;();
        for (Long key : keys) {
            result.put(key, load(key));
        }
        return result;
    }

    public Iterable&lt;Long&gt; loadAllKeys() {
        return new StatementIterable&lt;Long&gt;(allKeysStatement);
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For more MapStore/MapLoader code samples,
see <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/distributed-map/mapstore/src/main/java" target="_blank" rel="noopener">here</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast supports read-through, write-through and write-behind persistence
modes, which are explained in the subsections below.</p>
</div>
<div class="sect3">
<h4 id="using-read-through-persistence"><a class="anchor" href="#using-read-through-persistence"></a>Using Read-Through Persistence</h4>
<div class="paragraph">
<p>If an entry does not exist in memory when an application asks for it,
Hazelcast asks the loader implementation to load that entry from the
data store.  If the entry exists there, the loader implementation gets it,
hands it to Hazelcast, and Hazelcast puts it into memory. This is read-through
persistence mode.</p>
</div>
<div class="paragraph">
<p>As you can remember from the introduction of this section, the <code>IMap.get()</code> method
triggers the <code>load()</code> method in your MapLoader implementation if an entry does not
exist in the memory. In this case, note that the <code>IMap.get()</code> method does not create
backup copies for such entries, when the mode is read-through persistence: there is no
need for backups for these entries since if the primary entry is lost, then a read for
the key triggers the <code>load()</code> method and loads the entry from the persistence layer.</p>
</div>
</div>
<div class="sect3">
<h4 id="setting-write-through-persistence"><a class="anchor" href="#setting-write-through-persistence"></a>Setting Write-Through Persistence</h4>
<div class="paragraph">
<p><code>MapStore</code> can be configured to be write-through by setting the <code>write-delay-seconds</code>
property to <strong>0</strong>. This means the entries are put to the data store synchronously.</p>
</div>
<div class="paragraph">
<p>In this mode, when the <code>map.put(key,value)</code> call returns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>MapStore.store(key,value)</code> is successfully called so the entry is persisted.</p>
</li>
<li>
<p>In-Memory entry is updated.</p>
</li>
<li>
<p>In-Memory backup copies are successfully created on other cluster members
(if <code>backup-count</code> is greater than 0).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If <code>MapStore</code> throws an exception then the exception is propagated to the original
<code>put</code> or <code>remove</code> call in the form of <code>RuntimeException</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
There is a key difference in the behaviors of <code>map.remove(key)</code> and
<code>map.delete(key)</code>, i.e., the latter results in <code>MapStore.delete(key)</code> to be invoked
whereas the former only removes the entry from IMap.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="setting-write-behind-persistence"><a class="anchor" href="#setting-write-behind-persistence"></a>Setting Write-Behind Persistence</h4>
<div class="paragraph">
<p>You can configure <code>MapStore</code> as write-behind by setting the <code>write-delay-seconds</code>
property to a value bigger than <strong>0</strong>. This means the modified entries will be
put to the data store asynchronously after a configured delay.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
In write-behind mode, Hazelcast coalesces updates on a specific key by
default, which means it applies only the last update on that key. However,
you can set <code>MapStoreConfig.setWriteCoalescing()</code> to <code>FALSE</code> and you can store
all updates performed on a key to the data store.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When you set <code>MapStoreConfig.setWriteCoalescing()</code> to <code>FALSE</code>, after you
reached per-node maximum write-behind-queue capacity, subsequent put operations
will fail with <code>ReachedMaxSizeException</code>. This exception is thrown to prevent
uncontrolled grow of write-behind queues. You can set per-node maximum capacity
using the system property <code>hazelcast.map.write.behind.queue.capacity</code>. See the
<a href="#system-properties">System Properties appendix</a> for information on this property
and how to set the system properties.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In write-behind mode, when the <code>map.put(key,value)</code> call returns:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>in-memory entry is updated</p>
</li>
<li>
<p>in-memory backup copies are successfully created on the other cluster members
(if <code>backup-count</code> is greater than 0)</p>
</li>
<li>
<p>the entry is marked as dirty so that after <code>write-delay-seconds</code>, it can be
persisted with <code>MapStore.store(key,value)</code> call</p>
</li>
<li>
<p>and for fault tolerance, dirty entries are stored in a queue on the primary
member and also on a back-up member.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The same behavior goes for the <code>map.remove(key)</code>, the only difference is that
<code>MapStore.delete(key)</code> is called when the entry will be deleted.</p>
</div>
<div class="paragraph">
<p>If <code>MapStore</code> throws an exception, then Hazelcast tries to store the entry again.
If the entry still cannot be stored, a log message is printed and the entry is re-queued.</p>
</div>
<div class="paragraph">
<p>For batch write operations, which are only allowed in write-behind mode,
Hazelcast calls the <code>MapStore.storeAll(map)</code> and <code>MapStore.deleteAll(collection)</code>
methods to do all writes in a single call.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a map entry is marked as dirty, meaning that it is waiting to be
persisted to the <code>MapStore</code> in a write-behind scenario, the eviction process
forces the entry to be stored. This way you have control over the number of
entries waiting to be stored, and thus you can prevent a possible OutOfMemory
exception.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>MapStore</code> or <code>MapLoader</code> implementations should not use
Hazelcast Map/Queue/MultiMap/List/Set operations. Your implementation should
only work with your data store. Otherwise, you may get into deadlock situations.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Here is an example configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;map-store enabled="true" initial-mode="LAZY"&gt;
            &lt;class-name&gt;com.hazelcast.examples.DummyStore&lt;/class-name&gt;
            &lt;write-delay-seconds&gt;60&lt;/write-delay-seconds&gt;
            &lt;write-batch-size&gt;1000&lt;/write-batch-size&gt;
            &lt;write-coalescing&gt;true&lt;/write-coalescing&gt;
        &lt;/map-store&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      map-store:
        enabled: true
        initial-mode: LAZY
        class-name: com.hazelcast.examples.DummyStore
        write-delay-seconds: 60
        write-batch-size: 1000
        write-coalescing: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of MapStore configuration elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class-name</code>: Name of the class implementing MapLoader and/or MapStore.</p>
</li>
<li>
<p><code>write-delay-seconds</code>: Number of seconds to delay to call the
MapStore.store(key, value). If the value is zero then it is write-through,
so the <code>MapStore.store(key,value)</code> method is called as soon as the entry is
updated. Otherwise, it is write-behind; so the updates will be stored after
the <code>write-delay-seconds</code> value by calling the <code>Hazelcast.storeAll(map)</code> method.
Its default value is 0.</p>
</li>
<li>
<p><code>write-batch-size</code>: Used to create batch chunks when writing map store. In
default mode, all map entries are tried to be written in one go. To create
batch chunks, the minimum meaningful value for write-batch-size is 2. For values
smaller than 2, it works as in default mode.</p>
</li>
<li>
<p><code>write-coalescing</code>: In write-behind mode, Hazelcast coalesces updates on a
specific key by default; it applies only the last update on it. You can set this
element to <code>false</code> to store all updates performed on a key to the data store.</p>
</li>
<li>
<p><code>enabled</code>: True to enable this map-store, false to disable. Its default value
is true.</p>
</li>
<li>
<p><code>initial-mode</code>: Sets the initial load mode. LAZY is the default load mode, where
load is asynchronous. EAGER means load is blocked till all partitions are loaded.
See the <a href="#initializing-map-on-startup">Initializing Map on Startup section</a> for
more details.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_managing_the_lifecycle_of_a_maploader"><a class="anchor" href="#_managing_the_lifecycle_of_a_maploader"></a>Managing the Lifecycle of a MapLoader</h4>
<div class="paragraph">
<p>With <code>MapLoader</code> (and <code>MapStore</code> which extends it), you can do the regular store and load operations.
If you need to perform other operations on create or on destroy of a <code>MapLoader</code>,
such as establishing a connection to a database or accessing to other Hazelcast maps,
you need to implement the <code>MapLoaderLifeCycleSupport</code> interface. By implementing
it, you will have the <code>init()</code> and <code>destroy()</code> methods.</p>
</div>
<div class="paragraph">
<p>The <code>init()</code> method initializes the <code>MapLoader</code> implementation. Hazelcast calls
this method when the map is first created on a Hazelcast instance. The <code>MapLoader</code>
implementation can initialize the required resources
such as reading a configuration file or creating a database connection
or accessing a Hazelcast instance.</p>
</div>
<div class="paragraph">
<p>The <code>destroy()</code> method is called during the graceful shutdown of a Hazelcast instance.
You can override this method  to cleanup the resources held by the <code>MapLoader</code> implementation, such as
closing the database connections.</p>
</div>
<div class="paragraph">
<p>In summary, you need <code>MapLoaderLifecycleSupport</code> to perform actions
on create and on destroy of a <code>MapLoader</code>.</p>
</div>
<div class="paragraph">
<p>See <a href="https://github.com/hazelcast/hazelcast-code-samples/blob/master/hazelcast-integration/mongodb/src/main/java/com/hazelcast/loader/MongoMapStore.java" target="_blank" rel="noopener">here</a> to see this interface in action.</p>
</div>
</div>
<div class="sect3">
<h4 id="storing-entries-to-multiple-maps"><a class="anchor" href="#storing-entries-to-multiple-maps"></a>Storing Entries to Multiple Maps</h4>
<div class="paragraph">
<p>A configuration can be applied to more than one map using wildcards
(see <a href="#using-wildcards">Using Wildcards</a>), meaning that the configuration is
shared among the maps. But <code>MapStore</code> does not know which entries to store
when there is one configuration applied to multiple maps.</p>
</div>
<div class="paragraph">
<p>To store entries when there is one configuration applied to multiple maps,
use Hazelcast&#8217;s <code>MapStoreFactory</code> interface. Using the <code>MapStoreFactory</code> interface,
<code>MapStore</code>s for each map can be created when a wildcard configuration is used.
Example code is shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
MapConfig mapConfig = config.getMapConfig( "*" );
MapStoreConfig mapStoreConfig = mapConfig.getMapStoreConfig();
mapStoreConfig.setFactoryImplementation( new MapStoreFactory&lt;Object, Object&gt;() {
    @Override
    public MapLoader&lt;Object, Object&gt; newMapStore( String mapName, Properties properties ) {
        return null;
    }
});</code></pre>
</div>
</div>
<div class="paragraph">
<p>To initialize the <code>MapLoader</code> implementation with the given map name, configuration
properties and the Hazelcast instance, implement the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/MapLoaderLifecycleSupport.html" target="_blank" rel="noopener"><code>MapLoaderLifecycleSupport</code> interface</a>
which is described in the previous section.</p>
</div>
</div>
<div class="sect3">
<h4 id="initializing-map-on-startup"><a class="anchor" href="#initializing-map-on-startup"></a>Initializing Map on Startup</h4>
<div class="paragraph">
<p>To pre-populate the in-memory map when the map is first touched/used,
use the <code>MapLoader.loadAllKeys</code> API.</p>
</div>
<div class="paragraph">
<p>If <code>MapLoader.loadAllKeys</code> returns NULL, then nothing will be loaded.
Your <code>MapLoader.loadAllKeys</code> implementation can return all or some of the
keys. For example, you may select and return only the keys which are most
important to you that you want to load them while initializing the map.
<code>MapLoader.loadAllKeys</code> is the fastest way of pre-populating the map since
Hazelcast optimizes the loading process by having each cluster member load
its owned portion of the entries.</p>
</div>
<div class="paragraph">
<p>The <code>InitialLoadMode</code> configuration parameter in the class
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/MapStoreConfig.html" target="_blank" rel="noopener">MapStoreConfig</a>
has two values: <code>LAZY</code> and <code>EAGER</code>. If <code>InitialLoadMode</code> is set to
<code>LAZY</code>, data is not loaded during the map creation. If it is set to
<code>EAGER</code>, all the data is loaded while the map is created and everything becomes
ready to use. Also, if you add indices to your map with the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/IndexConfig.html" target="_blank" rel="noopener">IndexConfig</a>
class or the <a href="#indexing-queries"><code>addIndex</code></a> method, then
<code>InitialLoadMode</code> is overridden and <code>MapStoreConfig</code> behaves as if <code>EAGER</code> mode is on.</p>
</div>
<div class="paragraph">
<p>Here is the <code>MapLoader</code> initialization flow:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>When <code>getMap()</code> is first called from any member, initialization starts
depending on the value of <code>InitialLoadMode</code>. If it is set to <code>EAGER</code>,
initialization starts on all partitions as soon as the map is touched,
i.e., all partitions are loaded when <code>getMap</code> is called.  If it is set to
<code>LAZY</code>, data is loaded partition by partition, i.e., each partition is
loaded with its first touch.</p>
</li>
<li>
<p>Hazelcast calls <code>MapLoader.loadAllKeys()</code> to get all your
keys on one of the members.</p>
</li>
<li>
<p>That member distributes keys to all other members in batches.</p>
</li>
<li>
<p>Each member loads values of all its owned keys by calling
<code>MapLoader.loadAll(keys)</code>.</p>
</li>
<li>
<p>Each member puts its owned entries into the map by calling
<code>IMap.putTransient(key,value)</code>.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If the load mode is <code>LAZY</code> and the <code>clear()</code> method is called
(which triggers <code>MapStore.deleteAll()</code>), Hazelcast removes <strong>ONLY</strong> the
loaded entries from your map and datastore. Since all the data is not loaded
in this case (<code>LAZY</code> mode), please note that there may still be entries
in your datastore.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not want the MapStore start to load as soon as the
first cluster member starts, you can use the system property <code>hazelcast.initial.min.cluster.size</code>.
For example, if you set its value as <code>3</code>, loading process will be
blocked until all three members are completely up.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The return type of <code>loadAllKeys()</code> is changed from <code>Set</code> to <code>Iterable</code>
with the release of Hazelcast 3.5. MapLoader implementations from previous
releases are also supported and do not need to be adapted.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="loading-keys-incrementally"><a class="anchor" href="#loading-keys-incrementally"></a>Loading Keys Incrementally</h4>
<div class="paragraph">
<p>If the number of keys to load is large, it is more efficient to
load them incrementally rather than loading them all at once. To support
incremental loading, the <code>MapLoader.loadAllKeys()</code> method returns an <code>Iterable</code>
which can be lazily populated with the results of a database query.</p>
</div>
<div class="paragraph">
<p>Hazelcast iterates over the <code>Iterable</code> and, while doing so, sends out the keys
to their respective owner members. The <code>Iterator</code> obtained from <code>MapLoader.loadAllKeys()</code>
may also implement the <code>Closeable</code> interface, in which case <code>Iterator</code> is closed
once the iteration is over. This is intended for releasing resources such as
closing a JDBC result set.</p>
</div>
</div>
<div class="sect3">
<h4 id="forcing-all-keys-to-be-loaded"><a class="anchor" href="#forcing-all-keys-to-be-loaded"></a>Forcing All Keys To Be Loaded</h4>
<div class="paragraph">
<p>The method <code>loadAll</code> loads some or all keys into a data store in order to
optimize the multiple load operations. The method has two signatures; the
same method can take two different parameter lists. One signature loads the
given keys and the other loads all keys. See the example code below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final int numberOfEntriesToAdd = 1000;
        final String mapName = LoadAll.class.getCanonicalName();
        final Config config = createNewConfig(mapName);
        final HazelcastInstance node = Hazelcast.newHazelcastInstance(config);
        final IMap&lt;Integer, Integer&gt; map = node.getMap(mapName);

        populateMap(map, numberOfEntriesToAdd);
        System.out.printf("# Map store has %d elements\n", numberOfEntriesToAdd);

        map.evictAll();
        System.out.printf("# After evictAll map size\t: %d\n", map.size());

        map.loadAll(true);
        System.out.printf("# After loadAll map size\t: %d\n", map.size());</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="post-processing-objects-in-map-store"><a class="anchor" href="#post-processing-objects-in-map-store"></a>Post-Processing Objects in Map Store</h4>
<div class="paragraph">
<p>In some scenarios, you may need to modify the object after storing it into
the map store.
For example, you can get an ID or version auto-generated by your database and
then need to modify your object stored in the distributed map, but not to break
the synchronization between the database and the data grid.</p>
</div>
<div class="paragraph">
<p>To post-process an object in the map store, implement the <code>PostProcessingMapStore</code>
interface to put the modified object into the distributed map. This triggers an
extra step of <code>Serialization</code>, so use it only when needed. (This is only valid
when using the <code>write-through</code> map store configuration.)</p>
</div>
<div class="paragraph">
<p>Here is an example of post processing map store:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ProcessingStore implements MapStore&lt;Integer, Employee&gt;, PostProcessingMapStore {
    @Override
    public void store( Integer key, Employee employee ) {
        EmployeeId id = saveEmployee();
        employee.setId( id.getId() );
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Please note that if you are using a post-processing map store in
combination with the entry processors, post-processed values will not be
carried to backups.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="accessing-a-database-using-properties"><a class="anchor" href="#accessing-a-database-using-properties"></a>Accessing a Database Using <code>Properties</code></h4>
<div class="paragraph">
<p>You can prepare your own <code>MapLoader</code> to access a database such as Cassandra
and MongoDB. For this, you can first declaratively specify the database properties
in your <code>hazelcast.xml</code> configuration file and then implement the
<code>MapLoaderLifecycleSupport</code> interface to pass those properties.</p>
</div>
<div class="paragraph">
<p>You can define the database properties, such as its URL and name, using the
<code>properties</code> configuration element. The following is a configuration example
for MongoDB:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="supplements"&gt;
        &lt;map-store enabled="true" initial-mode="LAZY"&gt;
            &lt;class-name&gt;com.hazelcast.loader.YourMapStoreImplementation&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="mongo.url"&gt;mongodb://localhost:27017&lt;/property&gt;
                &lt;property name="mongo.db"&gt;mydb&lt;/property&gt;
                &lt;property name="mongo.collection"&gt;supplements&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/map-store&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    supplements:
      map-store:
        enabled: true
        initial-mode: LAZY
        class-name: com.hazelcast.loader.YourMapStoreImplementation
        properties:
          mongo_url: mongodb://localhost:27017
          mongo.db: mydb
          mango.collection: supplements</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you specified the database properties in your configuration,
you need to implement the <code>MapLoaderLifecycleSupport</code> interface and
give those properties in the <code>init()</code> method, as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class YourMapStoreImplementation implements MapStore&lt;String, Supplement&gt;, MapLoaderLifecycleSupport {

    private MongoClient mongoClient;
    private MongoCollection collection;

    public YourMapStoreImplementation() {
    }

    @Override
    public void init(HazelcastInstance hazelcastInstance, Properties properties, String mapName) {
        String mongoUrl = (String) properties.get("mongo.url");
        String dbName = (String) properties.get("mongo.db");
        String collectionName = (String) properties.get("mongo.collection");
        this.mongoClient = new MongoClient(new MongoClientURI(mongoUrl));
        this.collection = mongoClient.getDatabase(dbName).getCollection(collectionName);
    }</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the full example <a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/hazelcast-integration/mongodb" target="_blank" rel="noopener">here</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="map-mapstore"><a class="anchor" href="#map-mapstore"></a>MapStore and MapLoader Methods Triggered by IMap Operations</h4>
<div class="paragraph">
<p>As it is explained in the above sections, you can configure
Hazelcast maps to be backed
by a map store to persist the entries. In this case many of the
IMap methods call
MapLoader or MapStore methods to load, store or remove data. This
section summarizes
these methods. Here are the Hazelcast IMap operations that may
trigger the MapStore or MapLoader methods:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 16.6666%;">
<col style="width: 83.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">IMap Method</th>
<th class="tableblock halign-left valign-top">Impact on the MapStore/MapLoader</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>flush()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>If the map has a MapStore, this method flushes all the local dirty
entries. It calls the <code>MapStore.storeAll(Map)</code> or
<code>MapStore.deleteAll(Collection)</code> methods with the elements marked as dirty.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>put()</code></p>
</li>
<li>
<p><code>putAll()</code></p>
</li>
<li>
<p><code>putAsync()</code></p>
</li>
<li>
<p><code>tryPut()</code></p>
</li>
<li>
<p><code>putIfAbsent()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods are used to put entries to the map. They call the
<code>MapLoader.load(Object)</code> method for each entry not found in the memory
to load the value from the map store backing the map. They also call the
<code>MapStore.store(Object, Object)</code> method for each entry, if write-through
persistence mode is configured before the entry is added into the memory.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>set()</code></p>
</li>
<li>
<p><code>setAsync()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods put an entry into the map without returning the old value.
They call the <code>MapStore.store(Object, Object)</code> method if write-through
persistence mode is configured before the entry is added into the memory,
to write the value into the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>remove()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>Removes the mapping for a key from the map if it is present. It calls the
<code>MapLoader.load(Object)</code> method if no value is found with key in the memory,
to load the value from the map store backing the map. It also calls the
<code>MapStore.delete(Object)</code> method if write-through persistence mode is
configured before the value is removed from the memory, to remove the value
from the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>removeAll()</code></p>
</li>
<li>
<p><code>delete()</code></p>
</li>
<li>
<p><code>removeAsync()</code></p>
</li>
<li>
<p><code>tryRemove()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods are used to remove entries from the map for various conditions.
They call the <code>MapStore.delete(Object)</code> method if write-through persistence mode
is configured before the value is removed from the memory, to remove the value
from the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>setTtl</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>This method updates time-to-live of an existing entry. It calls the <code>MapLoader.load(Object)</code>
method if no value is found in the memory. It also calls <code>EntryStore.store(Object, MetadataAwareValue)</code>
with the entry whose time-to-live has been updated.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>clear()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It clears the map and deletes the items from the backing map store. It calls
the <code>MapStore.deleteAll(Collection)</code> method on each partition with the keys that the
given partition stores.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><code>replace()</code></p>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>It replaces the entry for a key only if currently mapped to a given value.
It calls the <code>MapStore.store(Object, Object)</code> method if write-through persistence
mode is configured before the value is stored in the memory, to write the value into
the map store.</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><code>executeOnKey()</code></p>
</li>
<li>
<p><code>executeOnKeys()</code></p>
</li>
<li>
<p><code>submitToKey()</code></p>
</li>
<li>
<p><code>executeOnAllEntries()</code></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>These methods apply the user defined entry processors to the entry or entries.
They call the <code>MapLoader.load(Object)</code> method if the value with key is not found in the
memory, to load the value from the map store backing the map. If the entry processor
updates the entry and write-through persistence mode is configured, before the value is
stored in memory, they call the <code>MapStore.store(Object, Object)</code> method to write the value
into the map store. If the entry processor updates the entry&#8217;s value to null value and write-through
persistence mode is configured, before the value is removed from the memory, they call the
<code>MapStore.delete(Object)</code> method to delete the value from the map store.</p>
</div></div></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="creating-near-cache-for-map"><a class="anchor" href="#creating-near-cache-for-map"></a>Creating Near Cache for Map</h3>
<div class="paragraph">
<p>The Hazelcast distributed map supports a local Near Cache for
remotely stored entries to increase the performance of local
read operations. See the <a href="#near-cache">Near Cache section</a> for a
detailed explanation of the Near Cache feature and its configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="locking-maps"><a class="anchor" href="#locking-maps"></a>Locking Maps</h3>
<div class="paragraph">
<p>Hazelcast Distributed Map (IMap) is thread-safe to meet your thread
safety requirements. When these requirements increase or you want to
have more control on the concurrency, consider the Hazelcast solutions described here.</p>
</div>
<div class="paragraph">
<p>Consider the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class RacyUpdateMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( "map" );
        String key = "1";
        map.put( key, new Value() );
        System.out.println( "Starting" );
        for ( int k = 0; k &lt; 1000; k++ ) {
            if ( k % 100 == 0 ) System.out.println( "At: " + k );
            Value value = map.get( key );
            Thread.sleep( 10 );
            value.amount++;
            map.put( key, value );
        }
        System.out.println( "Finished! Result = " + map.get(key).amount );
    }

    static class Value implements Serializable {
        public int amount;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the above code is run by more than one cluster member simultaneously,
a race condition is likely. You can solve this condition with Hazelcast
using either pessimistic or optimistic locking.</p>
</div>
<div class="sect3">
<h4 id="pessimistic-looking"><a class="anchor" href="#pessimistic-looking"></a>Pessimistic Locking</h4>
<div class="paragraph">
<p>One way to solve the race issue is by using pessimistic locking -
lock the map entry until you are finished with it.</p>
</div>
<div class="paragraph">
<p>To perform pessimistic locking, use the lock mechanism provided by the
Hazelcast distributed map, i.e., the <code>map.lock</code> and <code>map.unlock</code> methods.
See the below example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PessimisticUpdateMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( "map" );
        String key = "1";
        map.put( key, new Value() );
        System.out.println( "Starting" );
        for ( int k = 0; k &lt; 1000; k++ ) {
            map.lock( key );
            try {
                Value value = map.get( key );
                Thread.sleep( 10 );
                value.amount++;
                map.put( key, value );
            } finally {
                map.unlock( key );
            }
        }
        System.out.println( "Finished! Result = " + map.get( key ).amount );
    }

    static class Value implements Serializable {
        public int amount;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The IMap lock will automatically be collected by the garbage collector
when the lock is released and no other waiting conditions exist on the lock.</p>
</div>
<div class="paragraph">
<p>The IMap lock is reentrant, but it does not support fairness.</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
In some cases, a client application connected to your
cluster may cause the entries in a map to remain locked
after the application has been restarted (which were already locked
before such a restart). This can be due to the
reasons such as incomplete/incorrect client implementations. In these cases,
you can unlock the entries, either from the thread which locked them
using the <code>IMap.unlock()</code> method, or check if the entry is locked
using the <code>IMap.isLock()</code> method and then call <code>IMap.forceUnlock()</code>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
For the above case, as a workaround, you can also kill all the applications connected
to the cluster and use the Management Center&#8217;s scripting functionality to clear the map and
release the locks (instead of using <code>IMap.forceUnlock()</code>). Keep in mind that the scripting
functionality is limited to working with maps that have primitive key types, e.g., string keys
and limited to relaying only a single string of output per member to the result panel in the Management Center.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Another way to solve the race issue is by acquiring a predictable <code>Lock</code>
object from Hazelcast. This way, every value in the map can be given a lock,
or you can create a stripe of locks.</p>
</div>
</div>
<div class="sect3">
<h4 id="optimistic-locking"><a class="anchor" href="#optimistic-locking"></a>Optimistic Locking</h4>
<div class="paragraph">
<p>In Hazelcast, you can apply the optimistic locking strategy with the
map&#8217;s <code>replace</code> method. This method compares values in object or data forms
depending on the in-memory format configuration. If the values are equal,
it replaces the old value with the new one. If you want to use your defined
<code>equals</code> method, <code>in-memory-format</code> should be <code>OBJECT</code>. Otherwise, Hazelcast
serializes objects to <code>BINARY</code> forms and compares them.</p>
</div>
<div class="paragraph">
<p>See the below example code.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The below example code is intentionally broken.
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class OptimisticMember {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, Value&gt; map = hz.getMap( "map" );
        String key = "1";
        map.put( key, new Value() );
        System.out.println( "Starting" );
        for ( int k = 0; k &lt; 1000; k++ ) {
            if ( k % 10 == 0 ) System.out.println( "At: " + k );
            for (; ; ) {
                Value oldValue = map.get( key );
                Value newValue = new Value( oldValue );
                Thread.sleep( 10 );
                newValue.amount++;
                if ( map.replace( key, oldValue, newValue ) )
                    break;
            }
        }
        System.out.println( "Finished! Result = " + map.get( key ).amount );
    }

    static class Value implements Serializable {
        public int amount;

        public Value() {
        }

        public Value( Value that ) {
            this.amount = that.amount;
        }

        public boolean equals( Object o ) {
            if ( o == this ) return true;
            if ( !( o instanceof Value ) ) return false;
            Value that = ( Value ) o;
            return that.amount == this.amount;
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pessimistic-vs-optimistic-locking"><a class="anchor" href="#pessimistic-vs-optimistic-locking"></a>Pessimistic vs. Optimistic Locking</h4>
<div class="paragraph">
<p>The locking strategy you choose depends on your locking requirements.</p>
</div>
<div class="paragraph">
<p>Optimistic locking is better for mostly read-only systems. It has a
performance boost over pessimistic locking.</p>
</div>
<div class="paragraph">
<p>Pessimistic locking is good if there are lots of updates on the same
key. It is more robust than optimistic locking from the perspective of data consistency.</p>
</div>
<div class="paragraph">
<p>In Hazelcast, use <code>IExecutorService</code> to submit a task to a key owner,
or to a member or members. This is the recommended way to perform task executions,
rather than using pessimistic or optimistic locking techniques. <code>IExecutorService</code>
has fewer network hops and less data over wire, and tasks are executed very near to the data.
See the <a href="#data-affinity">Data Affinity section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="solving-the-aba-problem"><a class="anchor" href="#solving-the-aba-problem"></a>Solving the ABA Problem</h4>
<div class="paragraph">
<p>The ABA problem occurs in environments when a shared resource is
open to change by multiple threads. Even if one thread sees the same value
for a particular key in consecutive reads, it does not mean that nothing
has changed between the reads. Another thread may change the value,
do work and change the value back, while the first thread thinks that nothing has changed.</p>
</div>
<div class="paragraph">
<p>To prevent these kind of problems, you can assign a version number and
check it before any write to be sure that nothing has changed between consecutive reads.
Although all the other fields are equal, the version field will prevent objects
from being seen as equal. This is the optimistic locking strategy; it is used in
environments that do not expect intensive concurrent changes on a specific key.</p>
</div>
<div class="paragraph">
<p>In Hazelcast, you can apply the <a href="#optimistic-locking">optimistic locking</a>
strategy with the map <code>replace</code> method.</p>
</div>
</div>
<div class="sect3">
<h4 id="lock-split-brain-protection-with-pessimistic-locking"><a class="anchor" href="#lock-split-brain-protection-with-pessimistic-locking"></a>Lock Split-Brain Protection with Pessimistic Locking</h4>
<div class="paragraph">
<p>Locks can be configured to check the number of currently present members
before applying a locking operation. If the check fails, the lock operation
fails with a <code>SplitBrainProtectionException</code> (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
As pessimistic locking uses lock operations internally, it also uses the configured
lock split-brain protection. This means that you can configure a lock split-brain protection with the same name or a
pattern that matches the map name. Note that the split-brain protection for IMap locking actions can be
different from the split-brain protection for other IMap actions.</p>
</div>
<div class="paragraph">
<p>The following actions check for lock split-brain protection before being applied:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IMap.lock(K)</code> and <code>IMap.lock(K, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>IMap.isLocked()</code></p>
</li>
<li>
<p><code>IMap.tryLock(K)</code>, <code>IMap.tryLock(K, long, java.util.concurrent.TimeUnit)</code> and
<code>IMap.tryLock(K, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>IMap.unlock()</code></p>
</li>
<li>
<p><code>IMap.forceUnlock()</code></p>
</li>
<li>
<p><code>MultiMap.lock(K)</code> and <code>MultiMap.lock(K, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>MultiMap.isLocked()</code></p>
</li>
<li>
<p><code>MultiMap.tryLock(K)</code>, <code>MultiMap.tryLock(K, long, java.util.concurrent.TimeUnit)</code>
and <code>MultiMap.tryLock(K, long, java.util.concurrent.TimeUnit, long, java.util.concurrent.TimeUnit)</code></p>
</li>
<li>
<p><code>MultiMap.unlock()</code></p>
</li>
<li>
<p><code>MultiMap.forceUnlock()</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An example of declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;split-brain-protection-ref&gt;map-actions-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/map&gt;
    &lt;lock name="myMap"&gt;
        &lt;split-brain-protection-ref&gt;map-lock-actions-split-brain-protection&lt;/split-brain-protection-ref&gt;
    &lt;/lock&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      split-brain-protection-ref: map-actions-split-brain-protection
  lock:
    myMap:
      split-brain-protection-ref: map-lock-actions-split-brain-protection</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here the configured map uses the <code>map-lock-actions-split-brain-protection</code> for
map lock actions and the <code>map-actions-split-brain-protection</code> for other map actions.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="accessing-entry-statistics"><a class="anchor" href="#accessing-entry-statistics"></a>Accessing Map and Entry Statistics</h3>
<div class="paragraph">
<p>You can retrieve the statistics of the map in your Hazelcast IMDG member
using the <code>getLocalMapStats()</code> method, which is the programmatic approach.
It returns information such as primary and backup entry count, last update
time and locked entry count. If you need the cluster-wide map statistics, you can
get the local map statistics from all members of the cluster and combine them.
Alternatively, you can see the map statistics on the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#managing-maps" target="_blank" rel="noopener">Hazelcast Management Center</a>.</p>
</div>
<div class="paragraph">
<p>To be able to retrieve the map statistics, the <code>statistics-enabled</code>
element under the map configuration should be set as <code>true</code>, which is the default value:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      statistics-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>When this element is set to <code>false</code>, the statistics are not gathered
for the map and cannot be seen on the Hazelcast Management Center, nor retrieved
by the <code>getLocalMapStats()</code> method.</p>
</div>
<div class="paragraph">
<p>Hazelcast also keeps statistics about each map entry, such as creation time,
last update time, last access time, and number of hits and version. To access
the map entry statistics, use an <code>IMap.getEntryView(key)</code> call. Here is an example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hz = Hazelcast.newHazelcastInstance();
EntryView entry = hz.getMap( "quotes" ).getEntryView( "1" );
System.out.println ( "size in memory  : " + entry.getCost() );
System.out.println ( "creationTime    : " + entry.getCreationTime() );
System.out.println ( "expirationTime  : " + entry.getExpirationTime() );
System.out.println ( "number of hits  : " + entry.getHits() );
System.out.println ( "lastAccessedTime: " + entry.getLastAccessTime() );
System.out.println ( "lastUpdateTime  : " + entry.getLastUpdateTime() );
System.out.println ( "version         : " + entry.getVersion() );
System.out.println ( "key             : " + entry.getKey() );
System.out.println ( "value           : " + entry.getValue() );</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="map-listener"><a class="anchor" href="#map-listener"></a>Map Listener</h3>
<div class="paragraph">
<p>See the <a href="#listening-for-map-events">Listening for Map Events section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="listening-to-map-entries-with-predicates"><a class="anchor" href="#listening-to-map-entries-with-predicates"></a>Listening to Map Entries with Predicates</h3>
<div class="paragraph">
<p>You can listen to the modifications performed on specific map entries.
You can think of it as an entry listener with predicates. See the
<a href="#listening-for-map-events">Listening for Map Events section</a> for
information on how to add entry listeners to a map.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The default backwards-compatible event publishing strategy only publishes
<code>UPDATED</code> events when map entries are updated to a value that
matches the predicate with which the listener was registered.
This implies that when using the default event publishing strategy,
your listener is not notified about an entry whose
value is updated from one that matches the predicate to a new value
that does not match the predicate.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Since version 3.7, when you configure Hazelcast members with property
<code>hazelcast.map.entry.filtering.natural.event.types</code> set to <code>true</code>,
handling of entry updates conceptually treats value transition as entry,
update or exit with regards to the predicate value space.
The following table compares how a listener is notified about an update
to a map entry value under the default
backwards-compatible Hazelcast behavior (when property
<code>hazelcast.map.entry.filtering.natural.event.types</code> is not set or is set
to <code>false</code>) versus when set to <code>true</code>:</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Default</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hazelcast.map.entry.filtering.natural.event.types = true</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value matches predicate, new value does not match predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>REMOVED</code> event is delivered to entry listener</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value matches predicate, new value matches predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPDATED</code> event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPDATED</code> event is delivered to entry listener</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value does not match predicate, new value does not match predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">No event is delivered to entry listener</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">When old value does not match predicate, new value matches predicate</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>UPDATED</code> event is delivered to entry listener</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ADDED</code> event is delivered to entry listener</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>As an example, let&#8217;s listen to the changes made on an employee
with the surname "Smith". First, let&#8217;s create the <code>Employee</code> class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Employee implements Serializable {

    private final String surname;

    public Employee(String surname) {
        this.surname = surname;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "surname='" + surname + '\'' +
                '}';
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, let&#8217;s create a listener with predicate by adding a listener
that tracks <code>ADDED</code>, <code>UPDATED</code> and <code>REMOVED</code> entry events with the <code>surname</code> predicate.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ListenerWithPredicate {

    public static void main(String[] args) {
        Config config = new Config();
        config.setProperty("hazelcast.map.entry.filtering.natural.event.types", "true");
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);
        IMap&lt;String, String&gt; map = hz.getMap("map");
        map.addEntryListener(new MyEntryListener(),
                Predicates.sql("surname=smith"), true);
        System.out.println("Entry Listener registered");
    }

    static class MyEntryListener
            implements EntryAddedListener&lt;String, String&gt;,
            EntryUpdatedListener&lt;String, String&gt;,
            EntryRemovedListener&lt;String, String&gt; {
        @Override
        public void entryAdded(EntryEvent&lt;String, String&gt; event) {
            System.out.println("Entry Added:" + event);
        }

        @Override
        public void entryRemoved(EntryEvent&lt;String, String&gt; event) {
            System.out.println("Entry Removed:" + event);
        }

        @Override
        public void entryUpdated(EntryEvent&lt;String, String&gt; event) {
            System.out.println("Entry Updated:" + event);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And now, let&#8217;s play with the employee "smith" and see how that employee is listened to.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Modify {

    public static void main(String[] args) {
        Config config = new Config();
        config.setProperty("hazelcast.map.entry.filtering.natural.event.types", "true");
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);
        IMap&lt;String, Employee&gt; map = hz.getMap("map");

        map.put("1", new Employee("smith"));
        map.put("2", new Employee("jordan"));
        System.out.println("done");
        System.exit(0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you first run the class <code>ListenerWithPredicate</code> and then run <code>Modify</code>,
an output similar to the one below appears.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>entryAdded:EntryEvent {Address[192.168.178.10]:5702} key=1,oldValue=null,
value=Person{name= smith }, event=ADDED, by Member [192.168.178.10]:5702</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
See the <a href="#continuous-query-cache">Continuous Query Cache section</a>
for more information.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="removing-map-entries-in-bulk-with-predicates"><a class="anchor" href="#removing-map-entries-in-bulk-with-predicates"></a>Removing Map Entries in Bulk with Predicates</h3>
<div class="paragraph">
<p>You can remove all map entries that match your predicate. For this,
Hazelcast offers the method <code>removeAll()</code>. Its syntax is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">void removeAll(Predicate&lt;K, V&gt; predicate);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Normally the map entries matching the predicate are found with a full scan
of the map. If the entries are indexed, Hazelcast uses the index search to find them.
With index, you can expect that finding the entries is faster.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When <code>removeAll()</code> is called, ALL entries in the caller member&#8217;s
Near Cache are also removed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="adding-interceptors"><a class="anchor" href="#adding-interceptors"></a>Adding Interceptors</h3>
<div class="paragraph">
<p>You can add intercept operations and execute your own business logic
synchronously blocking the operations. You can change the returned value
from a <code>get</code> operation, change the value in <code>put</code>, or <code>cancel</code> operations
by throwing an exception.</p>
</div>
<div class="paragraph">
<p>Interceptors are different from listeners. With listeners, you take an action
after the operation has been completed. Interceptor actions are synchronous and
you can alter the behavior of operation, change its values, or totally cancel it.</p>
</div>
<div class="paragraph">
<p>Map interceptors are chained, so adding the same interceptor multiple times to the
same map can result in duplicate effects. This can easily happen when the interceptor
is added to the map at member initialization, so that each member adds the same interceptor.
When you add the interceptor in this way, be sure to implement the <code>hashCode()</code>
method to return the same value for every instance of the interceptor.
It is not strictly necessary, but it is a good idea to also implement <code>equals()</code>
as this ensures that the map interceptor can be removed reliably.</p>
</div>
<div class="paragraph">
<p>The IMap API has two methods for adding and removing an interceptor to the map:
<code>addInterceptor</code> and <code>removeInterceptor</code>. See also the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/map/MapInterceptor.html" target="_blank" rel="noopener"><code>MapInterceptor</code> interface</a>
to learn about the methods used to intercept the changes in a map.</p>
</div>
<div class="paragraph">
<p>The following is an example usage.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MapInterceptorMember {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IMap&lt;String, String&gt; map = hz.getMap("themap");
        map.addInterceptor(new MyMapInterceptor());

        map.put("1", "1");
        System.out.println(map.get("1"));
    }

    private static class MyMapInterceptor implements MapInterceptor {

        @Override
        public Object interceptGet(Object value) {
            return value + "-foo";
        }

        @Override
        public void afterGet(Object value) {
        }

        @Override
        public Object interceptPut(Object oldValue, Object newValue) {
            return null;
        }

        @Override
        public void afterPut(Object value) {
        }

        @Override
        public Object interceptRemove(Object removedValue) {
            return null;
        }

        @Override
        public void afterRemove(Object value) {
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="preventing-out-of-memory-exceptions"><a class="anchor" href="#preventing-out-of-memory-exceptions"></a>Preventing Out of Memory Exceptions</h3>
<div class="paragraph">
<p>It is very easy to trigger an out of memory exception (OOME) with query-based map methods,
especially with large clusters or heap sizes. For example, on a cluster with five members
having 10 GB of data and 25 GB heap size per member, a single call of <code>IMap.entrySet()</code>
fetches 50 GB of data and crashes the calling instance.</p>
</div>
<div class="paragraph">
<p>A call of <code>IMap.values()</code> may return too much data for a single member.
This can also happen with a real query and an unlucky choice of predicates,
especially when the parameters are chosen by a user of your application.</p>
</div>
<div class="paragraph">
<p>To prevent this, you can configure a maximum result size limit for query based operations.
This is not a limit like <code>SELECT * FROM map LIMIT 100</code>, which you can achieve by a
<a href="#filtering-with-paging-predicates">Paging Predicate</a>. A maximum result size limit
for query based operations is meant to be a last line of defense to prevent your members
from retrieving more data than they can handle.</p>
</div>
<div class="paragraph">
<p>The Hazelcast component which calculates this limit is the <code>QueryResultSizeLimiter</code>.</p>
</div>
<div class="sect3">
<h4 id="setting-query-result-size-limit"><a class="anchor" href="#setting-query-result-size-limit"></a>Setting Query Result Size Limit</h4>
<div class="paragraph">
<p>If the <code>QueryResultSizeLimiter</code> is activated, it calculates a result size limit per partition.
Each <code>QueryOperation</code> runs on all partitions of a member, so it collects result entries
as long as the member limit is not exceeded. If that happens, a
<code>QueryResultSizeExceededException</code> is thrown and propagated to the calling instance.</p>
</div>
<div class="paragraph">
<p>This feature depends on an equal distribution of the data on the cluster members to
calculate the result size limit per member. Therefore, there is a minimum value defined
in <code>QueryResultSizeLimiter.MINIMUM_MAX_RESULT_LIMIT</code>. Configured values below the minimum
will be increased to the minimum.</p>
</div>
</div>
<div class="sect3">
<h4 id="local-pre-check"><a class="anchor" href="#local-pre-check"></a>Local Pre-check</h4>
<div class="paragraph">
<p>In addition to the distributed result size check in the <code>QueryOperations</code>,
there is a local pre-check on the calling instance. If you call the method from a client,
the pre-check is executed on the member that invokes the <code>QueryOperations</code>.</p>
</div>
<div class="paragraph">
<p>Since the local pre-check can increase the latency of a <code>QueryOperation</code>,
you can configure how many local partitions should be considered for the pre-check,
or you can deactivate the feature completely.</p>
</div>
</div>
<div class="sect3">
<h4 id="scope-of-result-size-limit"><a class="anchor" href="#scope-of-result-size-limit"></a>Scope of Result Size Limit</h4>
<div class="paragraph">
<p>Besides the designated query operations, there are other operations that use predicates internally.
Those method calls throw the <code>QueryResultSizeExceededException</code> as well.
See the following matrix for the methods that are covered by the query result size limit.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/Map-QueryResultSizeLimiterScope.png" alt="Methods Covered by Query Result Size Limit"></span></p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-query-result-size"><a class="anchor" href="#configuring-query-result-size"></a>Configuring Query Result Size</h4>
<div class="paragraph">
<p>The query result size limit is configured via the following system properties.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.query.result.size.limit</code>: Result size limit for query operations on maps.
This value defines the maximum number of returned elements for a single query result.
If a query exceeds this number of elements, a QueryResultSizeExceededException is thrown.</p>
</li>
<li>
<p><code>hazelcast.query.max.local.partition.limit.for.precheck</code>: Maximum value of local partitions
to trigger local pre-check for <code>Predicates#alwaysTrue()</code> query operations on maps.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="#system-properties">System Properties appendix</a> to see the full descriptions
of these properties and how to set them.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="queue"><a class="anchor" href="#queue"></a>Queue</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast distributed queue is an implementation of <code>java.util.concurrent.BlockingQueue</code>.
Being distributed, Hazelcast distributed queue enables all cluster members to interact with it.
Using Hazelcast distributed queue, you can add an item in one cluster member and remove it from another one.</p>
</div>
<div class="sect2">
<h3 id="getting-a-queue-and-putting-items"><a class="anchor" href="#getting-a-queue-and-putting-items"></a>Getting a Queue and Putting Items</h3>
<div class="paragraph">
<p>Use the Hazelcast instance&#8217;s <code>getQueue</code> method to get the queue, then use the queue&#8217;s
<code>put</code> method to put items into the queue.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        BlockingQueue&lt;MyTask&gt; queue = hazelcastInstance.getQueue( "tasks" );
        queue.put( new MyTask() );
        MyTask task = queue.take();

        boolean offered = queue.offer( new MyTask(), 10, TimeUnit.SECONDS );
        task = queue.poll( 5, TimeUnit.SECONDS );
        if ( task != null ) {
            //process task
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>FIFO ordering applies to all queue operations across the cluster. The user objects
(such as <code>MyTask</code> in the example above) that are enqueued or dequeued have to be <code>Serializable</code>.</p>
</div>
<div class="paragraph">
<p>Hazelcast distributed queue performs no batching while iterating over the queue.
All items are copied locally and iteration occurs locally.</p>
</div>
<div class="paragraph">
<p>Hazelcast distributed queue uses <code>ItemListener</code> to listen to the events that occur
when items are added to and removed from the queue. See the <a href="#listening-for-item-events">Listening for Item Events section</a> for information on how to create an item listener
class and register it.</p>
</div>
</div>
<div class="sect2">
<h3 id="creating-an-example-queue"><a class="anchor" href="#creating-an-example-queue"></a>Creating an Example Queue</h3>
<div class="paragraph">
<p>The following example code illustrates a distributed queue that connects a producer and consumer.</p>
</div>
<div class="sect3">
<h4 id="putting-items-on-the-queue"><a class="anchor" href="#putting-items-on-the-queue"></a>Putting Items on the Queue</h4>
<div class="paragraph">
<p>Let&#8217;s <code>put</code> one integer on the queue every second, 100 integers total.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ProducerMember {

    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IQueue&lt;Integer&gt; queue = hz.getQueue( "queue" );
        for ( int k = 1; k &lt; 100; k++ ) {
            queue.put( k );
            System.out.println( "Producing: " + k );
            Thread.sleep(1000);
        }
        queue.put( -1 );
        System.out.println( "Producer Finished!" );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Producer</code> puts a <strong>-1</strong> on the queue to show that the <code>put</code>s are finished.</p>
</div>
</div>
<div class="sect3">
<h4 id="taking-items-off-the-queue"><a class="anchor" href="#taking-items-off-the-queue"></a>Taking Items off the Queue</h4>
<div class="paragraph">
<p>Now, let&#8217;s create a <code>Consumer</code> class to <code>take</code> a message from this queue, as shown below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ConsumerMember {

    public static void main( String[] args ) throws Exception {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IQueue&lt;Integer&gt; queue = hz.getQueue( "queue" );
        while ( true ) {
            int item = queue.take();
            System.out.println( "Consumed: " + item );
            if ( item == -1 ) {
                queue.put( -1 );
                break;
            }
            Thread.sleep( 5000 );
        }
        System.out.println( "Consumer Finished!" );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>As seen in the above example code, <code>Consumer</code> waits five seconds before it consumes
the next message. It stops once it receives <strong>-1</strong>. Also note that <code>Consumer</code>
puts <strong>-1</strong> back on the queue before the loop is ended.</p>
</div>
<div class="paragraph">
<p>When you first start <code>Producer</code> and then start <code>Consumer</code>, items produced on the
queue will be consumed from the same queue.</p>
</div>
</div>
<div class="sect3">
<h4 id="balancing-the-queue-operations"><a class="anchor" href="#balancing-the-queue-operations"></a>Balancing the Queue Operations</h4>
<div class="paragraph">
<p>From the above example code, you can see that an item is produced every second and
consumed every five seconds. Therefore, the consumer keeps growing. To balance the
produce/consume operation, let&#8217;s start another consumer. This way, consumption is
distributed to these two consumers, as seen in the example outputs below.</p>
</div>
<div class="paragraph">
<p>The second consumer is started. After a while, here is the first consumer output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>...
Consumed 13
Consumed 15
Consumer 17
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the second consumer output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>...
Consumed 14
Consumed 16
Consumer 18
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the case of a lot of producers and consumers for the queue, using a list of
queues may solve the queue bottlenecks. In this case, be aware that the order of the
messages sent to different queues is not guaranteed. Since in most cases strict ordering
is not important, a list of queues is a good solution.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The items are taken from the queue in the same order they were put on the queue.
However, if there is more than one consumer, this order is not guaranteed.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="itemids-when-offering-items"><a class="anchor" href="#itemids-when-offering-items"></a>ItemIDs When Offering Items</h4>
<div class="paragraph">
<p>Hazelcast gives an <code>itemId</code> for each item you offer, which is an incrementing sequence
identification for the queue items. You should consider the following to understand the
<code>itemId</code> assignment behavior:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When a Hazelcast member has a queue and that queue is configured to have at least one
backup, and that member is restarted, the <code>itemId</code> assignment resumes from the last known
highest <code>itemId</code> before the restart; <code>itemId</code> assignment does not start from the beginning for the new items.</p>
</li>
<li>
<p>When the whole cluster is restarted, the same behavior explained in the above
consideration applies if your queue has a persistent data store (<code>QueueStore</code>).
If the queue has <code>QueueStore</code>, the <code>itemId</code> for the new items are given, starting
from the highest <code>itemId</code> found in the IDs returned by the method <code>loadAllKeys</code>.
If the method <code>loadAllKeys</code> does not return anything, the <code>itemId</code>s starts
from the beginning after a cluster restart.</p>
</li>
<li>
<p>The above two considerations mean there are no duplicated <code>itemId</code>s in the memory
or in the persistent data store.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setting-a-bounded-queue"><a class="anchor" href="#setting-a-bounded-queue"></a>Setting a Bounded Queue</h3>
<div class="paragraph">
<p>A bounded queue is a queue with a limited capacity. When the bounded queue is full,
no more items can be put into the queue until some items are taken out.</p>
</div>
<div class="paragraph">
<p>To turn a Hazelcast distributed queue into a bounded queue, set the capacity limit
with the <code>max-size</code> property. You can set the <code>max-size</code> property in the configuration,
as shown below. The <code>max-size</code> element specifies the maximum size of the queue.
Once the queue size reaches this value, <code>put</code> operations are blocked until the
queue size goes below <code>max-size</code>, which happens when a consumer removes items from the queue.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s set <strong>10</strong> as the maximum size of our example queue in <a href="#creating-an-example-queue">Creating an Example Queue</a>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="queue"&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  queue:
    queue:
      max-size: 10</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the producer is started, ten items are put into the queue and then the queue
will not allow more <code>put</code> operations. When the consumer is started, it will remove
items from the queue. This means that the producer can <code>put</code> more items into the
queue until there are ten items in the queue again, at which point the <code>put</code> operation
again becomes blocked.</p>
</div>
<div class="paragraph">
<p>In this example code, the producer is five times faster than the consumer.
It will effectively always be waiting for the consumer to remove items before
it can put more on the queue. For this example code, if maximum throughput is the goal,
it would be a good option to start multiple consumers to prevent the queue from filling up.</p>
</div>
</div>
<div class="sect2">
<h3 id="queueing-with-persistent-datastore"><a class="anchor" href="#queueing-with-persistent-datastore"></a>Queueing with Persistent Datastore</h3>
<div class="paragraph">
<p>Hazelcast allows you to load and store the distributed queue items from/to a persistent
datastore using the interface <code>QueueStore</code>. If queue store is enabled, each item added to
the queue is also stored at the configured queue store. When the number of items in the
queue exceeds the memory limit, the subsequent items are persisted in the queue store,
they are not stored in the queue memory.</p>
</div>
<div class="paragraph">
<p>The <code>QueueStore</code> interface enables you to store, load and delete queue items with methods like
<code>store</code>, <code>storeAll</code>, <code>load</code> and <code>delete</code>. The following example class includes all of the <code>QueueStore</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TheQueueStore implements QueueStore&lt;Item&gt; {

    @Override
    public void delete(Long key) {
        System.out.println("delete");
    }

    @Override
    public void store(Long key, Item value) {
        System.out.println("store");
    }

    @Override
    public void storeAll(Map&lt;Long, Item&gt; map) {
        System.out.println("store all");
    }

    @Override
    public void deleteAll(Collection&lt;Long&gt; keys) {
        System.out.println("deleteAll");
    }

    @Override
    public Item load(Long key) {
        System.out.println("load");
        return null;
    }

    @Override
    public Map&lt;Long, Item&gt; loadAll(Collection&lt;Long&gt; keys) {
        System.out.println("loadALl");
        return null;
    }

    @Override
    public Set&lt;Long&gt; loadAllKeys() {
        System.out.println("loadAllKeys");
        return null;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Item</code> must be serializable. The following is an example queue store configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="queue"&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
        &lt;queue-store&gt;
            &lt;class-name&gt;com.hazelcast.QueueStoreImpl&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="binary"&gt;false&lt;/property&gt;
                &lt;property name="memory-limit"&gt;1000&lt;/property&gt;
                &lt;property name="bulk-load"&gt;500&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/queue-store&gt;
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  queue:
    queue:
      max-size: 10
      queue-store:
        class-name: com.hazelcast.QueueStoreImpl
        properties:
          binary: false
          memory-limit: 1000
          bulk-load: 500</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions for each queue store property:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Binary</strong>: By default, Hazelcast stores the queue items in serialized form,
and before it inserts the queue items into the queue store, it deserializes them.
If you are not reaching the queue store from an external application, you might
prefer that the items be inserted in binary form. Do this by setting the <code>binary</code>
property to true: then you can get rid of the deserialization step, which is a performance
optimization. The <code>binary</code> property is false by default.</p>
</li>
<li>
<p><strong>Memory Limit</strong>: This is the number of items after which Hazelcast stores items
only to the datastore. For example, if the memory limit is 1000, then the 1001st item
is put only to the datastore. This feature is useful when you want to avoid out-of-memory
conditions. If you want to always use memory, you can set it to <code>Integer.MAX_VALUE</code>.
The default number for <code>memory-limit</code> is 1000.</p>
</li>
<li>
<p><strong>Bulk Load</strong>: When the queue is initialized, items are loaded from <code>QueueStore</code>
in bulks. Bulk load is the size of these bulks. The default value of <code>bulk-load</code> is 250.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="split-brain-protection-for-queue"><a class="anchor" href="#split-brain-protection-for-queue"></a>Split-Brain Protection for Queue</h3>
<div class="paragraph">
<p>Queues can be configured to check for a minimum number of available members before
applying queue operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE</p>
<div class="ulist">
<ul>
<li>
<p><code>Collection.addAll()</code></p>
</li>
<li>
<p><code>Collection.removeAll()</code>, <code>Collection.retainAll()</code></p>
</li>
<li>
<p><code>BlockingQueue.offer()</code>, <code>BlockingQueue.add()</code>, <code>BlockingQueue.put()</code></p>
</li>
<li>
<p><code>BlockingQueue.drainTo()</code></p>
</li>
<li>
<p><code>IQueue.poll()</code>, <code>Queue.remove()</code>, <code>IQueue.take()</code></p>
</li>
<li>
<p><code>BlockingQueue.remove()</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE</p>
<div class="ulist">
<ul>
<li>
<p><code>Collection.clear()</code></p>
</li>
<li>
<p><code>Collection.containsAll()</code>, <code>BlockingQueue.contains()</code></p>
</li>
<li>
<p><code>Collection.isEmpty()</code></p>
</li>
<li>
<p><code>Collection.iterator()</code>, <code>Collection.toArray()</code></p>
</li>
<li>
<p><code>Queue.peek()</code>, <code>Queue.element()</code></p>
</li>
<li>
<p><code>Collection.size()</code></p>
</li>
<li>
<p><code>BlockingQueue.remainingCapacity()</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="configuring-queue"><a class="anchor" href="#configuring-queue"></a>Configuring Queue</h3>
<div class="paragraph">
<p>The following are examples of queue configurations. It includes the
<code>QueueStore</code> configuration, which is explained in the <a href="#queueing-with-persistent-datastore">Queueing with Persistent Datastore</a> section.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;queue name="default"&gt;
        &lt;max-size&gt;0&lt;/max-size&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;empty-queue-ttl&gt;-1&lt;/empty-queue-ttl&gt;
        &lt;item-listeners&gt;
            &lt;item-listener&gt;com.hazelcast.examples.ItemListener&lt;/item-listener&gt;
        &lt;/item-listeners&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;queue-store&gt;
            &lt;class-name&gt;com.hazelcast.QueueStoreImpl&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="binary"&gt;false&lt;/property&gt;
                &lt;property name="memory-limit"&gt;10000&lt;/property&gt;
                &lt;property name="bulk-load"&gt;500&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/queue-store&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/queue&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  queue:
    default:
      max-size: 0
      backup-count: 1
      async-backup-count: 0
      empty-queue-ttl: -1
      item-listeners:
        - include-value: true
          class-name: com.hazelcast.examples.ItemListener
      statistics-enabled: true
      queue-store:
        class-name: com.hazelcast.QueueStoreImpl
        properties:
          binary: false
          memory-limit: 1000
          bulk-load: 500
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        QueueConfig queueConfig = config.getQueueConfig("default");
        queueConfig.setName("MyQueue")
                .setBackupCount(1)
                .setMaxSize(0)
                .setStatisticsEnabled(true)
                .setSplitBrainProtectionName("splitbrainprotectionname");
        queueConfig.getQueueStoreConfig()
                .setEnabled(true)
                .setClassName("com.hazelcast.QueueStoreImpl")
                .setProperty("binary", "false");
        config.addQueueConfig(queueConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast distributed queue has one synchronous backup by default.
By having this backup, when a cluster member with a queue goes down,
another member having the backup of that queue will continue. Therefore,
no items are lost. You can define the number of synchronous backups for a
queue using the <code>backup-count</code> element in the declarative configuration.
A queue can also have asynchronous backups: you can define the number of
asynchronous backups using the <code>async-backup-count</code> element.</p>
</div>
<div class="paragraph">
<p>To set the maximum size of the queue, use the <code>max-size</code> element.
To purge unused or empty queues after a period of time, use the <code>empty-queue-ttl</code> element.
If you define a value (time in seconds) for the <code>empty-queue-ttl</code> element,
then your queue will be destroyed if it stays empty or unused for the time in seconds that you give.</p>
</div>
<div class="paragraph">
<p>The following is the full list of queue configuration elements with their descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max-size</code>: Maximum number of items in the queue. It is used to set an
upper bound for the queue. You will not be able to put more items when the
queue reaches to this maximum size whether you have a queue store configured or not.</p>
</li>
<li>
<p><code>backup-count</code>: Number of synchronous backups. Queue is a non-partitioned
data structure, so all entries of a queue reside in one partition. When this
parameter is '1', it means there will be one backup of that queue in another
member in the cluster. When it is '2', two members will have the backup.</p>
</li>
<li>
<p><code>async-backup-count</code>: Number of asynchronous backups.</p>
</li>
<li>
<p><code>empty-queue-ttl</code>: Used to purge unused or empty queues. If you define a
value (time in seconds) for this element, then your queue will be destroyed
if it stays empty or unused for that time.</p>
</li>
<li>
<p><code>item-listeners</code>: Adds listeners (listener classes) for the queue items.
You can also set the attribute <code>include-value</code> to <code>true</code> if you want the item
event to contain the item values. You can set <code>local</code> to <code>true</code> if you want to
listen to the items on the local member.</p>
</li>
<li>
<p><code>queue-store</code>: Includes the queue store factory class name and the properties
<strong>binary</strong>, <strong>memory limit</strong> and <strong>bulk load</strong>. See the <a href="#queueing-with-persistent-datastore">Queueing with Persistent Datastore section</a>.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your queue.
If set to <code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalQueueStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-queues" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code> : Name of the split-brain protection configuration that you want this queue to use.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multimap"><a class="anchor" href="#multimap"></a>MultiMap</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast <code>MultiMap</code> is a specialized map where you can store multiple values
under a single key. Just like any other distributed data structure implementation in
Hazelcast, <code>MultiMap</code> is distributed and thread-safe.</p>
</div>
<div class="paragraph">
<p>Hazelcast <code>MultiMap</code> is not an implementation of <code>java.util.Map</code> due to the difference
in method signatures. It supports most features of Hazelcast Map except for indexing,
predicates and MapLoader/MapStore. Yet, like Hazelcast Map, entries are almost evenly
distributed onto all cluster members. When a new member joins the cluster, the same
ownership logic used in the distributed map applies.</p>
</div>
<div class="sect2">
<h3 id="getting-a-multimap-and-putting-an-entry"><a class="anchor" href="#getting-a-multimap-and-putting-an-entry"></a>Getting a MultiMap and Putting an Entry</h3>
<div class="paragraph">
<p>The following example creates a MultiMap and puts items into it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        MultiMap&lt;String , String &gt; map = hazelcastInstance.getMultiMap( "map" );

        map.put( "a", "1" );
        map.put( "a", "2" );
        map.put( "b", "3" );
        System.out.println( "PutMember:Done" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the <code>getMultiMap</code> method to create the MultiMap and then use the <code>put</code>
method to put an entry into it.</p>
</div>
<div class="paragraph">
<p>Now let&#8217;s print the entries in this MultiMap using the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        MultiMap&lt;String, String&gt; map = hazelcastInstance.getMultiMap("map");

        map.put("a", "1");
        map.put("a", "2");
        map.put("b", "3");
        System.out.printf("PutMember:Done");

        for (String key: map.keySet()){
            Collection&lt;String&gt; values = map.get(key);
            System.out.printf("%s -&gt; %s\n", key, values);
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>After you run <code>ExampleMultiMap</code>, run <code>PrintMember</code>. You will see the key <strong><code>a</code></strong> has
two values, as shown below:</p>
</div>
<div class="paragraph">
<p><code>b &#8594; [3]</code></p>
</div>
<div class="paragraph">
<p><code>a &#8594; [2, 1]</code></p>
</div>
<div class="paragraph">
<p>Hazelcast MultiMap uses <code>EntryListener</code> to listen to events which occur when
entries are added to, updated in or removed from the MultiMap. See the
<a href="#listening-for-multimap-events">Listening for MultiMap Events section</a>
for information on how to create an entry listener class and register it.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-multimap"><a class="anchor" href="#configuring-multimap"></a>Configuring MultiMap</h3>
<div class="paragraph">
<p>When using MultiMap, the collection type of the values can be either <strong>Set</strong> or <strong>List</strong>.
Configure the collection type with the <code>valueCollectionType</code> parameter. If you choose
<code>Set</code>, duplicate and null values are not allowed in your collection and ordering is irrelevant.
If you choose <code>List</code>, ordering is relevant and your collection can include duplicate but not null values.</p>
</div>
<div class="paragraph">
<p>You can also enable statistics for your MultiMap with the <code>statisticsEnabled</code> parameter.
If you enable <code>statisticsEnabled</code>, statistics can be retrieved with <code>getLocalMultiMapStats()</code> method.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, eviction is not supported for the MultiMap data structure.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following are the example MultiMap configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;multimap name="default"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
        &lt;value-collection-type&gt;SET&lt;/value-collection-type&gt;
        &lt;entry-listeners&gt;
            &lt;entry-listener include-value="false" local="false" &gt;com.hazelcast.examples.EntryListener&lt;/entry-listener&gt;
        &lt;/entry-listeners&gt;
        &lt;split-brain-protection-ref&gt;split-brain-protection-name&lt;/split-brain-protection-ref&gt;
    &lt;/multimap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  multimap:
    default:
      backup-count: 0
      async-backup-count: 1
      value-collection-type: SET
      entry-listeners:
        - class-name: com.hazelcast.examples.EntryListener
          include-value: false
          local: false
      split-brain-protection-ref: split-brain-protection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        MultiMapConfig mmConfig = new MultiMapConfig();
        mmConfig.setName( "default" )
                .setBackupCount( 0 ).setAsyncBackupCount( 1 )
                .setValueCollectionType( "SET" )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the configuration elements and their descriptions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>backup-count</code>: Defines the number of synchronous backups. For example,
if it is set to 1, backup of a partition will be
placed on one other member. If it is 2, it will be placed on two other members.</p>
</li>
<li>
<p><code>async-backup-count</code>: The number of asynchronous backups. Behavior is the
same as that of the <code>backup-count</code> element.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your MultiMap.
If set to <code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalMultiMapStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-multimaps" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>value-collection-type</code>: Type of the value collection. It can be <code>SET</code> or <code>LIST</code>.</p>
</li>
<li>
<p><code>entry-listeners</code>: Lets you add listeners (listener classes) for the map entries.
You can also set the attribute
<code>include-value</code> to <code>true</code> if you want the item event to contain the entry values.
You can set
<code>local</code> to <code>true</code> if you want to listen to the entries on the local member.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this MultiMap to use.
See the <a href="#split-brain-protection-for-multimap-and-transactionalmultimap">Split-Brain
Protection for MultiMap and TransactionalMultiMap section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="split-brain-protection-for-multimap-and-transactionalmultimap"><a class="anchor" href="#split-brain-protection-for-multimap-and-transactionalmultimap"></a>Split-Brain Protection for MultiMap and TransactionalMultiMap</h3>
<div class="paragraph">
<p>MultiMap &amp; TransactionalMultiMap can be configured to check for a minimum number of
available members before applying their operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods that support split-brain protection checks. The list is grouped by the protection types.</p>
</div>
<div class="paragraph">
<p>MultiMap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>forceUnlock</code></p>
</li>
<li>
<p><code>lock</code></p>
</li>
<li>
<p><code>put</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
<li>
<p><code>tryLock</code></p>
</li>
<li>
<p><code>unlock</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>containsEntry</code></p>
</li>
<li>
<p><code>containsKey</code></p>
</li>
<li>
<p><code>containsValue</code></p>
</li>
<li>
<p><code>entrySet</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>isLocked</code></p>
</li>
<li>
<p><code>keySet</code></p>
</li>
<li>
<p><code>localKeySet</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>valueCount</code></p>
</li>
<li>
<p><code>values</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TransactionalMultiMap:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>put</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>valueCount</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for MultiMap can be configured programmatically using
the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/MultiMapConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;multimap name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/multimap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  multimap:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you configured
under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="set"><a class="anchor" href="#set"></a>Set</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast Set (<code>ISet</code>) is a distributed and concurrent implementation of <code>java.util.Set</code>.
It has the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Hazelcast Set does not allow duplicate elements.</p>
</li>
<li>
<p>Hazelcast Set does not preserve the order of elements.</p>
</li>
<li>
<p>Hazelcast Set is a non-partitioned data structure: all the data that belongs to
a set lives on one single partition in that member.</p>
</li>
<li>
<p>Hazelcast Set cannot be scaled beyond the capacity of a single machine.
Since the whole set lives on a single partition, storing a large amount of
data on a single set may cause memory pressure. Therefore, you should use multiple
sets to store a large amount of data. This way, all the sets are spread across the
cluster, sharing the load.</p>
</li>
<li>
<p>A backup of Hazelcast Set is stored on a partition of another member in the cluster
so that data is not lost in the event of a primary member failure.</p>
</li>
<li>
<p>All items are copied to the local member and iteration occurs locally.</p>
</li>
<li>
<p>The equals method implemented in Hazelcast Set uses a serialized byte version of
objects, as opposed to <code>java.util.HashSet</code>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="getting-a-set-and-putting-items"><a class="anchor" href="#getting-a-set-and-putting-items"></a>Getting a Set and Putting Items</h3>
<div class="paragraph">
<p>Use the <code>HazelcastInstance</code>s <code>getSet</code> method to get the Set, then use the <code>add</code> method to put items into it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ISet&lt;String&gt; set = hz.getSet("set");
        set.add("Tokyo");
        set.add("Paris");
        set.add("London");
        set.add("New York");
        System.out.println("Putting finished!");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Set uses <code>ItemListener</code> to listen to events that occur when items are
added to and removed from the Set. See the <a href="#listening-for-item-events">Listening for Item Events section</a>
for information on how to create an item listener class and register it.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-set"><a class="anchor" href="#configuring-set"></a>Configuring Set</h3>
<div class="paragraph">
<p>The following are the example Hazelcast Set configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;set name="default"&gt;
        &lt;statistics-enabled&gt;false&lt;/statistics-enabled&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
        &lt;item-listeners&gt;
            &lt;item-listener&gt;com.hazelcast.examples.ItemListener&lt;/item-listener&gt;
        &lt;/item-listeners&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  set:
    default:
      statistics-enabled: false
      backup-count: 1
      async-backup-count: 0
      max-size: 10
      item-listeners:
        - class-name: com.hazelcast.examples.ItemListener
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        CollectionConfig collectionSet = config.getSetConfig("MySet");
        collectionSet.setBackupCount(1)
                .setMaxSize(10)
                .setSplitBrainProtectionName("splitbrainprotectionname");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Set configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: True (default) if statistics gathering is
enabled on the Set, false otherwise.</p>
</li>
<li>
<p><code>backup-count</code>: Count of synchronous backups. Set is a non-partitioned
data structure, so all entries of a Set reside in one partition. When this
parameter is '1', it means there will be one backup of that Set in another
member in the cluster. When it is '2', two members will have the backup.</p>
</li>
<li>
<p><code>async-backup-count</code>: Count of asynchronous backups.</p>
</li>
<li>
<p><code>max-size</code>: The maximum number of entries for this Set. It can be any number
between 0 and Integer.MAX_VALUE. Its default value is 0, meaning there is no capacity constraint.</p>
</li>
<li>
<p><code>item-listeners</code>: Lets you add listeners (listener classes) for the list items.
You can also set the attributes <code>include-value</code> to <code>true</code> if you want the item event
to contain the item values. You can set <code>local</code> to <code>true</code> if you want to listen to
the items on the local member.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this Set to use.
See the <a href="#split-brain-protection-for-iset-and-transactionalset">Split-Brain Protection for ISet and TransactionalSet section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="split-brain-protection-for-iset-and-transactionalset"><a class="anchor" href="#split-brain-protection-for-iset-and-transactionalset"></a>Split-Brain Protection for ISet and TransactionalSet</h3>
<div class="paragraph">
<p>ISet &amp; TransactionalSet can be configured to check for a minimum number of
available members before applying queue operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support
split-brain protection checks:</p>
</div>
<div class="paragraph">
<p>ISet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAll</code></p>
</li>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
<li>
<p><code>removeAll</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>contains</code></p>
</li>
<li>
<p><code>containsAll</code></p>
</li>
<li>
<p><code>isEmpty</code></p>
</li>
<li>
<p><code>iterator</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>toArray</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TransactionalSet:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for ISet can be configured programmatically using
the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/SetConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. The following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;set name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/set&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  set:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you
configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="list"><a class="anchor" href="#list"></a>List</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast List (<code>IList</code>) is similar to Hazelcast Set, but it also
allows duplicate elements.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Besides allowing duplicate elements, Hazelcast List preserves the order of elements.</p>
</li>
<li>
<p>Hazelcast List is a non-partitioned data structure where values and each
backup are represented by their own single partition.</p>
</li>
<li>
<p>Hazelcast List cannot be scaled beyond the capacity of a single machine.</p>
</li>
<li>
<p>All items are copied to local and iteration occurs locally.</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
While IMap and ICache are the recommended data structures to be used by
<a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a>, IList can also be used by it for unit
testing or similar non-production situations. See <a href="https://docs.hazelcast.org/docs/jet/latest/manual/#imdg-list" target="_blank" rel="noopener">here</a>
in the Hazelcast Jet Reference Manual to learn how Jet can use IList, e.g., how it can fill
IList with data, consume it in a Jet job and drain the results to another IList.
See also the <a href="https://jet.hazelcast.org/use-cases/fast-batch-processing/" target="_blank" rel="noopener">Fast Batch Processing</a>
and <a href="https://jet.hazelcast.org/use-cases/real-time-stream-processing/" target="_blank" rel="noopener">Real-Time Stream Processing</a>
use cases for Hazelcast Jet.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="getting-a-list-and-putting-items"><a class="anchor" href="#getting-a-list-and-putting-items"></a>Getting a List and Putting Items</h3>
<div class="paragraph">
<p>Use the <code>HazelcastInstance</code>s <code>getList</code> method to get the List,
then use the <code>add</code> method to put items into it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        IList&lt;String&gt; list = hz.getList("list");
        list.add("Tokyo");
        list.add("Paris");
        list.add("London");
        list.add("New York");
        System.out.println("Putting finished!");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast List uses <code>ItemListener</code> to listen to events that occur when
items are added to and removed from the List. See the <a href="#listening-for-item-events">Listening for Item Events section</a> for information on how to create an item listener
class and register it.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-list"><a class="anchor" href="#configuring-list"></a>Configuring List</h3>
<div class="paragraph">
<p>The following are the example Hazelcast List configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;list name="default"&gt;
        &lt;statistics-enabled&gt;false&lt;/statistics-enabled&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;max-size&gt;10&lt;/max-size&gt;
        &lt;item-listeners&gt;
            &lt;item-listener&gt;
                com.hazelcast.examples.ItemListener
            &lt;/item-listener&gt;
        &lt;/item-listeners&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/list&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  list:
    default:
      statistics-enabled: false
      backup-count: 1
      async-backup-count: 0
      max-size: 10
      item-listeners:
        - class-name: com.hazelcast.examples.ItemListener
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        CollectionConfig collectionList = config.getListConfig("MyList");
        collectionList.setBackupCount(1)
                .setMaxSize(10)
                .setSplitBrainProtectionName("splitbrainprotectionname");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast List configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: True (default) if statistics gathering is
enabled on the list, false otherwise.</p>
</li>
<li>
<p><code>backup-count</code>: Number of synchronous backups. List is a non-partitioned
data structure, so all entries of a List reside in one partition. When this
parameter is '1', there will be one backup of that List in another member in
the cluster. When it is '2', two members will have the backup.</p>
</li>
<li>
<p><code>async-backup-count</code>: Number of asynchronous backups.</p>
</li>
<li>
<p><code>max-size</code>: The maximum number of entries for this List.</p>
</li>
<li>
<p><code>item-listeners</code>: Lets you add listeners (listener classes) for the list items.
You can also set the attribute <code>include-value</code> to <code>true</code> if you want the item event
to contain the item values. You can set the attribute <code>local</code> to <code>true</code> if you want
to listen the items on the local member.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of the split-brain protection configuration that you want this List to use.
See the <a href="#split-brain-protection-for-ilist-and-transactionallist">Split-Brain Protection for IList and TransactionalList section</a>.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="split-brain-protection-for-ilist-and-transactionallist"><a class="anchor" href="#split-brain-protection-for-ilist-and-transactionallist"></a>Split-Brain Protection for IList and TransactionalList</h3>
<div class="paragraph">
<p>IList &amp; TransactionalList can be configured to check for a minimum
number of available members before applying queue operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain protection checks:</p>
</div>
<div class="paragraph">
<p>IList:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAll</code></p>
</li>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
<li>
<p><code>removeAll</code></p>
</li>
<li>
<p><code>set</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>contains</code></p>
</li>
<li>
<p><code>containsAll</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>indexOf</code></p>
</li>
<li>
<p><code>isEmpty</code></p>
</li>
<li>
<p><code>iterator</code></p>
</li>
<li>
<p><code>lastIndexOf</code></p>
</li>
<li>
<p><code>listIterator</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>subList</code></p>
</li>
<li>
<p><code>toArray</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>TransactionalList:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for IList can be configured programmatically using
the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ListConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;list name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/list&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  list:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you
configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ringbuffer"><a class="anchor" href="#ringbuffer"></a>Ringbuffer</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast Ringbuffer is a replicated but not partitioned data structure that
stores its data in a ring-like structure. You can
think of it as a circular array with a given capacity. Each Ringbuffer has a
tail and a head. The tail is where the items are
added and the head is where the items are overwritten or expired. You can reach
each element in a Ringbuffer using a sequence
ID, which is mapped to the elements between the head and tail (inclusive) of the Ringbuffer.</p>
</div>
<div class="sect2">
<h3 id="getting-a-ringbuffer-and-reading-items"><a class="anchor" href="#getting-a-ringbuffer-and-reading-items"></a>Getting a Ringbuffer and Reading Items</h3>
<div class="paragraph">
<p>Reading from Ringbuffer is simple: get the Ringbuffer with the
HazelcastInstance <code>getRingbuffer</code> method, get its current head with
the <code>headSequence</code> method and start reading. Use the method <code>readOne</code> to
return the item at the
given sequence; <code>readOne</code> blocks if no item is available. To read the next item,
increment the sequence by one.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Ringbuffer&lt;String&gt; ringbuffer = hz.getRingbuffer("rb");
        long sequence = ringbuffer.headSequence();
        while(true){
            String item = ringbuffer.readOne(sequence);
            sequence++;
            // process item
        }</code></pre>
</div>
</div>
<div class="paragraph">
<p>By exposing the sequence, you can now move the item from the Ringbuffer
as long as the item is still available. If the item is not available
any longer, <code>StaleSequenceException</code> is thrown.</p>
</div>
</div>
<div class="sect2">
<h3 id="adding-items-to-a-ringbuffer"><a class="anchor" href="#adding-items-to-a-ringbuffer"></a>Adding Items to a Ringbuffer</h3>
<div class="paragraph">
<p>Adding an item to a Ringbuffer is also easy with the Ringbuffer <code>add</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Ringbuffer&lt;String&gt; ringbuffer = hz.getRingbuffer("ExampleRB");
ringbuffer.add("someitem");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Use the method <code>add</code> to return the sequence of the inserted item; the
sequence value is always unique. You can use this as a
very cheap way of generating unique IDs if you are already using Ringbuffer.</p>
</div>
</div>
<div class="sect2">
<h3 id="iqueue-vs-ringbuffer"><a class="anchor" href="#iqueue-vs-ringbuffer"></a>IQueue vs. Ringbuffer</h3>
<div class="paragraph">
<p>Hazelcast Ringbuffer can sometimes be a better alternative than an
Hazelcast IQueue. Unlike IQueue, Ringbuffer does not remove the items, it only
reads items using a certain position. There are many advantages to this
approach as described below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The same item can be read multiple times by the same thread. This is
useful for realizing semantics of read-at-least-once or
read-at-most-once.</p>
</li>
<li>
<p>The same item can be read by multiple threads. Normally you could use an
IQueue per thread for the same semantic, but this is
less efficient because of the increased remoting. A take from an IQueue is
destructive, so the change needs to be applied for backup
also, which is why a <code>queue.take()</code> is more expensive than a <code>ringBuffer.read(&#8230;&#8203;)</code>.</p>
</li>
<li>
<p>Reads are extremely cheap since there is no change in the Ringbuffer.
Therefore no replication is required.</p>
</li>
<li>
<p>Reads and writes can be batched to speed up performance. Batching can
dramatically improve the performance of Ringbuffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="configuring-ringbuffer-capacity"><a class="anchor" href="#configuring-ringbuffer-capacity"></a>Configuring Ringbuffer Capacity</h3>
<div class="paragraph">
<p>By default, a Ringbuffer is configured with a <code>capacity</code> of 10000 items.
This creates an array with a size of 10000. If
a <code>time-to-live</code> is configured, then an array of longs is also created that
stores the expiration time for every item.
In a lot of cases you may want to change this <code>capacity</code> number to something
that better fits your needs.</p>
</div>
<div class="paragraph">
<p>Below is a declarative configuration example of a Ringbuffer with a <code>capacity</code> of 2000 items.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;capacity&gt;2000&lt;/capacity&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      capacity: 2000</code></pre>
</div>
</div>
<div class="paragraph">
<p>Currently, Hazelcast Ringbuffer is not a partitioned data structure;
its data is stored in a single partition and the replicas
 are stored in another partition. Therefore, create a Ringbuffer that can
safely fit in a single cluster member.</p>
</div>
</div>
<div class="sect2">
<h3 id="backing-up-ringbuffer"><a class="anchor" href="#backing-up-ringbuffer"></a>Backing Up Ringbuffer</h3>
<div class="paragraph">
<p>Hazelcast Ringbuffer has a single synchronous backup by default. You can control
the Ringbuffer backup just like most of the other Hazelcast
distributed data structures by setting the synchronous and asynchronous backups:
<code>backup-count</code> and <code>async-backup-count</code>. In the example below, a Ringbuffer is configured with no
synchronous backups and one asynchronous backup:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;backup-count&gt;0&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      backup-count: 0
      async-backup-count: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>An asynchronous backup probably gives you better performance. However, there
is a chance that the item added will be lost
when the member owning the primary crashes before the backup could complete.
You may want to consider batching
methods if you need high performance but do not want to give up on consistency.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-ringbuffer-time-to-live"><a class="anchor" href="#configuring-ringbuffer-time-to-live"></a>Configuring Ringbuffer Time-To-Live</h3>
<div class="paragraph">
<p>You can configure Hazelcast Ringbuffer with a time-to-live in seconds. Using
this setting, you can control how long the items remain in
the Ringbuffer before they are expired. By default, the time-to-live is set to 0,
meaning that unless the item is overwritten,
it will remain in the Ringbuffer indefinitely. If you set a time-to-live and an item
is added, then, depending on the Overflow Policy,
either the oldest item is overwritten, or the call is rejected.</p>
</div>
<div class="paragraph">
<p>In the example below, a Ringbuffer is configured with a time-to-live of 180 seconds.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;time-to-live-seconds&gt;180&lt;/time-to-live-seconds&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      time-to-live-seconds: 180</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="setting-ringbuffer-overflow-policy"><a class="anchor" href="#setting-ringbuffer-overflow-policy"></a>Setting Ringbuffer Overflow Policy</h3>
<div class="paragraph">
<p>Using the overflow policy, you can determine what to do if the oldest item
in the Ringbuffer is not old enough to expire when
 more items than the configured Ringbuffer capacity are being added. The below
options are currently available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OverflowPolicy.OVERWRITE</code>: The oldest item is overwritten.</p>
</li>
<li>
<p><code>OverflowPolicy.FAIL</code>: The call is aborted. The methods that make use of the
OverflowPolicy return <code>-1</code> to indicate that adding
the item has failed.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Overflow policy gives you fine control on what to do if the Ringbuffer is full.
You can also use the overflow policy to apply
a back pressure mechanism. The following example code shows the usage of an exponential backoff.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Random random = new Random();
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Ringbuffer&lt;Long&gt; rb = hz.getRingbuffer("rb");

        long i = 100;
        while (true) {
            long sleepMs = 100;
            for (; ; ) {
                long result = rb.addAsync(i, OverflowPolicy.FAIL).toCompletableFuture().get();
                if (result != -1) {
                    break;
                }
                TimeUnit.MILLISECONDS.sleep(sleepMs);
                sleepMs = min(5000, sleepMs * 2);
            }

            // add a bit of random delay to make it look a bit more realistic
            Thread.sleep(random.nextInt(10));

            System.out.println("Written: " + i);
            i++;
        }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ringbuffer-with-persistent-datastore"><a class="anchor" href="#ringbuffer-with-persistent-datastore"></a>Ringbuffer with Persistent Datastore</h3>
<div class="paragraph">
<p>Hazelcast allows you to load and store the Ringbuffer items from/to a persistent
datastore using the interface <code>RingbufferStore</code>. If a Ringbuffer store is enabled,
each item added to the Ringbuffer will also be stored at the configured Ringbuffer store.</p>
</div>
<div class="paragraph">
<p>If the Ringbuffer store is configured, you can get items with sequences which are
no longer in the actual Ringbuffer but are only in the Ringbuffer store. This is
probably much slower but still allows you to continue consuming items from the
Ringbuffer even if they are overwritten with newer items in the Ringbuffer.</p>
</div>
<div class="paragraph">
<p>When a Ringbuffer is being instantiated, it checks if the Ringbuffer store is
configured and requests the latest sequence in the Ringbuffer store. This is to
enable the Ringbuffer to start with sequences larger than the ones in the Ringbuffer
store. In this case, the Ringbuffer is empty but you can still request older items
from it (which will be loaded from the Ringbuffer store).</p>
</div>
<div class="paragraph">
<p>The Ringbuffer store stores items in the same format as the Ringbuffer. If the
<code>BINARY</code> in-memory format is used, the Ringbuffer store must implement the interface
<code>RingbufferStore&lt;byte[]&gt;</code> meaning that the Ringbuffer receives items in the binary format.
If the <code>OBJECT</code> in-memory format is used, the Ringbuffer store must implement the interface
<code>RingbufferStore&lt;K&gt;</code>, where <code>K</code> is the type of item being stored (meaning that the Ringbuffer
store receives the deserialized object).</p>
</div>
<div class="paragraph">
<p>When adding items to the Ringbuffer, the method <code>storeAll</code> allows you to store items in batches.</p>
</div>
<div class="paragraph">
<p>The following example class includes all of the <code>RingbufferStore</code> methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TheRingbufferObjectStore implements RingbufferStore&lt;Item&gt; {

    @Override
    public void store(long sequence, Item data) {
        System.out.println("Object store");
    }

    @Override
    public void storeAll(long firstItemSequence, Item[] items) {
        System.out.println("Object store all");
    }

    @Override
    public Item load(long sequence) {
        System.out.println("Object load");
        return null;
    }

    @Override
    public long getLargestSequence() {
        System.out.println("Object get largest sequence");
        return -1;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>Item</code> must be serializable. The following is an example of a Ringbuffer with the
Ringbuffer store configured and enabled.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="default"&gt;
        &lt;capacity&gt;10000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;30&lt;/time-to-live-seconds&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;ringbuffer-store&gt;
            &lt;class-name&gt;com.hazelcast.RingbufferStoreImpl&lt;/class-name&gt;
        &lt;/ringbuffer-store&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    default:
      capacity: 10000
      time-to-live-seconds: 30
      backup-count: 1
      async-backup-count: 0
      in-memory-format: BINARY
      ringbuffer-store:
        class-name: com.hazelcast.RingbufferStoreImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the explanations for the Ringbuffer store configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>`class-name: Name of the Ringbuffer store factory class.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="configuring-ringbuffer-in-memory-format"><a class="anchor" href="#configuring-ringbuffer-in-memory-format"></a>Configuring Ringbuffer In-Memory Format</h3>
<div class="paragraph">
<p>You can configure Hazelcast Ringbuffer with an in-memory format that controls the
format of the Ringbuffer&#8217;s stored items. By default, <code>BINARY</code> in-memory format is used,
meaning that the object is stored in a serialized form. You can select the <code>OBJECT</code> in-memory
format, which is useful when filtering is
applied or when the <code>OBJECT</code> in-memory format has a smaller memory footprint than <code>BINARY</code>.</p>
</div>
<div class="paragraph">
<p>In the declarative configuration example below, a Ringbuffer is configured with the
<code>OBJECT</code> in-memory format:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;in-memory-format&gt;OBJECT&lt;/in-memory-format&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      in-memory-format: OBJECT</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-split-brain-protection-for-ringbuffer"><a class="anchor" href="#configuring-split-brain-protection-for-ringbuffer"></a>Configuring Split-Brain Protection for Ringbuffer</h3>
<div class="paragraph">
<p>Ringbuffer can be configured to check for a minimum number of available members before
applying Ringbuffer operations. This is a check to avoid performing successful Ringbuffer
operations on all parts of a cluster during a network partition and can be configured
using the element <code>split-brain-protection-ref</code>. You should set this element&#8217;s value as the quorum&#8217;s name,
which you configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>. Following is an example snippet:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAllAsync</code></p>
</li>
<li>
<p><code>addAsync</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>capacity</code></p>
</li>
<li>
<p><code>headSequence</code></p>
</li>
<li>
<p><code>readManyAsync</code></p>
</li>
<li>
<p><code>readOne</code></p>
</li>
<li>
<p><code>remainingCapacity</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>tailSequence</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="adding-batched-items"><a class="anchor" href="#adding-batched-items"></a>Adding Batched Items</h3>
<div class="paragraph">
<p>In the previous examples, the method <code>ringBuffer.add()</code> is used to add an item to the Ringbuffer.
The problems with this method
are that it always overwrites and that it does not support batching. Batching can have a huge
impact on the performance. You can use the method <code>addAllAsync</code> to support batching.</p>
</div>
<div class="paragraph">
<p>See the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">List&lt;String&gt; items = Arrays.asList("1","2","3");
CompletionStage&lt;Long&gt; s = rb.addAllAsync(items, OverflowPolicy.OVERWRITE);
// block until all items are added
s.toCompletableFuture().join();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above case, three strings are added to the Ringbuffer using the policy
<code>OverflowPolicy.OVERWRITE</code>. See the <a href="#setting-ringbuffer-overflow-policy">Overflow
Policy section</a> for more information.</p>
</div>
</div>
<div class="sect2">
<h3 id="reading-batched-items"><a class="anchor" href="#reading-batched-items"></a>Reading Batched Items</h3>
<div class="paragraph">
<p>In the previous example, the <code>readOne</code> method read items from the Ringbuffer.
<code>readOne</code> is simple but not very efficient for the following reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>readOne</code> does not use batching.</p>
</li>
<li>
<p><code>readOne</code> cannot filter items at the source; the items need to be retrieved
before being filtered.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The method <code>readManyAsync</code> can read a batch of items and can filter items at the source.</p>
</div>
<div class="paragraph">
<p>See the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionStage&lt;ReadResultSet&lt;E&gt;&gt; readManyAsync(
    long startSequence,
    int minCount,
    int maxCount,
    IFunction&lt;E, Boolean&gt; filter);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The meanings of the <code>readManyAsync</code> arguments are given below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>startSequence</code>: Sequence of the first item to read.</p>
</li>
<li>
<p><code>minCount</code>: Minimum number of items to read. If you do not want to block,
set it to 0. If you want to block for at least one item,
set it to 1.</p>
</li>
<li>
<p><code>maxCount</code>: Maximum number of the items to retrieve. Its value cannot exceed 1000.</p>
</li>
<li>
<p><code>filter</code>: A function that accepts an item and checks if it should be returned.
If no filtering should be applied, set it to <code>null</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A full example is given below.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">long sequence = rb.headSequence();
for(;;) {
    CompletionStage&lt;ReadResultSet&lt;String&gt;&gt; f = rb.readManyAsync(sequence, 1, 10, null);
    CompletionStage&lt;Integer&gt; readCountStage = f.thenApplyAsync(rs -&gt; {
        for (String s : rs) {
            System.out.println(s);
        }
        return rs.readCount();
    });
    sequence += readCountStage.toCompletableFuture().join();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Please take a careful look at how your sequence is being incremented. You cannot
always rely on the number of items being returned
if the items are filtered out.</p>
</div>
<div class="paragraph">
<p>There is not any filtering applied in the above example. The following example shows
how you can apply a filter when reading batched items. First, let&#8217;s create our filter
as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class FruitFilter implements IFunction&lt;String, Boolean&gt; {
    public FruitFilter() {}

    public Boolean apply(String s) {
        return s.startsWith("a");
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>So, the <code>FruitFilter</code> checks whether a String object starts with the letter "a".
You can see this filter in action in the below example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">HazelcastInstance hz = Hazelcast.newHazelcastInstance();
Ringbuffer&lt;String&gt; rb = hz.getRingbuffer("rb");

rb.add("apple");
rb.add("orange");
rb.add("pear");
rb.add("peach");
rb.add("avocado");

long sequence = rb.headSequence();
CompletableFuture&lt;ReadResultSet&lt;String&gt;&gt; f = rb.readManyAsync(sequence, 2, 5, new FruitFilter()).toCompletableFuture();

ReadResultSet&lt;String&gt; rs = f.join();
for (String s : rs) {
    System.out.println(s);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-async-methods"><a class="anchor" href="#using-async-methods"></a>Using Async Methods</h3>
<div class="paragraph">
<p>Hazelcast Ringbuffer provides asynchronous methods for more powerful operations
like batched writing or batched reading with filtering.
To wait for the result of the operation in a blocking way, obtain a <code>CompletableFuture</code>
from the returned <code>CompletionStage</code> by invoking <code>CompletionStage#toCompletableFuture()</code> method, then
use either <code>CompletableFuture#get()</code> or <code>CompletableFuture#join()</code>.</p>
</div>
<div class="paragraph">
<p>See the following example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionStage&lt;Long&gt; f = ringbuffer.addAsync(item, OverflowPolicy.FAIL);
f.toCompletableFuture().get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, you can also use <code>CompletionStage</code> API to add subsequent dependent computation
stages which will be executed when the operation  has completed. This way the thread used for
the call is not blocked until the response is returned.</p>
</div>
<div class="paragraph">
<p>See the below code as an example of when you want to
get notified when a batch of reads has completed.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompletionStage&lt;ReadResultSet&lt;String&gt;&gt; stage = rb.readManyAsync(sequence, min, max, someFilter);
stage.whenCompleteAsync((response, throwable) -&gt; {
    if (throwable == null) {
         for (String s : response) {
             System.out.println("Received:" + s);
         }
    } else {
        throwable.printStackTrace();
    }
});</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ringbuffer-configuration-examples"><a class="anchor" href="#ringbuffer-configuration-examples"></a>Ringbuffer Configuration Examples</h3>
<div class="paragraph">
<p>The following shows the declarative configuration of a Ringbuffer called <code>rb</code>.
The configuration is modeled after the Ringbuffer defaults.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;ringbuffer name="rb"&gt;
        &lt;capacity&gt;10000&lt;/capacity&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;0&lt;/async-backup-count&gt;
        &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/ringbuffer&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    rb:
      capacity: 10000
      backup-count: 1
      async-backup-count: 0
      time-to-live-seconds: 0
      in-memory-format: BINARY
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure a Ringbuffer programmatically. The following is a programmatic
version of the above declarative configuration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();
        RingbufferConfig rbConfig = config.getRingbufferConfig("myRB");
        rbConfig.setCapacity(10000)
                .setBackupCount(1)
                .setAsyncBackupCount(0)
                .setTimeToLiveSeconds(0)
                .setInMemoryFormat(InMemoryFormat.BINARY)
                .setSplitBrainProtectionName("splitbrainprotectionname");</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="topic"><a class="anchor" href="#topic"></a>Topic</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast provides a distribution mechanism for publishing messages that are delivered to multiple subscribers. This is
also known as a publish/subscribe (pub/sub) messaging model. Publishing and subscribing operations are cluster wide.
When a member subscribes to a topic, it is actually registering for messages published by any member in the cluster,
including the new members that joined after you add the listener.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Publish operation is async. It does not wait for operations to run in
remote members; it works as fire and forget.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="getting-a-topic-and-publishing-messages"><a class="anchor" href="#getting-a-topic-and-publishing-messages"></a>Getting a Topic and Publishing Messages</h3>
<div class="paragraph">
<p>Use the HazelcastInstance&#8217;s <code>getTopic</code> method to get the topic, then use the topic&#8217;s
<code>publish</code> method to publish your messages. The following is an example publisher:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TopicPublisher {

    public static void main(String[] args) {

        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ITopic&lt;Date&gt; topic = hz.getTopic("topic");
        topic.publish(new Date());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And here is an example subscriber:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class TopicSubscriber {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ITopic&lt;Date&gt; topic = hz.getTopic("topic");
        topic.addMessageListener(new MessageListenerImpl());
        System.out.println("Subscribed");
    }

    private static class MessageListenerImpl implements MessageListener&lt;Date&gt; {
        public void onMessage(Message&lt;Date&gt; m) {
            System.out.println("Received: " + m.getMessageObject());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hazelcast Topic uses the <code>MessageListener</code> interface to listen for events that occur
when a message is received. See the <a href="#listening-for-topic-messages">Listening for Topic Messages section</a>
for information on how to create a message listener class and register it.</p>
</div>
</div>
<div class="sect2">
<h3 id="getting-topic-statistics"><a class="anchor" href="#getting-topic-statistics"></a>Getting Topic Statistics</h3>
<div class="paragraph">
<p>Topic has two statistic variables that you can query. These values are incremental and local to the member.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ITopic&lt;Object&gt; myTopic = hazelcastInstance.getTopic( "myTopicName" );

        myTopic.getLocalTopicStats().getPublishOperationCount();
        myTopic.getLocalTopicStats().getReceiveOperationCount();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>getPublishOperationCount</code> and <code>getReceiveOperationCount</code> returns the total
number of published and received messages since the start of this member, respectively.
Note that these values are not backed up, so if the member goes down, these values will be lost.</p>
</div>
<div class="paragraph">
<p>You can disable this feature with topic configuration. See the <a href="#configuring-topic">Configuring Topic section</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
These statistics values can be also viewed in Management Center. See the
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-topics" target="_blank" rel="noopener">Monitoring Topics section</a>
in Hazelcast Management Center Reference Manual.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="understanding-topic-behavior"><a class="anchor" href="#understanding-topic-behavior"></a>Understanding Topic Behavior</h3>
<div class="paragraph">
<p>Each cluster member has a list of all registrations in the cluster.
When a new member is registered for a topic, it sends a registration message
to all members in the cluster. Also, when a new member joins the cluster, it
receives all registrations made so far in the cluster.</p>
</div>
<div class="paragraph">
<p>The behavior of a topic varies depending on the value of the configuration
parameter <code>globalOrderEnabled</code>.</p>
</div>
<div class="sect3">
<h4 id="ordering-messages-as-published"><a class="anchor" href="#ordering-messages-as-published"></a>Ordering Messages as Published</h4>
<div class="paragraph">
<p>If <code>globalOrderEnabled</code> is disabled, messages are not ordered and listeners
(subscribers) process the messages in the order that the messages are published.
If cluster member M publishes messages <strong>m1, m2, m3, &#8230;&#8203;, mn</strong> to a topic <strong>T</strong>,
then Hazelcast makes sure that all of the subscribers of topic <strong>T</strong> receive and
process <strong>m1, m2, m3, &#8230;&#8203;, mn</strong> in the given order.</p>
</div>
<div class="paragraph">
<p>Here is how it works: Let&#8217;s say that we have three members (<strong>member1</strong>, <strong>member2</strong> and
<strong>member3</strong>) and that <strong>member1</strong> and <strong>member2</strong> are registered to a topic named <code>news</code>.
Note that all three members know that <strong>member1</strong> and <strong>member2</strong> are registered to <code>news</code>.</p>
</div>
<div class="paragraph">
<p>In this example, <strong>member1</strong> publishes two messages: <code>a1</code> and <code>a2</code>. <strong>Member3</strong> publishes
two messages: <code>c1</code> and <code>c2</code>. When <strong>member1</strong> and <strong>member3</strong> publish a message, they check
their local list for registered members, discover that <strong>member1</strong> and <strong>member2</strong> are
in their lists, and then they fire messages to those members. One possible order of
the messages received could be the following.</p>
</div>
<div class="paragraph">
<p><strong>member1</strong> &#8594; <code>c1</code>, <code>a1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p><strong>member2</strong> &#8594; <code>c1</code>, <code>c2</code>, <code>a1</code>, <code>a2</code></p>
</div>
</div>
<div class="sect3">
<h4 id="ordering-messages-for-members"><a class="anchor" href="#ordering-messages-for-members"></a>Ordering Messages for Members</h4>
<div class="paragraph">
<p>If <code>globalOrderEnabled</code> is enabled, all members listening to the same topic
get its messages in the same order.</p>
</div>
<div class="paragraph">
<p>Here is how it works. Let&#8217;s say that we have three members (<strong>member1</strong>, <strong>member2</strong> and
<strong>member3</strong>) and that <strong>member1</strong> and <strong>member2</strong> are registered to a topic named <code>news</code>.
Note that all three members know that <strong>member1</strong> and <strong>member2</strong> are registered to <code>news</code>.</p>
</div>
<div class="paragraph">
<p>In this example, <strong>member1</strong> publishes two messages: <code>a1</code> and <code>a2</code>. <strong>Member3</strong> publishes
two messages: <code>c1</code> and <code>c2</code>. When a member publishes messages over the topic <code>news</code>,
it first calculates which partition the <code>news</code> ID corresponds to. Then it sends an
operation to the owner of the partition for that member to publish messages. Let&#8217;s assume
that <code>news</code> corresponds to a partition that <strong>member2</strong> owns. <strong>member1</strong> and <strong>member3</strong> first
sends all messages to <strong>member2</strong>. Assume that the messages are published in the following order:</p>
</div>
<div class="paragraph">
<p><strong>member1</strong> &#8594; <code>a1</code>, <code>c1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p><strong>member2</strong> then publishes these messages by looking at registrations in its local list.
It sends these messages to <strong>member1</strong> and <strong>member2</strong> (it makes a local dispatch for itself).</p>
</div>
<div class="paragraph">
<p><strong>member1</strong> &#8594; <code>a1</code>, <code>c1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p><strong>member2</strong> &#8594; <code>a1</code>, <code>c1</code>, <code>a2</code>, <code>c2</code></p>
</div>
<div class="paragraph">
<p>This way we guarantee that all members see the events in the same order.</p>
</div>
</div>
<div class="sect3">
<h4 id="keeping-generated-and-published-order-the-same"><a class="anchor" href="#keeping-generated-and-published-order-the-same"></a>Keeping Generated and Published Order the Same</h4>
<div class="paragraph">
<p>In both cases, there is a <code>StripedExecutor</code> in EventService that is responsible for
dispatching the received message. For all events in Hazelcast, the order that events
are generated and the order they are published to the user are guaranteed to be the
same via this <code>StripedExecutor</code>.</p>
</div>
<div class="paragraph">
<p>In <code>StripedExecutor</code>, there are as many threads as are specified in the property
<code>hazelcast.event.thread.count</code> (default is five). For a specific event source (for a
particular topic name), <strong>hash of that source&#8217;s name % 5</strong> gives the ID of the responsible
thread. Note that there can be another event source (entry listener of a map, item listener
of a collection, etc.) corresponding to the same thread. In order not to make other messages
to block, heavy processing should not be done in this thread. If there is time-consuming work
that needs to be done, the work should be handed over to another thread. See the
<a href="#getting-a-topic-and-publishing-messages">Getting a Topic and Publishing Messages section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-topic"><a class="anchor" href="#configuring-topic"></a>Configuring Topic</h3>
<div class="paragraph">
<p>To configure a topic, set the topic name, decide on statistics and global ordering,
and set the message listeners.
The following are the default values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>global-ordering</code> is <strong>false</strong>, meaning that by default, there is no guarantee of global order.</p>
</li>
<li>
<p><code>statistics</code> is <strong>true</strong>, meaning that by default, statistics are calculated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can see the example configuration snippets below.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;topic name="yourTopicName"&gt;
        &lt;global-ordering-enabled&gt;true&lt;/global-ordering-enabled&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;message-listeners&gt;
            &lt;message-listener&gt;MessageListenerImpl&lt;/message-listener&gt;
        &lt;/message-listeners&gt;
    &lt;/topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  topic:
    yourTopicName:
      global-ordering-enabled: true
      statistics-enabled: true
      message-listeners:
        - MessageListenerImpl</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        TopicConfig topicConfig = new TopicConfig();
        topicConfig.setGlobalOrderingEnabled( true );
        topicConfig.setStatisticsEnabled( true );
        topicConfig.setName( "yourTopicName" );
        MessageListener&lt;String&gt; implementation = new MessageListener&lt;String&gt;() {
            @Override
            public void onMessage( Message&lt;String&gt; message ) {
                // process the message
            }
        };
        topicConfig.addMessageListenerConfig( new ListenerConfig( implementation ) );
        HazelcastInstance instance = Hazelcast.newHazelcastInstance();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Topic configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your topic.
If set to <code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalTopicStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-topics" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>global-ordering-enabled</code>: Default is <code>false</code>, meaning there is no global order guarantee.</p>
</li>
<li>
<p><code>message-listeners</code>: Lets you add listeners (listener classes) for the topic messages.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Besides the above elements, there are the following system properties
that are topic related but not topic specific:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hazelcast.event.queue.capacity</code> with a default value of 1,000,000</p>
</li>
<li>
<p><code>hazelcast.event.queue.timeout.millis</code> with a default value of 250</p>
</li>
<li>
<p><code>hazelcast.event.thread.count</code> with a default value of 5</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the descriptions of these parameters, see the <a href="#global-event-configuration">Global Event Configuration section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="reliable-topic"><a class="anchor" href="#reliable-topic"></a>Reliable Topic</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Reliable Topic uses the same <code>ITopic</code> interface
as a regular topic. The main difference is that Reliable Topic
is backed up by the Ringbuffer data structure. The following are the advantages of this approach:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Events are not lost since the Ringbuffer is configured with one
synchronous backup by default.</p>
</li>
<li>
<p>Each Reliable <code>ITopic</code> gets its own Ringbuffer; if a topic has a
very fast producer, it will not lead to problems at topics that run at a slower pace.</p>
</li>
<li>
<p>Since the event system behind a regular <code>ITopic</code> is shared with other
data structures, e.g., collection listeners,
  you can run into isolation problems. This does not happen with the Reliable <code>ITopic</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example for a publisher using Reliable Topic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PublisherMember {
    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Random random = new Random();
        ITopic&lt;Long&gt; topic = hz.getReliableTopic("sometopic");
        long messageId = 0;

        while (true) {
            topic.publish(messageId);
            messageId++;
            System.out.println("Written: " + messageId);
            sleepMillis(random.nextInt(100));
        }
    }
    public static boolean sleepMillis(int millis) {
        try {
            MILLISECONDS.sleep(millis);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            return false;
        }
        return true;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>And the following is an example for the subscriber:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class SubscribedMember {

    public static void main(String[] args) {
        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ITopic&lt;Long&gt; topic = hz.getReliableTopic("sometopic");
        topic.addMessageListener(new MessageListenerImpl());
    }

    private static class MessageListenerImpl implements MessageListener&lt;Long&gt; {
        public void onMessage(Message&lt;Long&gt; m) {
            System.out.println("Received: " + m.getMessageObject());
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you create a Reliable Topic, Hazelcast automatically creates a
Ringbuffer for it. You may configure this Ringbuffer by adding a Ringbuffer config
with the same name as the Reliable Topic. For instance, if you have a
Reliable Topic with the name "sometopic", you should add a Ringbuffer config
with the name "sometopic" to configure the backing Ringbuffer. Some of the
things that you may configure are the capacity, the time-to-live for the topic
messages, and you can even add a Ringbuffer store which allows you to have a persistent topic.
By default, a Ringbuffer does not have any TTL (time-to-live) and it has a limited
capacity; you may want to change that configuration. The following is an example
configuration for the "sometopic" given above.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;!-- This is the ringbuffer that is used by the 'sometopic' Reliable-topic. As you can see the
         ringbuffer has the same name as the topic. --&gt;
    &lt;ringbuffer name="sometopic"&gt;
        &lt;capacity&gt;1000&lt;/capacity&gt;
        &lt;time-to-live-seconds&gt;5&lt;/time-to-live-seconds&gt;
    &lt;/ringbuffer&gt;
    &lt;reliable-topic name="sometopic"&gt;
        &lt;topic-overload-policy&gt;BLOCK&lt;/topic-overload-policy&gt;
    &lt;/reliable-topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  ringbuffer:
    sometopic:
      capacity: 1000
      time-to-live-seconds: 5
  reliable-topic:
    sometopic:
      topic-overload-policy: BLOCK</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#configuring-reliable-topic">Configuring Reliable Topic section</a>
below for the descriptions of all Reliable Topic configuration elements.</p>
</div>
<div class="paragraph">
<p>By default, the Reliable <code>ITopic</code> uses a shared thread pool. If you need a
better isolation, you can configure a custom executor on the
<code>ReliableTopicConfig</code>.</p>
</div>
<div class="paragraph">
<p>Because the reads on a Ringbuffer are not destructive, batching is easy to apply.
<code>ITopic</code> uses read batching and reads
ten items at a time (if available) by default. See <a href="#reading-batched-items">Reading Batched Items</a>
for more information.</p>
</div>
<div class="sect2">
<h3 id="slow-consumers"><a class="anchor" href="#slow-consumers"></a>Slow Consumers</h3>
<div class="paragraph">
<p>The Reliable <code>ITopic</code> provides control and a way to deal with slow consumers.
It is unwise to keep events for a slow consumer in memory
indefinitely since you do not know when the slow consumer is going to catch up.
You can control the size of the Ringbuffer by using its capacity. For the cases
when a Ringbuffer runs out of its capacity, you can specify the following policies
for the <code>TopicOverloadPolicy</code> configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DISCARD_OLDEST</code>: Overwrite the oldest item, even if a TTL is set.
In this case the fast producer supersedes a slow consumer.</p>
</li>
<li>
<p><code>DISCARD_NEWEST</code>: Discard the newest item.</p>
</li>
<li>
<p><code>BLOCK</code>: Wait until the items are expired in the Ringbuffer.</p>
</li>
<li>
<p><code>ERROR</code>: Immediately throw <code>TopicOverloadException</code> if there is no space in the Ringbuffer.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="configuring-reliable-topic"><a class="anchor" href="#configuring-reliable-topic"></a>Configuring Reliable Topic</h3>
<div class="paragraph">
<p>The following are example Reliable Topic configurations.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;reliable-topic name="default"&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;message-listeners&gt;
            &lt;message-listener&gt;
                ...
            &lt;/message-listener&gt;
        &lt;/message-listeners&gt;
        &lt;read-batch-size&gt;10&lt;/read-batch-size&gt;
        &lt;topic-overload-policy&gt;BLOCK&lt;/topic-overload-policy&gt;
    &lt;/reliable-topic&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  reliable-topic:
    default:
      statistics-enabled: true
      message-listeners:
        - ...
      read-batch-size: 10
      topic-overload-policy: BLOCK</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
ReliableTopicConfig rtConfig = config.getReliableTopicConfig( "default" );
rtConfig.setTopicOverloadPolicy( TopicOverloadPolicy.BLOCK )
    .setReadBatchSize( 10 )
    .setStatisticsEnabled( true );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Reliable Topic configuration has the following elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is
enabled for your Reliable Topic. If set to <code>false</code>, you cannot collect statistics
in your implementation and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-reliable-topics" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>message-listener</code>: Message listener class that listens to the
messages when they are added or removed.</p>
</li>
<li>
<p><code>read-batch-size</code>: Minimum number of messages that Reliable Topic
tries to read in batches. Its default value is 10.</p>
</li>
<li>
<p><code>topic-overload-policy</code>: Policy to handle an overloaded topic.
Available values are <code>DISCARD_OLDEST</code>, <code>DISCARD_NEWEST</code>, <code>BLOCK</code> and <code>ERROR</code>.
Its default value is <code>BLOCK</code>. See <a href="#slow-consumers">Slow Consumers</a> for definitions of these policies.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="lock"><a class="anchor" href="#lock"></a>FencedLock</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>FencedLock</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>FencedLock</code> is a linearizable and distributed implementation of
<code>java.util.concurrent.locks.Lock</code>, meaning that if you lock using a <code>FencedLock</code>,
the critical section that it guards is guaranteed to be executed by only one thread
in the entire cluster. Even though locks are great for synchronization, they can lead
to problems if not used properly. Also note that Hazelcast Lock does not support fairness.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For detailed information and configuration, see the <a href="#fencedlock">FencedLock section</a>
under the CP Subsystem chapter.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="using-try-catch-blocks-with-locks"><a class="anchor" href="#using-try-catch-blocks-with-locks"></a>Using Try-Catch Blocks with Locks</h3>
<div class="paragraph">
<p>Always use locks with <strong>try</strong>-<strong>catch</strong> blocks. This ensures that locks are
released if an exception is thrown from
the code in a critical section. Also note that the <code>lock</code> method is outside
the <strong>try</strong>-<strong>catch</strong> block because we do not want to unlock
if the lock operation itself fails.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();

        Lock lock = hazelcastInstance.getCPSubsystem().getLock("myLock");
        lock.lock();
        try {
            // do something here
        } finally {
            lock.unlock();
        }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="releasing-locks-with-trylock-timeout"><a class="anchor" href="#releasing-locks-with-trylock-timeout"></a>Releasing Locks with tryLock Timeout</h3>
<div class="paragraph">
<p>If a lock is not released in the cluster, another thread that is trying to get the
lock can wait forever. To avoid this, use <code>tryLock</code> with a timeout value. You can
set a high value (normally it should not take that long) for <code>tryLock</code>.
You can check the return value of <code>tryLock</code> as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">if ( lock.tryLock ( 10, TimeUnit.SECONDS ) ) {
  try {
    // do some stuff here..
  } finally {
    lock.unlock();
  }
} else {
  // warning
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="understanding-lock-behavior"><a class="anchor" href="#understanding-lock-behavior"></a>Understanding Lock Behavior</h3>
<div class="ulist">
<ul>
<li>
<p>Locks are fail-safe. If a member holds a lock and some other members go down,
the cluster will keep your locks safe and available.
Moreover, when a member leaves the cluster, all the locks acquired by that
dead member will be removed so that those
locks are immediately available for live members.</p>
</li>
<li>
<p>Locks are not automatically removed. If a lock is not used anymore, Hazelcast
does not automatically perform garbage collection in the lock.
This can lead to an <code>OutOfMemoryError</code>. If you create locks on the fly,
make sure they are destroyed.</p>
</li>
<li>
<p>Locks are re-entrant. The same thread can lock multiple times on the same lock.
Note that for other threads to be able to require this lock, the owner of the lock
must call <code>unlock</code> as many times as the owner called <code>lock</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="iatomiclong"><a class="anchor" href="#iatomiclong"></a>IAtomicLong</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>IAtomicLong</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast <code>IAtomicLong</code> is the distributed implementation of
<code>java.util.concurrent.atomic.AtomicLong</code>. It offers most of AtomicLong&#8217;s operations
such as <code>get</code>, <code>set</code>, <code>getAndSet</code>, <code>compareAndSet</code> and <code>incrementAndGet</code>.
Since IAtomicLong is a distributed implementation, these operations involve remote
calls and thus their performances differ from AtomicLong.</p>
</div>
<div class="paragraph">
<p>The following example code creates an instance, increments it
by a million and prints the count.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IAtomicLong counter = hazelcastInstance.getCPSubsystem().getAtomicLong( "counter" );
        for ( int k = 0; k &lt; 1000 * 1000; k++ ) {
            if ( k % 500000 == 0 ) {
                System.out.println( "At: " + k );
            }
            counter.incrementAndGet();
        }
        System.out.printf( "Count is %s\n", counter.get() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you start other instances with the code above,
you will see the count as <strong>member count</strong> times <strong>a million</strong>.</p>
</div>
<div class="sect2">
<h3 id="sending-functions-to-iatomiclong"><a class="anchor" href="#sending-functions-to-iatomiclong"></a>Sending Functions to IAtomicLong</h3>
<div class="paragraph">
<p>You can send functions to an IAtomicLong. <code>IFunction</code> is a Hazelcast owned,
single method interface. The following example <code>IFunction</code> implementation
adds two to the original value.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">    private static class Add2Function implements IFunction&lt;Long, Long&gt; {
        @Override
        public Long apply( Long input ) {
            return input + 2;
        }
    }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="executing-functions-on-iatomiclong"><a class="anchor" href="#executing-functions-on-iatomiclong"></a>Executing Functions on IAtomicLong</h3>
<div class="paragraph">
<p>You can use the following methods to execute functions on IAtomicLong:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>apply</code>: Applies the function to the value in IAtomicLong without
changing the actual value and returning the result.</p>
</li>
<li>
<p><code>alter</code>: Alters the value stored in the IAtomicLong by applying the function.
It does not send back a result.</p>
</li>
<li>
<p><code>alterAndGet</code>: Alters the value stored in the IAtomicLong by applying the function,
storing the result in the IAtomicLong and returning the result.</p>
</li>
<li>
<p><code>getAndAlter</code>: Alters the value stored in the IAtomicLong by applying the function
and returning the original value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following example includes these methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        IAtomicLong atomicLong = hazelcastInstance.getCPSubsystem().getAtomicLong( "counter" );

        atomicLong.set( 1 );
        long result = atomicLong.apply( new Add2Function() );
        System.out.println( "apply.result: " + result);
        System.out.println( "apply.value: " + atomicLong.get() );

        atomicLong.set( 1 );
        atomicLong.alter( new Add2Function() );
        System.out.println( "alter.value: " + atomicLong.get() );

        atomicLong.set( 1 );
        result = atomicLong.alterAndGet( new Add2Function() );
        System.out.println( "alterAndGet.result: " + result );
        System.out.println( "alterAndGet.value: " + atomicLong.get() );

        atomicLong.set( 1 );
        result = atomicLong.getAndAlter( new Add2Function() );
        System.out.println( "getAndAlter.result: " + result );
        System.out.println( "getAndAlter.value: " + atomicLong.get() );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The output of the above class when run is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>apply.result: 3
apply.value: 1
alter.value: 3
alterAndGet.result: 3
alterAndGet.value: 3
getAndAlter.result: 1
getAndAlter.value: 3</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="reasons-to-use-functions-with-iatomic"><a class="anchor" href="#reasons-to-use-functions-with-iatomic"></a>Reasons to Use Functions with IAtomicLong</h3>
<div class="paragraph">
<p>The reason for using a function instead of a simple code line like
<code>atomicLong.set(atomicLong.get() + 2));</code> is that the IAtomicLong read and write
operations are not atomic. Since <code>IAtomicLong</code> is a distributed implementation,
those operations can be remote ones, which may lead to race problems. By using functions,
the data is not pulled into the code, but the code is sent to the data. This makes it more scalable.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="isemaphore"><a class="anchor" href="#isemaphore"></a>ISemaphore</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ISemaphore</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast ISemaphore is the distributed implementation of <code>java.util.concurrent.Semaphore</code>.</p>
</div>
<div class="sect2">
<h3 id="controlling-thread-counts-with-permits"><a class="anchor" href="#controlling-thread-counts-with-permits"></a>Controlling Thread Counts with Permits</h3>
<div class="paragraph">
<p>Semaphores offer <strong>permit</strong>s to control the thread counts when performing concurrent activities.
To execute a concurrent activity, a thread grants a permit or waits until a permit
becomes available. When the execution is completed, the permit is released.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<code>ISemaphore</code> with a single permit may be considered as a lock. Unlike the locks,
when semaphores are used, any thread can release the permit depending on the configuration,
and semaphores can have multiple permits. For more information, see the <a href="#semaphore-configuration">Semaphore Configuration section</a>.
</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
Hazelcast ISemaphore does not support fairness at all times. There are some edge cases
where the fairness is not honored, e.g., when the permit becomes available
at the time when an internal timeout occurs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When a permit is acquired on ISemaphore:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there are permits, the number of permits in the semaphore is decreased by one
and the calling thread performs its activity. If there is contention,
the longest waiting thread acquires the permit before all other threads.</p>
</li>
<li>
<p>If no permits are available, the calling thread blocks until a permit
becomes available. When a timeout happens during this block, the thread is interrupted.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="example-semaphore-code"><a class="anchor" href="#example-semaphore-code"></a>Example Semaphore Code</h3>
<div class="paragraph">
<p>The following example code uses an <code>IAtomicLong</code> resource 1000 times,
increments the resource when a thread starts to use it and decrements
it when the thread completes.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ISemaphore semaphore = hazelcastInstance.getCPSubsystem().getSemaphore( "semaphore" );
        IAtomicLong resource = hazelcastInstance.getCPSubsystem().getAtomicLong( "resource" );
        for ( int k = 0 ; k &lt; 1000 ; k++ ) {
            System.out.println( "At iteration: " + k + ", Active Threads: " + resource.get() );
            semaphore.acquire();
            try {
                resource.incrementAndGet();
                Thread.sleep( 1000 );
                resource.decrementAndGet();
            } finally {
                semaphore.release();
            }
        }
        System.out.println("Finished");</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you execute the above <code>SemaphoreMember</code> class 5 times,
the following output appears:</p>
</div>
<div class="paragraph">
<p><code>At iteration: 0, Active Threads: 1</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 1, Active Threads: 2</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 2, Active Threads: 3</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 3, Active Threads: 3</code></p>
</div>
<div class="paragraph">
<p><code>At iteration: 4, Active Threads: 3</code></p>
</div>
<div class="paragraph">
<p>As you can see, the maximum count of concurrent threads is equal or
smaller than three. If you remove the semaphore acquire/release statements
in <code>SemaphoreMember</code>, you will see that there is no limitation on the number
of concurrent usages.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="iatomicreference"><a class="anchor" href="#iatomicreference"></a>IAtomicReference</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>IAtomicReference</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>IAtomicLong</code> is very useful if you need to deal with a long,
but in some cases you need to deal with a reference. That is why Hazelcast
also supports the <code>IAtomicReference</code> which is the distributed version of
the <code>java.util.concurrent.atomic.AtomicReference</code>.</p>
</div>
<div class="paragraph">
<p>Here is an IAtomicReference example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();

        HazelcastInstance hz = Hazelcast.newHazelcastInstance(config);

        IAtomicReference&lt;String&gt; ref = hz.getCPSubsystem().getAtomicReference("reference");
        ref.set("foo");
        System.out.println(ref.get());
        System.exit(0);</code></pre>
</div>
</div>
<div class="paragraph">
<p>When you execute the above example, the output is as follows:</p>
</div>
<div class="paragraph">
<p><code>foo</code></p>
</div>
<div class="sect2">
<h3 id="sending-functions-to-iatomicreference"><a class="anchor" href="#sending-functions-to-iatomicreference"></a>Sending Functions to IAtomicReference</h3>
<div class="paragraph">
<p>Just like <code>IAtomicLong</code>, <code>IAtomicReference</code> has methods that accept a
'function' as an argument, such as <code>alter</code>, <code>alterAndGet</code>, <code>getAndAlter</code> and <code>apply</code>.
There are two big advantages of using these methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>From a performance point of view, it is better to send the function to the data
than the data to the function. Often the function is a lot smaller than the data and
therefore cheaper to send over the line. Also the function only needs to be transferred
once to the target machine and the data needs to be transferred twice.</p>
</li>
<li>
<p>You do not need to deal with concurrency control. If you would perform a load, transform,
store, you could run into a data race since another thread might have updated the value you
are about to overwrite.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="using-iatomicreference"><a class="anchor" href="#using-iatomicreference"></a>Using IAtomicReference</h3>
<div class="paragraph">
<p>The following are some considerations you need to know when you use IAtomicReference:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IAtomicReference</code> works based on the byte-content and not on the object-reference.
If you use the <code>compareAndSet</code> method, do not change to the original value because its
serialized content will then be different. It is also important to know that if you rely
on Java serialization, sometimes (especially with hashmaps) the same object can result in
different binary content.</p>
</li>
<li>
<p>All methods returning an object return a private copy. You can modify the private copy,
but the rest of the world is shielded from your changes. If you want these changes to be
visible to the rest of the world, you need to write the change back to the <code>IAtomicReference</code>;
but be careful about introducing a data-race.</p>
</li>
<li>
<p>The 'in-memory format' of an <code>IAtomicReference</code> is <code>binary</code>. The receiving side does
not need to have the class definition available unless it needs to be deserialized on the
other side, e.g., because a method like 'alter' is executed. This deserialization is done
for every call that needs to have the object instead of the binary content, so be careful
with expensive object graphs that need to be deserialized.</p>
</li>
<li>
<p>If you have an object with many fields or an object graph and you only need to calculate
some information or need a subset of fields, you can use the <code>apply</code> method. With the <code>apply</code>
method, the whole object does not need to be sent over the line; only the information that is
relevant is sent.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="icountdownlatch"><a class="anchor" href="#icountdownlatch"></a>ICountDownLatch</h2>
<div class="sectionbody">
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>ICountDownLatch</code> is a member of CP Subsystem API.
For detailed information, see the <a href="#cp-subsystem">CP Subsystem</a> chapter.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast <code>ICountDownLatch</code> is the distributed implementation of
<code>java.util.concurrent.CountDownLatch</code>. But unlike Java&#8217;s implementation,
Hazelcast&#8217;s <code>ICountDownLatch</code> count can be reset after a countdown has finished,
but not during an active count.</p>
</div>
<div class="sect2">
<h3 id="gate-keeping-concurrent-activities"><a class="anchor" href="#gate-keeping-concurrent-activities"></a>Gate-Keeping Concurrent Activities</h3>
<div class="paragraph">
<p><code>ICountDownLatch</code> is considered to be a gate keeper for concurrent activities.
It enables the threads to wait for other threads to complete their operations.
The following examples describe the mechanism of <code>ICountDownLatch</code>.</p>
</div>
<div class="paragraph">
<p>Assume that there is a leader process and there are follower processes that will
wait until the leader completes. Here is the leader:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Leader {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ICountDownLatch latch = hazelcastInstance.getCPSubsystem().getCountDownLatch( "countDownLatch" );
        System.out.println( "Starting" );
        latch.trySetCount( 1 );
        Thread.sleep( 30000 );
        latch.countDown();
        System.out.println( "Leader finished" );
        latch.destroy();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since only a single step is needed to be completed as a sample, the above code
initializes the latch with 1. Then, the code sleeps for a while to simulate a
process and starts the countdown. Finally, it clears up the latch. Let&#8217;s write a follower:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class Follower {
    public static void main( String[] args ) throws Exception {
        HazelcastInstance hazelcastInstance = Hazelcast.newHazelcastInstance();
        ICountDownLatch latch = hazelcastInstance.getCPSubsystem().getCountDownLatch( "countDownLatch" );
        System.out.println( "Waiting" );
        boolean success = latch.await( 10, TimeUnit.SECONDS );
        System.out.println( "Complete: " + success );
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The follower class above first retrieves <code>ICountDownLatch</code> and then calls the <code>await</code>
method to enable the thread to listen for the latch. The method <code>await</code> has a timeout
value as a parameter. This is useful when the <code>countDown</code> method fails. To see <code>ICountDownLatch</code>
in action, start the leader first and then start one or more followers. You will see that the
followers wait until the leader completes.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pn-counter"><a class="anchor" href="#pn-counter"></a>PN Counter</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Conflict-free Replicated Data Type (CRDT) is a distributed data structure
that achieves high availability by relaxing consistency constraints.
There may be several replicas for the same data and these replicas can be
modified concurrently without coordination. This means that you may achieve
high throughput and low latency when updating a CRDT data structure.
On the other hand, all of the updates are replicated asynchronously.
Each replica then receives updates made on other replicas eventually and
if no new updates are done, all replicas which can communicate to each other
return the same state (converge) after some time.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers a lightweight CRDT PN counter (Positive-Negative Counter)
implementation where each Hazelcast instance can increment and decrement the
counter value and these updates are propagated to all replicas. Only a Hazelcast
member can store state for a counter which means that counter method invocations
performed on a Hazelcast member are usually local (depending on the configured
replica count). If there is no member failure, it is guaranteed that each replica
sees the final value of the counter eventually. Counter&#8217;s state converges with each
update and all CRDT replicas that can communicate to each other will eventually have the same state.</p>
</div>
<div class="paragraph">
<p>Using the PN Counter, you can get a distributed counter, increment and decrement it,
and query its value with RYW (read-your-writes) and monotonic reads. The implementation
borrows most methods from the <code>AtomicLong</code> which should be familiar in most cases and
easily interchangeable in the existing code.</p>
</div>
<div class="paragraph">
<p>Some examples of PN counter are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>counting the number of "likes" or "+1"</p>
</li>
<li>
<p>counting the number of logged in users</p>
</li>
<li>
<p>counting the number of page hits/views.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>How it works</strong></p>
</div>
<div class="paragraph">
<p>The counter supports adding and subtracting values as well as retrieving
the current counter value. Each replica of this counter can perform operations
locally without coordination with the other replicas, thus increasing availability.
The counter guarantees that whenever two members have received the same set of updates,
possibly in a different order, their state is identical, and any conflicting updates
are merged automatically. If no new updates are made to the shared state, all
members that can communicate will eventually have the same data.</p>
</div>
<div class="paragraph">
<p>The updates to the counter are applied locally when invoked on a CRDT replica.
A CRDT replica can be any Hazelcast instance <strong>which is NOT a client or a lite member</strong>.
You can configure the number of replicas in the cluster using the <code>replica-count</code>
configuration element.</p>
</div>
<div class="paragraph">
<p>When invoking updates from a non-replica instance, the invocation is remote.
This may lead to indeterminate state - the update may be applied but the response
has not been received. In this case, the caller is notified with a
<code>TargetDisconnectedException</code> when invoked from a client or a <code>MemberLeftException</code>
when invoked from a member.</p>
</div>
<div class="paragraph">
<p>The read and write methods provide monotonic read and RYW (read-your-write) guarantees.
These guarantees are session guarantees which mean that if no replica with the previously
observed state is reachable, the session guarantees are lost and the method invocation
throws a <code>ConsistencyLostException</code>. This does not mean that an update is lost.
All of the updates are part of some replica and eventually reflected in the state of all other replicas.
This exception just means that you cannot observe your own writes because all replicas
that contain your updates are currently unreachable. After you have received a
<code>ConsistencyLostException</code>, you can either wait for a sufficiently up-to-date replica
to become reachable in which case the session can be continued or you can reset the
session by calling the method `reset(). If you have called this method, a new session
is started with the next invocation to a CRDT replica.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The CRDT state is kept entirely on non-lite (data) members. If there aren&#8217;t any
and the methods here are invoked on a lite member, they fail with a <code>NoDataMemberInClusterException</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is an example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final HazelcastInstance instance = Hazelcast.newHazelcastInstance();
        final PNCounter counter = instance.getPNCounter("counter");
        counter.addAndGet(5);
        final long value = counter.get();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This code snippet creates an instance of a PN counter, increments it by 5 and retrieves the value.</p>
</div>
<div class="sect2">
<h3 id="configuring-pn-counter"><a class="anchor" href="#configuring-pn-counter"></a>Configuring PN Counter</h3>
<div class="paragraph">
<p>Following is an example declarative configuration snippet:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;pn-counter name="default"&gt;
        &lt;replica-count&gt;10&lt;/replica-count&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;/pn-counter&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  pn-counter:
    default:
      replica-count: 10
      statistics-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>PN Counter has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of your PN Counter.</p>
</li>
<li>
<p><code>replica-count</code>: Number of replicas on which state for this PN counter is kept.
This number applies in quiescent state, if there are currently membership changes or
clusters are merging, the state may be temporarily kept on more replicas.
Its default value is Integer.MAX_VALUE. Generally, keeping the state on more replicas
means that more Hazelcast members are able to perform updates locally but it also means
that the PN counter state is kept on more replicas, increasing the network traffic,
decreasing the speed at which replica states converge and increasing the size of the
PN counter state kept on each replica.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled for your
PN Counter. If set to <code>false</code>, you cannot collect statistics in your implementation
(using <code>getLocalPNCounterStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-pn-counters" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an equivalent snippet of Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        PNCounterConfig pnCounterConfig = new PNCounterConfig("default")
                .setReplicaCount(10)
                .setStatisticsEnabled(true);
        Config hazelcastConfig = new Config()
                .addPNCounterConfig(pnCounterConfig);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-the-crdt-replication-mechanism"><a class="anchor" href="#configuring-the-crdt-replication-mechanism"></a>Configuring the CRDT Replication Mechanism</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Configuring the replication mechanism is for advanced use
cases only - usually the default configuration works fine for most cases.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In some cases, you may want to configure the replication mechanism for all
CRDT implementations. The CRDT states are replicated in rounds (the period is
configurable) and in each round the state is replicated up to the configured number
of members. Generally speaking, you may increase the speed at which replicas converge
at the expense of more network traffic or decrease the network traffic at the expense
of slower convergence of replicas.
Hazelcast implements the state-based replication mechanism - the CRDT state for changed
CRDTs is replicated in its entirety to other replicas on each replication round.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;crdt-replication&gt;
        &lt;max-concurrent-replication-targets&gt;1&lt;/max-concurrent-replication-targets&gt;
        &lt;replication-period-millis&gt;1000&lt;/replication-period-millis&gt;
    &lt;/crdt-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  crdt-replication:
    max-concurrent-replication-targets: 1
    replication-period-millis: 1000</code></pre>
</div>
</div>
<div class="paragraph">
<p>CRDT replication has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>max-concurrent-replication-targets</code>: The maximum number of target members
that we replicate the CRDT states to in one period. A higher count leads to
states being disseminated more rapidly at the expense of burst-like behavior -
one update to a CRDT leads to a sudden burst in the number of replication messages
in a short time interval. Its default value is 1 which means that each replica
replicates state to only one other replica in each replication round.</p>
</li>
<li>
<p><code>replication-period-millis</code>: The period between two replications of CRDT states
in milliseconds. A lower value increases the speed at which changes are disseminated
to other cluster members at the expense of burst-like behavior - less updates are
batched together in one replication message, and one update to a CRDT may cause a
sudden burst of replication messages in a short time interval. The value must be a
positive non-null integer. Its default value is 1000 milliseconds which means that
the changed CRDT state is replicated every 1 second.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Following is an equivalent snippet of Java configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        final CRDTReplicationConfig crdtReplicationConfig = new CRDTReplicationConfig()
                .setMaxConcurrentReplicationTargets(1)
                .setReplicationPeriodMillis(1000);
        Config hazelcastConfig = new Config()
                .setCRDTReplicationConfig(crdtReplicationConfig);</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="flakeidgenerator"><a class="anchor" href="#flakeidgenerator"></a>Flake ID Generator</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast Flake ID Generator is used to generate cluster-wide unique identifiers.
Generated identifiers are <code>long</code> primitive values and are k-ordered (roughly ordered).
IDs are in the range from 0 to Long.MAX_VALUE.</p>
</div>
<div class="sect2">
<h3 id="generating-cluster-wide-flake-ids"><a class="anchor" href="#generating-cluster-wide-flake-ids"></a>Generating Cluster-Wide IDs</h3>
<div class="paragraph">
<p>The IDs contain timestamp component and a node ID component, which is assigned when the
member joins the cluster. This allows the IDs to be ordered and unique without any
coordination between the members, which makes the generator safe even in split-brain
scenarios (for limitations in this case, see the <a href="#node-id-assignment">Node ID assignment section</a> below).</p>
</div>
<div class="paragraph">
<p>Timestamp component is in milliseconds since 1.1.2018, 0:00 UTC and has 41 bits.
This caps the useful lifespan of the generator to little less than 70 years (until ~2088).
The sequence component is 6 bits. If more than 64 IDs are requested in single millisecond,
IDs gracefully overflow to the next millisecond and uniqueness is guaranteed in this case.
The implementation does not allow overflowing by more than 15 seconds, if IDs are requested
at higher rate, the call blocks. Note, however, that clients are able to generate even faster
because each call goes to a different (random) member and the 64 IDs/ms limit is for single member.</p>
</div>
</div>
<div class="sect2">
<h3 id="flakeidgenerator-performance"><a class="anchor" href="#flakeidgenerator-performance"></a>Performance</h3>
<div class="paragraph">
<p>Operation on member is always local, if the member has valid node ID, otherwise it&#8217;s remote.
On the client, the <code>newId()</code> method goes to a random member and gets a batch of IDs,
which is then returned locally for a limited time. The pre-fetch size and the validity
time can be configured for each client and member.</p>
</div>
</div>
<div class="sect2">
<h3 id="flakeidgenerator-example"><a class="anchor" href="#flakeidgenerator-example"></a>Example</h3>
<div class="paragraph">
<p>Let&#8217;s write an example identifier generator.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ExampleFlakeIdGenerator {
    public static void main(String[] args) {
        HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance();

        ClientConfig clientConfig = new ClientConfig()
                .addFlakeIdGeneratorConfig(new ClientFlakeIdGeneratorConfig("idGenerator")
                        .setPrefetchCount(10)
                        .setPrefetchValidityMillis(MINUTES.toMillis(10)));
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);

        FlakeIdGenerator idGenerator = client.getFlakeIdGenerator("idGenerator");
        for (int i = 0; i &lt; 10000; i++) {
            sleepSeconds(1);
            System.out.printf("Id: %s\n", idGenerator.newId());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="node-id-assignment"><a class="anchor" href="#node-id-assignment"></a>Node ID Assignment</h3>
<div class="paragraph">
<p>Flake IDs require a unique node ID to be assigned to each member, from which point the
member can generate unique IDs without any coordination. Hazelcast uses the member list
version from the moment when the member joined the cluster as a unique node ID.</p>
</div>
<div class="paragraph">
<p>The join algorithm is specifically designed to ensure that member list join version is unique
for each member in the cluster. This ensures that IDs are unique even during network splits,
with one caveat: at most one member is allowed to join the cluster during a network split.
If two members join different subclusters, they are likely to get the same node ID. This is
resolved when the cluster heals, but until then, they can generate duplicate IDs.</p>
</div>
<div class="sect3">
<h4 id="node-id-overflow"><a class="anchor" href="#node-id-overflow"></a>Node ID Overflow</h4>
<div class="paragraph">
<p>Node ID component of the ID has 16 bits. Members with the member list join version higher
than 2^16 won&#8217;t be able to generate IDs, but functionality is preserved by forwarding to another member.
It is possible to generate IDs on any member or client as long as there is at least one
member with join version smaller than 2^16 in the cluster. The remedy is to restart the cluster:
the node ID component will be reset and assigned starting from zero again. Uniqueness after the
restart will be preserved thanks to the timestamp component.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_flake_id_generator"><a class="anchor" href="#_configuring_flake_id_generator"></a>Configuring Flake ID Generator</h3>
<div class="paragraph">
<p>Following is an example declarative configuration snippet:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;flake-id-generator name="default"&gt;
        &lt;prefetch-count&gt;100&lt;/prefetch-count&gt;
        &lt;prefetch-validity-millis&gt;600000&lt;/prefetch-validity-millis&gt;
        &lt;epoch-start&gt;1514764800000&lt;/epoch-start&gt;
        &lt;node-id-offset&gt;0&lt;/node-id-offset&gt;
        &lt;bits-sequence&gt;6&lt;/bits-sequence&gt;
        &lt;bits-node-id&gt;16&lt;/bits-node-id&gt;
        &lt;allowed-future-millis&gt;15000&lt;/allowed-future-millis&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
    &lt;/flake-id-generator&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  flake-id-generator:
    default:
      prefetch-count: 100
      prefetch-validity-millis: 600000
      epoch-start: 1514764800000
      node-id-offset: 0
      bits-sequence: 6
      bits-node-id: 16
      allowed-future-millis: 15000
      statistics-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the descriptions of configuration elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of your Flake ID Generator. It is a required attribute.</p>
</li>
<li>
<p><code>prefetch-count</code>: Count of IDs which are pre-fetched on the background
when one call to FlakeIdGenerator.newId() is made. Its value must be in the
range 1 -100,000. Its default value is 100. This setting pertains only to
<code>newId()</code> calls made on the member that configured it.</p>
</li>
<li>
<p><code>prefetch-validity-millis</code>: Specifies for how long the pre-fetched IDs can
be used. After this time elapses, a new batch of IDs are fetched. Time unit is
milliseconds. Its default value is 600,000 milliseconds (10 minutes). The IDs
contain a timestamp component, which ensures a rough global ordering of them.
If an ID is assigned to an object that was created later, it will be out of order.
If ordering is not important, set this value to 0. This setting pertains only to
<code>newId()</code> calls made on the member that configured it.</p>
</li>
<li>
<p><code>epoch-start</code>: Offset of the timestamp component. Time unit is
milliseconds, default is 1514764800000 (1.1.2018 0:00 UTC)</p>
</li>
<li>
<p><code>node-id-offset</code>: Specifies the offset that is added to the node ID assigned
to cluster member for this generator. Might be useful in A/B deployment scenarios
where you have cluster A which you want to upgrade. You create cluster B and
for some time both will generate IDs and you want to have them unique.
In this case, configure node ID offset for generators on cluster B.</p>
</li>
<li>
<p><code>bits-sequence</code>: Bit-length of the sequence component. Default value is 6 bits.</p>
</li>
<li>
<p><code>bits-node-id</code>: Bit-length of node id component. Default value is 16 bits.</p>
</li>
<li>
<p><code>allowed-future-millis</code>: Sets how far to the future is the generator allowed to
generate IDs without blocking. Default is 15 seconds.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled
for your Flake ID Generator. If set to <code>false</code>, you cannot collect statistics
in your implementation (using <code>getLocalFlakeIdGeneratorStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-flake-id-generators" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="replicated-map"><a class="anchor" href="#replicated-map"></a>Replicated Map</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A Replicated Map is a distributed key-value data structure where
the data is replicated to all members in the cluster.
It provides full replication of entries to all members for high speed access.</p>
</div>
<div class="paragraph">
<p>The following are the features of Replicated Map:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When you have a Replicated Map in the  cluster, your clients
can communicate with any cluster member.</p>
</li>
<li>
<p>All cluster members are able to perform write operations.</p>
</li>
<li>
<p>It supports all methods of the interface <code>java.util.Map</code>.</p>
</li>
<li>
<p>It supports automatic initial fill up when a new member is started.</p>
</li>
<li>
<p>It provides statistics for entry access, write and update so that
you can monitor it using Hazelcast Management Center.</p>
</li>
<li>
<p>New members joining to the cluster pull all the data from the existing members.</p>
</li>
<li>
<p>You can listen to entry events using listeners. See the
<a href="#using-entrylistener-on-replicated-map">Using EntryListener on Replicated Map section</a>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="replicating-instead-of-partitioning"><a class="anchor" href="#replicating-instead-of-partitioning"></a>Replicating Instead of Partitioning</h3>
<div class="paragraph">
<p>A Replicated Map does not partition data
(it does not spread data to different cluster members); instead,
it replicates the data to all members.</p>
</div>
<div class="paragraph">
<p>Replication leads to higher memory consumption.
However, a Replicated Map has faster read and write access since
the data is available on all members.</p>
</div>
<div class="paragraph">
<p>Writes could take place on local/remote members in order to provide write-order,
eventually being replicated to all other members.</p>
</div>
<div class="paragraph">
<p>Replicated Map is suitable for objects, catalog data, or idempotent calculable data
(such as HTML pages). It fully implements the <code>java.util.Map</code> interface,
but it lacks the methods from <code>java.util.concurrent.ConcurrentMap</code> since
there are no atomic guarantees to writes or reads.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If Replicated Map is used from a unisocket client and this
unisocket client is connected to a lite member, the entry listeners cannot be registered/de-registered.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
You cannot use Replicated Map from a lite member.
A <code>com.hazelcast.replicatedmap.ReplicatedMapCantBeCreatedOnLiteMemberException</code>
is thrown if <code>com.hazelcast.core.HazelcastInstance.getReplicatedMap(name)</code>
is invoked on a lite member.
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="example-replicated-map-code"><a class="anchor" href="#example-replicated-map-code"></a>Example Replicated Map Code</h3>
<div class="paragraph">
<p>Here is an example of Replicated Map code. The HazelcastInstance&#8217;s
<code>getReplicatedMap</code> method gets the Replicated Map, and the Replicated Map&#8217;s
<code>put</code> method creates map entries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        Map&lt;String, String&gt; map = hz.getReplicatedMap("map");

        map.put("1", "Tokyo");
        map.put("2", "Paris");
        map.put("3", "New York");

        System.out.println("Finished loading map");
        hz.shutdown();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HazelcastInstance.getReplicatedMap()</code> returns
<code>com.hazelcast.core.ReplicatedMap</code> which, as stated above, extends the
<code>java.util.Map</code> interface.</p>
</div>
<div class="paragraph">
<p>The <code>com.hazelcast.core.ReplicatedMap</code> interface has some
additional methods for registering entry listeners or retrieving
values in an expected order.</p>
</div>
</div>
<div class="sect2">
<h3 id="considerations-for-replicated-map"><a class="anchor" href="#considerations-for-replicated-map"></a>Considerations for Replicated Map</h3>
<div class="paragraph">
<p>If you have a large cluster or very high occurrences of updates,
the Replicated Map may not scale linearly as expected since
it has to replicate update operations to all members in the cluster.</p>
</div>
<div class="paragraph">
<p>Since the replication of updates is performed in an asynchronous manner,
we recommend you enable back pressure in case your system has high occurrences
of updates. See the <a href="#back-pressure">Back Pressure section</a> to learn how to enable it.</p>
</div>
<div class="paragraph">
<p>Replicated Map has an anti-entropy system that converges values to a
common one if some of the members are missing replication updates.</p>
</div>
<div class="paragraph">
<p>Replicated Map does not guarantee eventual consistency because there are
some edge cases that fail to provide consistency.</p>
</div>
<div class="paragraph">
<p>Replicated Map uses the internal partition system of Hazelcast in order to
serialize updates happening on the same key at the same time. This happens
by sending updates of the same key to the same Hazelcast member in the cluster.</p>
</div>
<div class="paragraph">
<p>Due to the asynchronous nature of replication, a Hazelcast member could
die before successfully replicating a "write" operation to other members
after sending the "write completed" response to its caller during the write process.
In this scenario, Hazelcast&#8217;s internal partition system promotes one of the replicas
of the partition as the primary one. The new primary partition does not have
the latest "write" since the dead member could not successfully replicate the update.
(This leaves the system in a state that the caller is the only one that has the
update and the rest of the cluster have not.) In this case even the anti-entropy
system simply could not converge the value since the source of true information
is lost for the update. This leads to a break in the eventual consistency
because different values can be read from the system for the same key.</p>
</div>
<div class="paragraph">
<p>Other than the aforementioned scenario, the Replicated Map behaves
like an eventually consistent system with read-your-writes and monotonic-reads consistency.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuration-design-for-replicated-map"><a class="anchor" href="#configuration-design-for-replicated-map"></a>Configuration Design for Replicated Map</h3>
<div class="paragraph">
<p>There are several technical design decisions you should consider when you configure a Replicated Map.</p>
</div>
<div class="paragraph">
<p><strong>Initial Provisioning</strong></p>
</div>
<div class="paragraph">
<p>If a new member joins the cluster, there are two ways you can handle
the initial provisioning that is executed to replicate all existing
values to the new member. Each involves how you configure the async fill up.</p>
</div>
<div class="paragraph">
<p>First, you can configure async fill up to true, which does not block
reads while the fill up operation is underway. That way,
you have immediate access on the new member, but it will take time until
all the values are eventually accessible. Not yet
replicated values are returned as non-existing (null).</p>
</div>
<div class="paragraph">
<p>Second, you can configure for a synchronous initial fill up (by configuring
the async fill up to false), which blocks every read or write access to the map until the
fill up operation is finished. Use this with caution since it might block your
application from operating.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-replicated-map"><a class="anchor" href="#configuring-replicated-map"></a>Configuring Replicated Map</h3>
<div class="paragraph">
<p>Replicated Map can be configured programmatically or declaratively.</p>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="paragraph">
<p>You can declare your Replicated Map configuration in the Hazelcast configuration
file <code>hazelcast.xml</code>. See the following example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;replicatedmap name="default"&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;async-fillup&gt;true&lt;/async-fillup&gt;
        &lt;statistics-enabled&gt;true&lt;/statistics-enabled&gt;
        &lt;entry-listeners&gt;
            &lt;entry-listener include-value="true"&gt;
                com.hazelcast.examples.EntryListener
            &lt;/entry-listener&gt;
       &lt;/entry-listeners&gt;
       &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/replicatedmap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  replicatedmap:
    default:
      in-memory-format: BINARY
      async-fillup: true
      statistics-enabled: true
      entry-listeners:
        - class-name: com.hazelcast.examples.EntryListener
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>Replicated Map has the following configuration elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>in-memory-format</code>: Internal storage format.  See the
<a href="#in-memory-format-on-replicated-map">In-Memory Format section</a>. Its default value is <code>OBJECT</code>.</p>
</li>
<li>
<p><code>async-fillup</code>: Specifies whether the Replicated Map is available
for reads before the initial replication is completed. Its default value is <code>true</code>.
If set to <code>false</code>, i.e., synchronous initial fill up, no exception is thrown when
the Replicated Map is not yet ready, but <code>null</code> values can be seen until the initial
replication is completed.</p>
</li>
<li>
<p><code>statistics-enabled</code>: Specifies whether the statistics gathering is enabled
for your Replicated Map. If set to <code>false</code>, you cannot collect statistics in your
implementation (using <code>getLocalReplicatedMapStats()</code>) and also
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-replicated-maps" target="_blank" rel="noopener">Hazelcast Management Center</a>
will not show them. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>entry-listener</code>: Full canonical classname of the <code>EntryListener</code> implementation.</p>
<div class="ulist">
<ul>
<li>
<p><code>entry-listener#include-value</code>: Specifies whether the event includes the value or not.
Sometimes the key is enough to react on an event. In those situations, setting this value
to <code>false</code> saves a deserialization cycle. Its default value is <code>true</code>.</p>
</li>
<li>
<p><code>entry-listener#local</code>: Not used for Replicated Map since listeners are always local.</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>split-brain-protection-ref</code>: Name of quorum configuration that you want this Replicated Map to use.
See the <a href="#split-brain-protection-for-replicated-map">Split-Brain Protection for Replicated Map section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="paragraph">
<p>You can configure a Replicated Map programmatically, as you can do for all other
data structures in Hazelcast. You must create the configuration upfront, when you
instantiate the <code>HazelcastInstance</code>.
A basic example of how to configure the Replicated Map using the programmatic approach
is shown in the following snippet.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();

        ReplicatedMapConfig replicatedMapConfig =
                config.getReplicatedMapConfig( "default" );

        replicatedMapConfig.setInMemoryFormat( InMemoryFormat.BINARY )
                .setSplitBrainProtectionName( "splitbrainprotectionname" );</code></pre>
</div>
</div>
<div class="paragraph">
<p>All properties that can be configured using the declarative configuration
are also available using programmatic configuration
by transforming the tag names into getter or setter names.</p>
</div>
<div class="sect3">
<h4 id="in-memory-format-on-replicated-map"><a class="anchor" href="#in-memory-format-on-replicated-map"></a>In-Memory Format on Replicated Map</h4>
<div class="paragraph">
<p>Currently, you can use the following <code>in-memory-format</code> options with the Replicated Map:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>OBJECT</code> (default): The data is stored in deserialized form.
This configuration is the default choice since
the data replication is mostly used for high speed access. Please
be aware that changing the values without a <code>Map.put()</code> is
not reflected on the other members but is visible on the changing members
for later value accesses.</p>
</li>
<li>
<p><code>BINARY</code>: The data is stored in serialized binary format and has to be
deserialized on every request. This
option offers higher encapsulation since changes to values are always
discarded as long as the newly changed object is
not explicitly <code>Map.put()</code> into the map again.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-entrylistener-on-replicated-map"><a class="anchor" href="#using-entrylistener-on-replicated-map"></a>Using EntryListener on Replicated Map</h3>
<div class="paragraph">
<p>A <code>com.hazelcast.core.EntryListener</code> used on a Replicated Map serves
the same purpose as it would on other
data structures in Hazelcast. You can use it to react on add, update
and remove operations. Replicated Maps do not yet support eviction.</p>
</div>
<div class="sect3">
<h4 id="difference-in-entrylistener-on-replicated-map"><a class="anchor" href="#difference-in-entrylistener-on-replicated-map"></a>Difference in EntryListener on Replicated Map</h4>
<div class="paragraph">
<p>The fundamental difference in Replicated Map behavior, compared to the
other data structures, is that an EntryListener only reflects
changes on local data. Since replication is asynchronous, all listener
events are fired only when an operation is finished
on a local member. Events can fire at different times on different members.</p>
</div>
</div>
<div class="sect3">
<h4 id="example-of-replicated-map-entrylistener"><a class="anchor" href="#example-of-replicated-map-entrylistener"></a>Example of Replicated Map EntryListener</h4>
<div class="paragraph">
<p>Here is a code example for using EntryListener on a Replicated Map.</p>
</div>
<div class="paragraph">
<p>The <code>HazelcastInstance</code> s <code>getReplicatedMap</code> method gets a
Replicated Map (customers), and the <code>ReplicatedMap</code> s <code>addEntryListener</code>
method adds an entry listener to the Replicated Map. Then, the <code>ReplicatedMap</code> s <code>put</code>
method adds a Replicated Map
entry and updates it. The method <code>remove</code> removes the entry.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        ReplicatedMap&lt;String, String&gt; map = hz.getReplicatedMap("somemap");
        map.addEntryListener(new MyEntryListener());
        System.out.println("EntryListener registered");
    }

    private static class MyEntryListener implements EntryListener&lt;String, String&gt; {

        @Override
        public void entryAdded(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryAdded: " + event);
        }

        @Override
        public void entryRemoved(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryRemoved: " + event);
        }

        @Override
        public void entryUpdated(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryUpdated: " + event);
        }

        @Override
        public void entryEvicted(EntryEvent&lt;String, String&gt; event) {
            System.out.println("entryEvicted: " + event);
        }
        @Override
        public void entryExpired(EntryEvent&lt;String, String&gt; event) {
            System.out.println( "Entry expired: " + event );
        }
        @Override
        public void mapEvicted(MapEvent event) {
            System.out.println("mapEvicted:" + event);

        }

        @Override
        public void mapCleared(MapEvent event) {
            System.out.println("mapCleared: " + event);
        }</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="split-brain-protection-for-replicated-map"><a class="anchor" href="#split-brain-protection-for-replicated-map"></a>Split-Brain Protection for Replicated Map</h3>
<div class="paragraph">
<p>Replicated Map can be configured to check for a minimum number of available
members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>).
This is a check to avoid performing successful queue operations on all parts of a
cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support split-brain
protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>clear</code></p>
</li>
<li>
<p><code>put</code></p>
</li>
<li>
<p><code>putAll</code></p>
</li>
<li>
<p><code>remove</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>containsKey</code></p>
</li>
<li>
<p><code>containsValue</code></p>
</li>
<li>
<p><code>entrySet</code></p>
</li>
<li>
<p><code>get</code></p>
</li>
<li>
<p><code>isEmpty</code></p>
</li>
<li>
<p><code>keySet</code></p>
</li>
<li>
<p><code>size</code></p>
</li>
<li>
<p><code>values</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Replicated Map can be configured programmatically
using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/ReplicatedMapConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>. Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;replicatedmap name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/replicatedmap&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  replicatedmap:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name which you
configured under the <code>split-brain-protection</code> element as explained in the <a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="cardinality-estimator"><a class="anchor" href="#cardinality-estimator"></a>Cardinality Estimator Service</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast&#8217;s cardinality estimator service is a data structure which implements
Flajolet&#8217;s HyperLogLog algorithm for estimating cardinalities of unique objects in theoretically huge data sets.
The implementation offered by Hazelcast includes improvements from Google&#8217;s
version of the algorithm, i.e., HyperLogLog++.</p>
</div>
<div class="paragraph">
<p>The cardinality estimator service does not provide any ways to configure
its properties, but rather uses some well tested defaults:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>P</code>: Stands for precision with a default value of 14
(using the 14 LSB of the hash for the index)</p>
</li>
<li>
<p><code>M</code>: 2 ^ P = 16384 (16K) registers</p>
</li>
<li>
<p><code>P'</code>: Stands for sparse precision with a default value of 25</p>
</li>
<li>
<p><code>Durability</code>: Count of backups for each estimator with a default value of 2</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is important to understand that this data structure is not
100% accurate, it is used to provide estimates. The error rate is typically
a result of <code>1.04/sqrt(M)</code> which in our implementation is around 0.81% for high percentiles.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The memory consumption of this data structure is close to 16K despite the
size of elements in the source data set or stream.</p>
</div>
<div class="paragraph">
<p>There are two phases in using the cardinality estimator.</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Add objects to the instance of the estimator, e.g., for IPs <code>estimator.add("0.0.0.0.")</code>.
The provided object is first serialized and then the byte array is used to
generate a hash for that object.</p>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Objects must be serializable in a form that Hazelcast understands.
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Compute the estimate of the set so far <code>estimator.estimate()</code>.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/cardinality/CardinalityEstimator.html" target="_blank" rel="noopener">cardinality estimator Javadoc</a>
for more information on its API.</p>
</div>
<div class="paragraph">
<p>The following is an example code.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        HazelcastInstance hz = Hazelcast.newHazelcastInstance();
        CardinalityEstimator visitorsEstimator = hz.getCardinalityEstimator("visitors");

        InputStreamReader isr = new InputStreamReader(ExampleCardinalityEstimator.class.getResourceAsStream("visitors.txt"));
        BufferedReader br = new BufferedReader(isr);
        try {
            String visitor = br.readLine();
            while (visitor != null) {
                visitorsEstimator.add(visitor);
                visitor = br.readLine();
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            closeResource(br);
            closeResource(isr);
        }

        System.out.printf("Estimated unique visitors seen so far: %d%n", visitorsEstimator.estimate());

        Hazelcast.shutdownAll();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="split-brain-protection-for-cardinality-estimator"><a class="anchor" href="#split-brain-protection-for-cardinality-estimator"></a>Split-Brain Protection for Cardinality Estimator</h3>
<div class="paragraph">
<p>Cardinality Estimator can be configured to check for a minimum number of
available members before applying its operations (see the <a href="#split-brain-protection">Split-Brain Protection section</a>). This is a check to avoid performing successful queue
operations on all parts of a cluster during a network partition.</p>
</div>
<div class="paragraph">
<p>The following is a list of methods, grouped by the protection types, that support
split-brain protection checks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>WRITE, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>add</code></p>
</li>
<li>
<p><code>addAsync</code></p>
</li>
</ul>
</div>
</li>
<li>
<p>READ, READ_WRITE:</p>
<div class="ulist">
<ul>
<li>
<p><code>estimate</code></p>
</li>
<li>
<p><code>estimateAsync</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Configuring Split-Brain Protection</strong></p>
</div>
<div class="paragraph">
<p>Split-brain protection for Cardinality Estimator can be configured
programmatically using the method <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/CardinalityEstimatorConfig.html" target="_blank" rel="noopener">setSplitBrainProtectionName()</a>,
or declaratively using the element <code>split-brain-protection-ref</code>.
Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cardinality-estimator name="default"&gt;
        &lt;split-brain-protection-ref&gt;splitbrainprotection-name&lt;/split-brain-protection-ref&gt;
    &lt;/cardinality-estimator&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cardinality-estimator:
    default:
      split-brain-protection-ref: splitbrainprotection-name</code></pre>
</div>
</div>
<div class="paragraph">
<p>The value of <code>split-brain-protection-ref</code> should be the split-brain protection configuration name
which you configured under the <code>split-brain-protection</code> element as explained in the
<a href="#split-brain-protection">Split-Brain Protection section</a>.</p>
</div>
<div class="paragraph">
<p><strong>Configuring Merge Policy</strong></p>
</div>
<div class="paragraph">
<p>While recovering from a split-brain syndrome, Cardinality Estimator
in the small cluster merges into the bigger cluster based on a configured
merge policy. When an estimator merges into the cluster, an estimator with
the same name might already exist in the cluster.
So the merge policy resolves these kinds of conflicts with different out-of-the-box strategies.
It can be configured programmatically using the method
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/CardinalityEstimatorConfig.html" target="_blank" rel="noopener">setMergePolicyConfig()</a>,
or declaratively using the element <code>merge-policy</code>.
Following is an example declarative configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cardinality-estimator name="default"&gt;
        &lt;merge-policy batch-size="102"&gt;HyperLogLogMergePolicy&lt;/merge-policy&gt;
    &lt;/cardinality-estimator&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cardinality-estimator:
      merge-policy:
        batch-size: 102
        class-name: HyperLogLogMergePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following out-of-the-box merge policies are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DiscardMergePolicy</code>: Estimator from the smaller cluster is discarded.</p>
</li>
<li>
<p><code>HyperLogLogMergePolicy</code>: Estimator merges with the existing one,
using the algorithmic merge for HyperLogLog. This is the default policy.</p>
</li>
<li>
<p><code>PassThroughMergePolicy</code>: Estimator from the smaller cluster wins.</p>
</li>
<li>
<p><code>PutIfAbsentMergePolicy</code>: Estimator from the smaller cluster wins if it doesn&#8217;t exist in the cluster.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="event-journal"><a class="anchor" href="#event-journal"></a>Event Journal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The event journal is a distributed data structure that stores the history
of mutation actions on map or cache. Each action on the map or cache which
modifies its contents (such as <code>put</code>, <code>remove</code> or scheduled tasks which are
not triggered by using the public API) creates an event which is stored in
the event journal. The event stores the event type as well as the key, old
value and updated value for the entry (when applicable). As a user, you can
only append to the journal indirectly by using the map and cache methods or
configuring the expiration and eviction.  By reading from the event journal
you can recreate the state of the map or cache at any point in time.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently the event journal does not expose a public API for reading the
event journal in Hazelcast IMDG. The event journal can be used to stream event
data to Hazelcast Jet, so it should be used in conjunction with
<a href="http://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a>. Because of this we describe
how to configure it but not how to use it from IMDG in this section. If you
enable and configure the event journal, you may only reach it through private
API and you most probably do not get any benefits but the journal retains events
nevertheless and consumes heap space.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The event journal has a fixed capacity and an expiration time. Internally it is
structured as a ringbuffer (partitioned by ringbuffer item) and shares many
similarities with it.</p>
</div>
<div class="sect2">
<h3 id="interaction-with-evictions-and-expiration-for-imap"><a class="anchor" href="#interaction-with-evictions-and-expiration-for-imap"></a>Interaction with Evictions and Expiration for IMap</h3>
<div class="paragraph">
<p>Configuring IMap with eviction and expiration can cause the event journal to
contain different events on the different replicas of the same partition. You
can run into issues if you are reading from the event journal and the partition
owner is terminated. A backup replica is then promoted into the partition owner
but the event journal will contain different events. The event count should stay
the same but the entries which you previously thought were evicted and expired
could now be "alive" and vice versa.</p>
</div>
<div class="paragraph">
<p>This is because eviction and expiration randomly choose entries to be
evicted/expired. The entry is not coordinated between partition replicas.
In these cases, the event journal diverges and will not converge at any
future point, but will remain inconsistent just as well as the contents
of the internal record stores are inconsistent between replicas. You may
say that the event journal on a specific replica is in-sync with the record
store on that replica but the event journals and record stores between
replicas are out-of-sync.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-event-journal-capacity"><a class="anchor" href="#configuring-event-journal-capacity"></a>Configuring Event Journal Capacity</h3>
<div class="paragraph">
<p>By default, an event journal is configured with a <code>capacity</code> of 10000 items.
This creates a single array per partition, roughly the size of the capacity
divided by the number of partitions. Thus, if the configured capacity is
10000 and number of partitions is 271, we create 271 arrays of size 36
(10000/271). If
a <code>time-to-live</code> is configured, then an array of longs is also created
that stores the expiration time for every item.
A single array of the event journal keeps events that are only related
to the map entries in that partition. In a lot of cases you may want to
change this <code>capacity</code> number to something that better fits your needs.
As the capacity is shared between partitions, keep in mind not to set it
to a value which is too low for you. Setting the capacity to a number
lower than the partition count results in an error when initializing the
event journal.</p>
</div>
<div class="paragraph">
<p>Below is a declarative configuration example of an event journal with a
<code>capacity</code> of 5000 items for a map and 10000 items for a cache:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="default"&gt;
        &lt;event-journal enabled="true"&gt;
            &lt;capacity&gt;5000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;20&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/map&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;event-journal enabled="true"&gt;
            &lt;capacity&gt;10000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;0&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    default:
      event-journal:
        enabled: true
        capacity: 5000
        time-to-live-seconds: 20
  cache:
    default:
      event-journal:
        enabled: true
        capacity: 10000
        time-to-live-seconds: 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure an event journal programmatically. The following
is a programmatic version of the above declarative configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        EventJournalConfig eventJournalMapConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(5000)
                .setTimeToLiveSeconds(20);

        EventJournalConfig eventJournalCacheConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(10000)
                .setTimeToLiveSeconds(0);

        Config config = new Config();
        config.getMapConfig("myMap").setEventJournalConfig(eventJournalMapConfig);
        config.getCacheConfig("myCache").setEventJournalConfig(eventJournalCacheConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>mapName</code> and <code>cacheName</code> attributes define the map or cache to which
this event journal configuration applies. You can use pattern-matching and
the <code>default</code> keyword when doing so. For instance, by using a <code>mapName</code> of
<code>journaled*</code>, the journal configuration applies to all maps whose names start
with "journaled" and don&#8217;t have other journal configurations that match (e.g.,
if you would have a more specific journal configuration with an exact name match).
If you specify the <code>mapName</code> or <code>cacheName</code> as <code>default</code>, the journal configuration
applies to all maps and caches that don&#8217;t have any other journal configuration.
This means that potentially all maps and/or caches have one single
event journal configuration.</p>
</div>
</div>
<div class="sect2">
<h3 id="event-journal-partitioning"><a class="anchor" href="#event-journal-partitioning"></a>Event Journal Partitioning</h3>
<div class="paragraph">
<p>The event journal is a partitioned data structure. The partitioning
is done by the event key. Because of this, the map and cache entry
with a specific key is co-located with the events for that key and
will be migrated accordingly.
Also, the backup count for the event journal is equal to the backup
count of the map or cache for which it contains events. The events on
the backup replicas will be created with the map or cache backup operations
and no additional network traffic is introduced when appending events
to the event journal.</p>
</div>
</div>
<div class="sect2">
<h3 id="configuring-event-journal-ttl"><a class="anchor" href="#configuring-event-journal-ttl"></a>Configuring Event Journal time-to-live</h3>
<div class="paragraph">
<p>You can configure Hazelcast event journal with a <code>time-to-live</code> in seconds.
Using this setting, you can control how long the items remain in
the event journal before they are expired. By default, the <code>time-to-live</code>
is set to 0, meaning that unless the item is overwritten,
it remains in the journal indefinitely. The expiration time of the existing
journal events is checked whenever a new event is appended to the event
journal or when the event journal is being read. If the journal is not
being read from or written to, the journal may keep expired items indefinitely.</p>
</div>
<div class="paragraph">
<p>In the example below, an event journal is configured with a <code>time-to-live</code> of 180 seconds:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="myCache"&gt;
        &lt;event-journal enabled="true"&gt;
            &lt;capacity&gt;10000&lt;/capacity&gt;
            &lt;time-to-live-seconds&gt;180&lt;/time-to-live-seconds&gt;
        &lt;/event-journal&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    myCache:
      event-journal:
        enabled: true
        capacity: 10000
        time-to-live-seconds: 180</code></pre>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/reference/dds.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
