<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Hazelcast JCache Hazelcast Documentation</title>
    <link rel="canonical" href="https://JakeSCahill.github.io/hazelcast/4.1/develop/jcache.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://JakeSCahill.github.io">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Use cases</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">GitHub</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../deploy/installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/wan.html">WAN Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../deploy/network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference/faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../home/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../home/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../hazelcast_overview.html">Hazelcast IMDG</a></li>
    <li><a href="hazelcast_clients.html">Develop Solutions</a></li>
    <li><a href="jcache.html">JCache</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a class="git" href="file:///C:/Users/Jake%20Cahill/Documents/code-playground/docs/hazelcast-docs/modules/develop/pages/jcache.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">Hazelcast JCache</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the basics of JCache, the standardized Java caching layer API. The JCache
caching API is specified by the Java Community Process (JCP) as Java Specification Request (JSR) 107.</p>
</div>
<div class="paragraph">
<p>Caching keeps data in memory that either are slow to calculate/process or originate from another underlying backend system.
Caching is used to prevent additional request round trips for frequently used data. In both cases, caching can be used to
gain performance or decrease application latencies.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_jcache_overview"><a class="anchor" href="#_jcache_overview"></a>JCache Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast offers a specification-compliant JCache implementation.
To show our commitment to this
important specification that the Java world was waiting for
over a decade, we did not just provide a simple wrapper around our existing
APIs; we implemented a caching structure from the ground up
to optimize the behavior to the needs of JCache.
The Hazelcast JCache implementation is 100% TCK (Technology
Compatibility Kit) compliant and therefore passes all specification
requirements.</p>
</div>
<div class="paragraph">
<p>In addition to the given specification, we added some
features like asynchronous versions of almost all
operations to give the user extra power.</p>
</div>
<div class="paragraph">
<p>This chapter gives a basic understanding of how to
configure your application and how to setup Hazelcast
to be your JCache
provider. It also shows examples of basic JCache usage
as well as the additionally offered features that are
not part of JSR-107.
To gain a full understanding of the JCache functionality
and provided guarantees of different operations, read
the specification document (which is also the main
documentation for functionality) at the specification
page of <a href="https://www.jcp.org/en/jsr/detail?id=107" target="_blank" rel="noopener">JSR-107</a>.</p>
</div>
<div class="sect2">
<h3 id="_supported_jcache_versions"><a class="anchor" href="#_supported_jcache_versions"></a>Supported JCache Versions</h3>
<div class="paragraph">
<p>The following versions of the JCache specification
have been released:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The original release, version 1.0.0, was released
in March 2014. Hazelcast versions 3.3.1 up to 3.9.2
(included) implement version 1.0.0 of the JCache specification.</p>
</li>
<li>
<p>A maintenance release, version 1.1.0 was released
in December 2017. Hazelcast version 3.9.3 and higher
implement JCache specification version 1.1.0.</p>
</li>
<li>
<p>A patch release, version 1.1.1 was released in
May 2019. Hazelcast version 3.12.1 and higher implement JCache 1.1.1.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>JCache 1.1.x versions are backwards compatible with
JCache 1.0.0. As maintenance releases, JCache 1.1.x versions
introduce clarifications and bug fixes in the specification, reference implementation
and TCK, without introducing any additional features.</p>
</div>
</div>
<div class="sect2">
<h3 id="jcache-111"><a class="anchor" href="#jcache-111"></a>Upgrading from JCache 1.1.0 to 1.1.1</h3>
<div class="paragraph">
<p>JCache 1.1.1 is a bug-fix-only release. There are no
behavioral differences between the JCache 1.1.0 and 1.1.1 specifications.</p>
</div>
</div>
<div class="sect2">
<h3 id="_upgrading_from_jcache_1_0_0_to_1_1_0"><a class="anchor" href="#_upgrading_from_jcache_1_0_0_to_1_1_0"></a>Upgrading from JCache 1.0.0 to 1.1.0</h3>
<div class="paragraph">
<p>When upgrading from a Hazelcast version which implements
JCache 1.0.0 to a version that implements version 1.1.0
of the specification, some behavioral differences must be taken into account:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invoking <code>CacheManager.getCacheNames</code> on a closed
<code>CacheManager</code> returns an empty iterator under JCache 1.0.0.
While under JCache 1.1.0, it throws <code>IllegalStateException</code>.</p>
</li>
<li>
<p>Runtime type checking is removed from <code>CacheManager.getCache(String)</code>,
so when using JCache 1.1.0 one may obtain a <code>Cache</code> by name
even when its configured key/value types are not known.</p>
</li>
<li>
<p>Statistics effects of <code>Cache.putIfAbsent</code> on misses and
hits are properly applied when using JCache 1.1.0, while
under JCache 1.0.0 misses and hits were not updated.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that these behavioral differences apply on the Hazelcast
member that executes the operation. Thus when performing a
rolling member upgrade from a JCache 1.0.0-compliant Hazelcast
version to a newer Hazelcast version that supports JCache 1.1.0,
operations executed on the new members exhibit JCache 1.1.0
behavior while those executed on old members implement
JCache 1.0.0 behavior.</p>
</div>
<div class="paragraph">
<p>The complete list of issues addressed in JCache specification
version 1.1.0 is <a href="https://github.com/jsr107/jsr107spec/milestone/2?closed=1" target="_blank" rel="noopener">available on Github</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_jcache_setup_and_configuration"><a class="anchor" href="#_jcache_setup_and_configuration"></a>JCache Setup and Configuration</h3>
<div class="paragraph">
<p>This section shows what is necessary to provide
the JCache API and the Hazelcast JCache implementation
for your application. In addition, it demonstrates the
different configuration options and describes the
configuration properties.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_your_application"><a class="anchor" href="#_setting_up_your_application"></a>Setting up Your Application</h4>
<div class="paragraph">
<p>To provide your application with this JCache functionality,
your application needs the JCache API inside its classpath.
This API is the bridge between the specified JCache standard
and the implementation provided by Hazelcast.</p>
</div>
<div class="paragraph">
<p>The method of integrating the JCache API JAR into the
application classpath depends on the build system used.
For Maven, Gradle, SBT,
Ivy and many other build systems, all using Maven-based
dependency repositories, perform the integration by adding
the Maven coordinates to the build descriptor.</p>
</div>
<div class="paragraph">
<p>As already mentioned, you have to add JCache
coordinates next to the default Hazelcast coordinates
that might be already part of the application.</p>
</div>
<div class="paragraph">
<p>For Maven users, the coordinates look like the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.cache&lt;/groupId&gt;
    &lt;artifactId&gt;cache-api&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>With other build systems, you might need to describe
the coordinates in a different way.</p>
</div>
<div class="sect4">
<h5 id="_activating_hazelcast_as_jcache_provider"><a class="anchor" href="#_activating_hazelcast_as_jcache_provider"></a>Activating Hazelcast as JCache Provider</h5>
<div class="paragraph">
<p>To activate Hazelcast as the JCache provider implementation,
add either <code>hazelcast-all.jar</code> or
<code>hazelcast.jar</code> to the classpath (if not already available)
by either one of the following Maven snippets.</p>
</div>
<div class="paragraph">
<p>If you use <code>hazelcast-all.jar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast-all&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you use <code>hazelcast.jar</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The users of other build systems have to adjust the
definition of the dependency to their needs.</p>
</div>
</div>
<div class="sect4">
<h5 id="_connecting_clients_to_remote_member"><a class="anchor" href="#_connecting_clients_to_remote_member"></a>Connecting Clients to Remote Member</h5>
<div class="paragraph">
<p>When you want to use Hazelcast clients to connect to
a remote cluster, you do not need to perform any additional
steps; having <code>hazelcast</code> as a dependency does the work since
it contains the client libraries, too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
    &lt;groupId&gt;com.hazelcast&lt;/groupId&gt;
    &lt;artifactId&gt;hazelcast&lt;/artifactId&gt;
    &lt;version&gt;4.1&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For other build systems, for instance, ANT, the users
have to download these dependencies from either the JSR-107
specification and
Hazelcast community website (<a href="https://hazelcast.org/" target="_blank" rel="noopener">hazelcast.org</a>)
or from the Maven repository search page
(<a href="http://search.maven.org" target="_blank" rel="noopener">maven.org</a>).</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example_jcache_application"><a class="anchor" href="#_example_jcache_application"></a>Example JCache Application</h4>
<div class="paragraph">
<p>Before moving on to configuration, let&#8217;s have a look at a
basic introductory example. The following code shows how to
use the Hazelcast JCache integration
inside an application in an easy but typesafe way.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        // Retrieve the CachingProvider which is automatically backed by
        // the chosen Hazelcast member or client provider.
        CachingProvider cachingProvider = Caching.getCachingProvider();

        // Create a CacheManager.
        CacheManager cacheManager = cachingProvider.getCacheManager();

        // Create a simple but typesafe configuration for the cache.
        CompleteConfiguration&lt;String, String&gt; config =
                new MutableConfiguration&lt;String, String&gt;()
                        .setTypes( String.class, String.class );

        // Create and get the cache.
        Cache&lt;String, String&gt; cache = cacheManager.createCache( "example", config );
        // Alternatively to request an already existing cache:
        // Cache&lt;String, String&gt; cache = cacheManager
        //     .getCache( name, String.class, String.class );

        // Put a value into the cache.
        cache.put( "world", "Hello World" );

        // Retrieve the value again from the cache.
        String value = cache.get( "world" );

        // Print the value 'Hello World'.
        System.out.println( value );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Although the example is simple, let&#8217;s go through the code
lines one by one.</p>
</div>
<div class="sect4">
<h5 id="_getting_the_hazelcast_jcache_implementation"><a class="anchor" href="#_getting_the_hazelcast_jcache_implementation"></a>Getting the Hazelcast JCache Implementation</h5>
<div class="paragraph">
<p>First of all, we retrieve the <code>javax.cache.spi.CachingProvider</code>
using the static method from
<code>javax.cache.Caching.getCachingManager()</code>, which automatically
picks up Hazelcast as the underlying JCache implementation, if
available in the classpath. This way, the Hazelcast implementation
of a <code>CachingProvider</code> automatically starts a new Hazelcast
member or client (depending on the chosen provider type) and
pick up the configuration from either the command line parameter
or from the classpath. We will show how to use an existing
<code>HazelcastInstance</code> later in this chapter; for now, we keep
it simple.</p>
</div>
</div>
<div class="sect4">
<h5 id="_setting_up_the_jcache_entry_point"><a class="anchor" href="#_setting_up_the_jcache_entry_point"></a>Setting up the JCache Entry Point</h5>
<div class="paragraph">
<p>In the next line, we ask the <code>CachingProvider</code> to return a
<code>javax.cache.CacheManager</code>. This is the general application&#8217;s entry
point into JCache. The <code>CacheManager</code> creates and manages
named caches.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_the_cache_before_creating_it"><a class="anchor" href="#_configuring_the_cache_before_creating_it"></a>Configuring the Cache Before Creating It</h5>
<div class="paragraph">
<p>The next few lines create a simple
<code>javax.cache.configuration.MutableConfiguration</code> to configure
the cache before actually
creating it. In this case, we only configure the key and value
types to make the cache typesafe which is highly recommended and
checked on retrieval of the cache.</p>
</div>
</div>
<div class="sect4">
<h5 id="_creating_the_cache"><a class="anchor" href="#_creating_the_cache"></a>Creating the Cache</h5>
<div class="paragraph">
<p>To create the cache, we call <code>javax.cache.CacheManager.createCache()</code>
with a name for the cache and the previously created
configuration; the call returns the created cache. If you need to
retrieve a previously created cache, you can use the corresponding
method overload <code>javax.cache.CacheManager.getCache()</code>. If the cache
was created using type parameters, you must retrieve the cache
afterward using the type checking version of <code>getCache</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_get_put_and_getandput"><a class="anchor" href="#_get_put_and_getandput"></a>get, put and getAndPut</h5>
<div class="paragraph">
<p>The following lines are simple <code>put</code> and <code>get</code> calls from the
<code>java.util.Map</code> interface. The
<code>javax.cache.Cache.put()</code> has a <code>void</code> return type and does
not return the previously assigned value of the key. To imitate the
<code>java.util.Map.put()</code> method, the JCache cache has a method
called <code>getAndPut</code>.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_configuring_for_jcache"><a class="anchor" href="#_configuring_for_jcache"></a>Configuring for JCache</h4>
<div class="paragraph">
<p>Hazelcast JCache provides two different methods for cache configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>declaratively: using <code>hazelcast.xml</code> or <code>hazelcast-client.xml</code></p>
</li>
<li>
<p>programmatically: the typical Hazelcast way, using the Config API seen above</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="jcache-declarative-configuration"><a class="anchor" href="#jcache-declarative-configuration"></a>Declarative Configuration</h5>
<div class="paragraph">
<p>You can declare your JCache cache configuration using the
<code>hazelcast.xml</code> or <code>hazelcast-client.xml</code> configuration files.
Using this declarative configuration makes creating the <code>javax.cache.Cache</code>
fully transparent and automatically ensures internal thread safety.
You do not need a call to <code>javax.cache.Cache.createCache()</code> in this case:
you can retrieve the cache using
<code>javax.cache.Cache.getCache()</code> overloads and by passing in the name defined
in the configuration for the cache.</p>
</div>
<div class="paragraph">
<p>To retrieve the cache that you defined in the declaration files, you only need
to perform a simple call (example below) because the cache is
created automatically by the implementation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider cachingProvider = Caching.getCachingProvider();
CacheManager cacheManager = cachingProvider.getCacheManager();
Cache&lt;Object, Object&gt; cache = cacheManager
    .getCache( "default", Object.class, Object.class );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that this section only describes the JCache provided
standard properties. For the Hazelcast specific properties,
see the <a href="#icache-configuration">ICache Configuration section</a>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;key-type class-name="java.lang.Object" /&gt;
        &lt;value-type class-name="java.lang.Object" /&gt;
        &lt;statistics-enabled&gt;false&lt;/statistics-enabled&gt;
        &lt;management-enabled&gt;false&lt;/management-enabled&gt;
        &lt;read-through&gt;true&lt;/read-through&gt;
        &lt;write-through&gt;true&lt;/write-through&gt;
        &lt;cache-loader-factory
            class-name="com.example.cache.MyCacheLoaderFactory" /&gt;
        &lt;cache-writer-factory
            class-name="com.example.cache.MyCacheWriterFactory" /&gt;
        &lt;expiry-policy-factory
            class-name="com.example.cache.MyExpiryPolicyFactory" /&gt;
        &lt;cache-entry-listeners&gt;
            &lt;cache-entry-listener old-value-required="false" synchronous="false"&gt;
                &lt;cache-entry-listener-factory
                    class-name="com.example.cache.MyEntryListenerFactory" /&gt;
                &lt;cache-entry-event-filter-factory
                    class-name="com.example.cache.MyEntryEventFilterFactory" /&gt;
            &lt;/cache-entry-listener&gt;
        &lt;/cache-entry-listeners&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    default:
      key-type:
        class-name: java.lang.Object
      value-type:
        class-name: java.lang.Object
      statistics-enabled: false
      management-enabled: false
      read-through: true
      write-through: true
      cache-loader-factory:
        class-name: com.example.cache.MyCacheLoaderFactory
      cache-writer-factory:
        class-name: com.example.cache.MyCacheWriterFactory
      expiry-policy-factory:
        class-name: com.example.cache.MyExpirePolicyFactory
      cache-entry-listeners:
        cache-entry-listener:
          old-value-required: false
          synchronous: false
          cache-entry-listener-factory:
            class-name: com.example.cache.MyEntryListenerFactory
          cache-entry-event-filter-factory:
            class-name: com.example.cache.MyEntryEventFilterFactory</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>key-type#class-name</code>: Fully qualified class name of the cache
key type. Its default value is <code>java.lang.Object</code>.</p>
</li>
<li>
<p><code>value-type#class-name</code>: Fully qualified class name of the
cache value type. Its default value is <code>java.lang.Object</code>.</p>
</li>
<li>
<p><code>statistics-enabled</code>: If set to true, statistics like cache
hits and misses are collected. Its default value is false.</p>
</li>
<li>
<p><code>management-enabled</code>: If set to true, JMX beans are enabled
and collected statistics are provided. It doesn&#8217;t automatically
enable statistics collection. Its default value is false.</p>
</li>
<li>
<p><code>read-through</code>: If set to true, enables read-through behavior of
the cache to an underlying configured <code>javax.cache.integration.CacheLoader</code>
which is also known as lazy-loading. Its default value is false.</p>
</li>
<li>
<p><code>write-through</code>: If set to true, enables write-through behavior of the
cache to an underlying configured <code>javax.cache.integration.CacheWriter</code>
which passes any changed value to the external backend resource.
Its default value is false.</p>
</li>
<li>
<p><code>cache-loader-factory#class-name</code>: Fully qualified class name of the
<code>javax.cache.configuration.Factory</code> implementation providing a
<code>javax.cache.integration.CacheLoader</code> instance to the cache.</p>
</li>
<li>
<p><code>cache-writer-factory#class-name</code>: Fully qualified class name of the
<code>javax.cache.configuration.Factory</code> implementation providing a
<code>javax.cache.integration.CacheWriter</code> instance to the cache.</p>
</li>
<li>
<p><code>expiry-policy-factory#-class-name</code>: Fully qualified class name of the
<code>javax.cache.configuration.Factory</code> implementation providing a
<code>javax.cache.expiry.ExpiryPolicy</code> instance to the cache.</p>
</li>
<li>
<p><code>cache-entry-listener</code>: A set of attributes and elements,
explained below, to describe a <code>javax.cache.event.CacheEntryListener</code>.</p>
<div class="ulist">
<ul>
<li>
<p><code>cache-entry-listener#old-value-required</code>: If set to true,
previously assigned values for the affected keys are sent to the
<code>javax.cache.event.CacheEntryListener</code> implementation. Setting this
attribute to true creates additional traffic. Its default value is false.</p>
</li>
<li>
<p><code>cache-entry-listener#synchronous</code>: If set to true, the
<code>javax.cache.event.CacheEntryListener</code> implementation is called
in a synchronous manner. Its default value is false.</p>
</li>
<li>
<p><code>cache-entry-listener/entry-listener-factory#class-name</code>: Fully
qualified class name of the <code>javax.cache.configuration.Factory</code>
implementation providing a <code>javax.cache.event.CacheEntryListener</code> instance.</p>
</li>
<li>
<p><code>cache-entry-listener/entry-event-filter-factory#class-name</code>:
Fully qualified class name of the <code>javax.cache.configuration.Factory</code>
implementation providing a <code>javax.cache.event.CacheEntryEventFilter</code> instance.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The JMX MBeans provided by Hazelcast JCache show statistics of the local member only.
To show the cluster-wide statistics, the user should collect
statistic information from all members and accumulate them to
the overall statistics.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="jcache-programmatic-configuration"><a class="anchor" href="#jcache-programmatic-configuration"></a>Programmatic Configuration</h5>
<div class="paragraph">
<p>To configure the JCache programmatically:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>either instantiate <code>javax.cache.configuration.MutableConfiguration</code> if you will use
only the JCache standard configuration,</p>
</li>
<li>
<p>or instantiate <code>com.hazelcast.config.CacheConfig</code> for a deeper Hazelcast integration.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>com.hazelcast.config.CacheConfig</code> offers additional options that
are specific to Hazelcast, such as asynchronous and synchronous backup counts.
Both classes share the same supertype interface
<code>javax.cache.configuration.CompleteConfiguration</code> which is part of the JCache
standard.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To stay vendor independent, try to keep your code as near as
possible to the standard JCache API. We recommend that you use declarative
configuration and that you use the <code>javax.cache.configuration.Configuration</code>
or <code>javax.cache.configuration.CompleteConfiguration</code> interfaces in
your code only when you need to pass the configuration instance throughout your code.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If you don&#8217;t need to configure Hazelcast specific properties, we recommend that you instantiate
<code>javax.cache.configuration.MutableConfiguration</code> and that you use the
setters to configure Hazelcast as shown in the example in the
<a href="#example-jcache-application">Example JCache Application section</a>.
Since the configurable properties are the same as the ones explained in the
<a href="#jcache-declarative-configuration">JCache Declarative Configuration section</a>,
they are not mentioned here. For Hazelcast specific properties, please read the
<a href="#icache-configuration">ICache Configuration section</a> section.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jcache_providers"><a class="anchor" href="#_jcache_providers"></a>JCache Providers</h3>
<div class="paragraph">
<p>Use JCache providers to create caches for a
specification compliant implementation. Those
providers abstract the platform
specific behavior and bindings and provide the
different JCache required features.</p>
</div>
<div class="paragraph">
<p>Hazelcast has two types of providers. Depending on your
application setup and the cluster topology,
you can use the Client Provider (used by Hazelcast clients)
or the Member Provider (used by cluster members).</p>
</div>
<div class="paragraph">
<p>For more information on cluster topologies and Hazelcast
clients, see the <a href="#hazelcast-topology">Hazelcast Topology section</a>.</p>
</div>
<div class="sect3">
<h4 id="_configuring_jcache_provider"><a class="anchor" href="#_configuring_jcache_provider"></a>Configuring JCache Provider</h4>
<div class="paragraph">
<p>Hazelcast provides three <code>CachingProvider</code> implementations:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A member-side implementation: the <code>CacheManager</code>s created by this provider are backed by
member-side <code>HazelcastInstance</code>s.</p>
</li>
<li>
<p>A client-side implementation: the <code>CacheManager</code>s created by this provider are backed by
client-side <code>HazelcastInstance</code>s.</p>
</li>
<li>
<p>A delegating caching provider that can be configured to delegate to the member-
or client-side implementation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When Hazelcast is the only JCache provider on the classpath, the default
caching provider returned by <code>javax.cache.CachingProvider#getCachingProvider()</code> is
the delegating <code>CachingProvider</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// provides the default delegating caching provider
CachingProvider provider = javax.cache.Caching.getCachingProvider();</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, the delegating caching provider chooses the client-side implementation,
however it can be configured to explicitly pick the client- or member-side implementation.
This is achieved by setting the <code>hazelcast.jcache.provider.type</code> system property to <code>client</code>
or <code>member</code>. The legacy value <code>server</code> is also accepted as an alias for <code>member</code>, however its
usage is discouraged as it will be removed in a future version.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">System.setProperty("hazelcast.jcache.provider.type", "member");
// the returned provider will delegate to the member-side caching provider
CachingProvider provider = javax.cache.Caching.getCachingProvider();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also configure the default <code>CachingProvider</code> by setting its fully qualified
class name to the value of the <code>javax.cache.spi.CachingProvider</code> system property.
The system property can be defined at the <code>java</code> command line (using
<code>-Djavax.cache.spi.CachingProvider=&lt;fully-qualified-class-name&gt;</code>) or
programmatically using <code>java.lang.System#setProperty(String, String)</code>.</p>
</div>
<div class="paragraph">
<p>The JCache API also provides methods to explicitly request the instantiation of
a specific <code>CachingProvider</code> by supplying its fully qualified class name. This is
useful to explicitly choose Hazelcast as <code>CachingProvider</code> in case multiple
implementations reside on the classpath.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// provides the member-side caching provider
CachingProvider provider = Caching.getCachingProvider("com.hazelcast.cache.HazelcastMemberCachingProvider");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Since Hazelcast 4.0.3 the fully qualified class names for Hazelcast&#8217;s <code>CachingProvider</code> implementations are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Delegating <code>CachingProvider</code> (picks member- or client-side provider depending on configuration):
<code>com.hazelcast.cache.HazelcastCachingProvider</code></p>
</li>
<li>
<p>Member-side: <code>com.hazelcast.cache.HazelcastMemberCachingProvider</code>. The legacy class name
<code>com.hazelcast.cache.impl.HazelcastServerCachingProvider</code> is also accepted, however its usage is
discouraged and will be removed in a future version.</p>
</li>
<li>
<p>Client-side: <code>com.hazelcast.client.cache.HazelcastClientCachingProvider</code>. The legacy class name
<code>com.hazelcast.client.cache.impl.HazelcastClientCachingProvider</code> is also accepted, however its usage is
discouraged and will be removed in a future version.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jcache_api"><a class="anchor" href="#_jcache_api"></a>JCache API</h3>
<div class="paragraph">
<p>This section explains the JCache API by providing simple
examples and use cases. While walking through the examples,
we will have
a look at a couple of the standard API classes and see
how these classes are used.</p>
</div>
<div class="sect3">
<h4 id="_jcache_api_application_example"><a class="anchor" href="#_jcache_api_application_example"></a>JCache API Application Example</h4>
<div class="paragraph">
<p>The code in this subsection creates a small account application
by providing a caching layer over an imagined database abstraction.
The database layer is simulated using a single demo data in a simple
DAO interface. To show the difference between the "database"
access and retrieving values from the cache, a small waiting time is
used in the DAO implementation to simulate network and
database latency.</p>
</div>
<div class="sect4">
<h5 id="_creating_user_class_example"><a class="anchor" href="#_creating_user_class_example"></a>Creating User Class Example</h5>
<div class="paragraph">
<p>Before we implement the JCache caching layer, let&#8217;s have a quick
look at some basic classes we need for this example.</p>
</div>
<div class="paragraph">
<p>The <code>User</code> class is the representation of a user table in the
database. To keep it simple, it has just two properties:
<code>userId</code> and <code>username</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class User implements Serializable {

    private int userId;
    private String username;

    public User() {
    }</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_creating_dao_interface_example"><a class="anchor" href="#_creating_dao_interface_example"></a>Creating DAO Interface Example</h5>
<div class="paragraph">
<p>The DAO interface is also kept easy in this example.
It provides a simple method to retrieve (find) a user by its <code>userId</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public interface UserDao {

    User findUserById(int userId);
    boolean storeUser(int userId, User user);
    boolean removeUser(int userId);
    Collection&lt;Integer&gt; allUserIds();
}</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_jcache_example"><a class="anchor" href="#_configuring_jcache_example"></a>Configuring JCache Example</h5>
<div class="paragraph">
<p>To show most of the standard features, the configuration
example is a little more complex.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create javax.cache.configuration.CompleteConfiguration subclass
CompleteConfiguration&lt;Integer, User&gt; config =
    new MutableConfiguration&lt;Integer, User&gt;()
        // Configure the cache to be typesafe
        .setTypes( Integer.class, User.class )
        // Configure to expire entries 30 secs after creation in the cache
        .setExpiryPolicyFactory( FactoryBuilder.factoryOf(
            new AccessedExpiryPolicy( new Duration( TimeUnit.SECONDS, 30 ) )
        ) )
        // Configure read-through of the underlying store
        .setReadThrough( true )
        // Configure write-through to the underlying store
        .setWriteThrough( true )
        // Configure the javax.cache.integration.CacheLoader
        .setCacheLoaderFactory( FactoryBuilder.factoryOf(
            new UserCacheLoader( userDao )
        ) )
        // Configure the javax.cache.integration.CacheWriter
        .setCacheWriterFactory( FactoryBuilder.factoryOf(
            new UserCacheWriter( userDao )
        ) )
        // Configure the javax.cache.event.CacheEntryListener with no
        // javax.cache.event.CacheEntryEventFilter, to include old value
        // and to be executed synchronously
        .addCacheEntryListenerConfiguration(
            new MutableCacheEntryListenerConfiguration&lt;Integer, User&gt;(
                new UserCacheEntryListenerFactory(),
                null, true, true
            )
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s go through this configuration line by line.</p>
</div>
<div class="sect5">
<h6 id="_setting_the_cache_type_and_expire_policy"><a class="anchor" href="#_setting_the_cache_type_and_expire_policy"></a>Setting the Cache Type and Expire Policy</h6>
<div class="paragraph">
<p>First, we set the expected types for the cache, which
is already known from the previous example. On the next line, a
<code>javax.cache.expiry.ExpiryPolicy</code> is configured.
Almost all integration <code>ExpiryPolicy</code> implementations are
configured using
<code>javax.cache.configuration.Factory</code> instances. <code>Factory</code> and
<code>FactoryBuilder</code> are explained later in this chapter.</p>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_read_through_and_write_through"><a class="anchor" href="#_configuring_read_through_and_write_through"></a>Configuring Read-Through and Write-Through</h6>
<div class="paragraph">
<p>The next two lines configure the thread that are read-through
and write-through to the underlying backend resource that is configured
over the next few lines. The JCache API offers <code>javax.cache.integration.CacheLoader</code>
and <code>javax.cache.integration.CacheWriter</code> to
implement adapter classes to any kind of backend resource, e.g., JPA, JDBC, or any
other backend technology implementable in Java.
The interface provides the typical CRUD operations like <code>create</code>, <code>get</code>,
<code>update</code>, <code>delete</code> and some bulk operation versions of those
common operations. We will look into the implementation of those implementations
later.</p>
</div>
</div>
<div class="sect5">
<h6 id="_configuring_entry_listeners"><a class="anchor" href="#_configuring_entry_listeners"></a>Configuring Entry Listeners</h6>
<div class="paragraph">
<p>The last configuration setting defines entry listeners based on
sub-interfaces of <code>javax.cache.event.CacheEntryListener</code>. This
config does not use a <code>javax.cache.event.CacheEntryEventFilter</code>
since the listener is meant to be fired on every change that
happens on the cache. Again we will look in the implementation
of the listener in later in this chapter.</p>
</div>
</div>
<div class="sect5">
<h6 id="_full_example_code"><a class="anchor" href="#_full_example_code"></a>Full Example Code</h6>
<div class="paragraph">
<p>A full running example that is presented in this
subsection is available in the
<a href="https://github.com/hazelcast/hazelcast-code-samples/tree/master/jcache/src/main/java/com/hazelcast/examples/application" target="_blank" rel="noopener">code samples repository</a>.
The application is built to be a command line app. It
offers a small shell to accept different commands. After startup, you can
enter <code>help</code> to see all available commands and their descriptions.</p>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jcache_base_classes"><a class="anchor" href="#_jcache_base_classes"></a>JCache Base Classes</h4>
<div class="paragraph">
<p>In the <a href="#example-jcache-application">Example JCache Application section</a>,
we have already seen a couple of the base classes and explained how
those work. The following are quick descriptions of them:</p>
</div>
<div class="paragraph">
<p><strong><code>javax.cache.Caching</code></strong>:</p>
</div>
<div class="paragraph">
<p>The access point into the JCache API. It retrieves the general
<code>CachingProvider</code> backed by any compliant JCache
implementation, such as Hazelcast JCache.</p>
</div>
<div class="paragraph">
<p><strong><code>javax.cache.spi.CachingProvider</code></strong>:</p>
</div>
<div class="paragraph">
<p>The SPI that is implemented to bridge between the JCache API and
the implementation itself. Hazelcast members and clients use different
providers chosen as seen in the <a href="#configuring-jcache-provider">Configuring JCache Provider section</a> which enable the JCache API to
interact with Hazelcast clusters.</p>
</div>
<div class="paragraph">
<p>When a <code>javax.cache.spi.CachingProvider.getCacheManager()</code> overload
that takes a <code>java.lang.ClassLoader</code> argument is used, this
classloader will be a part of the scope of the created <code>java.cache.Cache</code>,
and it is not possible to retrieve it on other members.
We advise not to use those overloads, as they are not meant to be used
in distributed environments!</p>
</div>
<div class="paragraph">
<p><strong><code>javax.cache.CacheManager</code></strong>:</p>
</div>
<div class="paragraph">
<p>The <code>CacheManager</code> provides the capability to create new and
manage existing JCache caches.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>javax.cache.Cache</code> instance created with key and
value types in the configuration
provides a type checking of those types at retrieval of the
cache. For that reason, all non-types retrieval methods like
<code>getCache</code> throw an exception because types cannot be checked.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong><code>javax.cache.configuration.Configuration</code></strong>, <strong><code>javax.cache.configuration.MutableConfiguration</code></strong>:</p>
</div>
<div class="paragraph">
<p>These two classes are used to configure a cache prior to
retrieving it from a <code>CacheManager</code>. The <code>Configuration</code> interface,
therefore, acts as a common super type for all compatible
configuration classes such as <code>MutableConfiguration</code>.</p>
</div>
<div class="paragraph">
<p>Hazelcast itself offers a special implementation
(<code>com.hazelcast.config.CacheConfig</code>) of the <code>Configuration</code> interface
which offers more options on the specific Hazelcast properties
that can be set to configure features like synchronous and asynchronous
backups counts or selecting the underlying <a href="#setting-in-memory-format">in-memory format</a> of the cache. For more information on this
configuration class, see the reference in the <a href="#jcache-programmatic-configuration">JCache Programmatic Configuration section</a>.</p>
</div>
<div class="paragraph">
<p><strong><code>javax.cache.Cache</code></strong>:</p>
</div>
<div class="paragraph">
<p>This interface represents the cache instance itself.
It is comparable to <code>java.util.Map</code> but offers special operations dedicated
to the caching use case. Therefore, for example <code>javax.cache.Cache.put()</code>,
unlike <code>java.util.Map.put()</code>, does not return the old
value previously assigned to the given key.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Bulk operations on the <code>Cache</code> interface guarantee atomicity
per entry but not over
all given keys in the same bulk operations since no transactional
behavior is applied over the whole batch process.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_factory_and_factorybuilder"><a class="anchor" href="#_implementing_factory_and_factorybuilder"></a>Implementing Factory and FactoryBuilder</h4>
<div class="paragraph">
<p>The <code>javax.cache.configuration.Factory</code> implementations configure
features like <code>CacheEntryListener</code>, <code>ExpiryPolicy</code> and <code>CacheLoader</code>s or <code>CacheWriter</code>s.
These factory implementations are required to distribute the
different features to members in a cluster environment like Hazelcast.
Therefore, these factory implementations have to be serializable.</p>
</div>
<div class="paragraph">
<p><code>Factory</code> implementations are easy to do, as they follow the default
Provider- or Factory-Pattern. The example class
<code>UserCacheEntryListenerFactory</code> shown below implements a custom JCache <code>Factory</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserCacheEntryListenerFactory implements Factory&lt;CacheEntryListener&lt;Integer, User&gt;&gt; {

    @Override
    public CacheEntryListener&lt;Integer, User&gt; create() {
        // just create a new listener instance
        return new UserCacheEntryListener();
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>To simplify the process for the users, JCache API offers a set of
helper methods collected in <code>javax.cache.
configuration.FactoryBuilder</code>. In the above configuration
example, <code>FactoryBuilder.factoryOf()</code> creates a
singleton factory for the given instance.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_cacheloader"><a class="anchor" href="#_implementing_cacheloader"></a>Implementing CacheLoader</h4>
<div class="paragraph">
<p><code>javax.cache.integration.CacheLoader</code> loads cache entries
from any external backend resource.</p>
</div>
<div class="sect4">
<h5 id="_cache_read_through"><a class="anchor" href="#_cache_read_through"></a>Cache read-through</h5>
<div class="paragraph">
<p>If the cache is
configured to be <code>read-through</code>, then <code>CacheLoader.load()</code>
is called transparently from the cache when the key or the value is not
yet found in the cache. If no value is found for a given key, it returns null.</p>
</div>
<div class="paragraph">
<p>If the cache is not configured to be <code>read-through</code>, nothing is
loaded automatically. The user code must call
<code>javax.cache.Cache.loadAll()</code> to load data for the given
set of keys into the cache.</p>
</div>
<div class="paragraph">
<p>For the bulk load operation (<code>loadAll()</code>), some keys may not
be found in the returned result set. In this case, a
<code>javax.cache.integration.CompletionListener</code> parameter can be used
as an asynchronous callback after all the key-value pairs are loaded
because loading many key-value pairs can take lots of time.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cacheloader_example"><a class="anchor" href="#_cacheloader_example"></a>CacheLoader Example</h5>
<div class="paragraph">
<p>Let&#8217;s look at the <code>UserCacheLoader</code> implementation.
This implementation is quite straight forward.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It implements <code>CacheLoader</code>.</p>
</li>
<li>
<p>It overrides the <code>load</code> method to compute or retrieve
the value corresponding to <code>key</code>.</p>
</li>
<li>
<p>It overrides the <code>loadAll</code> method to compute or
retrieve the values corresponding to <code>keys</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An important note is that
any kind of exception has to be wrapped into
<code>javax.cache.integration.CacheLoaderException</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserCacheLoader implements CacheLoader&lt;Integer, User&gt;, Serializable {

    private final UserDao userDao;

    public UserCacheLoader(UserDao userDao) {
        // store the dao instance created externally
        this.userDao = userDao;
    }

    @Override
    public User load(Integer key) throws CacheLoaderException {
        // just call through into the dao
        return userDao.findUserById(key);
    }

    @Override
    public Map&lt;Integer, User&gt; loadAll(Iterable&lt;? extends Integer&gt; keys) throws CacheLoaderException {
        // create the resulting map
        Map&lt;Integer, User&gt; loaded = new HashMap&lt;Integer, User&gt;();
        // for every key in the given set of keys
        for (Integer key : keys) {
            // try to retrieve the user
            User user = userDao.findUserById(key);
            // if user is not found do not add the key to the result set
            if (user != null) {
                loaded.put(key, user);
            }
        }
        return loaded;
    }
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_cachewriter"><a class="anchor" href="#_cachewriter"></a>CacheWriter</h4>
<div class="paragraph">
<p>You use a <code>javax.cache.integration.CacheWriter</code> to update
an external backend resource. If the cache is configured to be
<code>write-through</code>, this process is executed transparently to
the user&#8217;s code. Otherwise, there is currently no way to trigger
writing changed entries to the external resource to a user-defined
point in time.</p>
</div>
<div class="paragraph">
<p>If bulk operations throw an exception, <code>java.util.Collection</code>
has to be cleaned of all successfully written keys so
the cache implementation can determine what keys are written
and can be applied to the cache state.</p>
</div>
<div class="paragraph">
<p>The following example performs the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It implements <code>CacheWriter</code>.</p>
</li>
<li>
<p>It overrides the <code>write</code> method to write the specified
entry to the underlying store.</p>
</li>
<li>
<p>It overrides the <code>writeAll</code> method to write the specified
entires to the underlying store.</p>
</li>
<li>
<p>It overrides the <code>delete</code> method to delete the key entry
from the store.</p>
</li>
<li>
<p>It overrides the <code>deleteAll</code> method to delete the data and
keys from the underlying store for the given collection of keys, if present.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserCacheWriter implements CacheWriter&lt;Integer, User&gt;, Serializable {

    private final UserDao userDao;

    public UserCacheWriter(UserDao userDao) {
        // store the dao instance created externally
        this.userDao = userDao;
    }

    @Override
    public void write(Cache.Entry&lt;? extends Integer, ? extends User&gt; entry) throws CacheWriterException {
        // store the user using the dao
        userDao.storeUser(entry.getKey(), entry.getValue());
    }

    @Override
    public void writeAll(Collection&lt;Cache.Entry&lt;? extends Integer, ? extends User&gt;&gt; entries) throws CacheWriterException {
        // retrieve the iterator to clean up the collection from written keys in case of an exception
        Iterator&lt;Cache.Entry&lt;? extends Integer, ? extends User&gt;&gt; iterator = entries.iterator();
        while (iterator.hasNext()) {
            // write entry using dao
            write(iterator.next());
            // remove from collection of keys
            iterator.remove();
        }
    }

    @Override
    public void delete(Object key) throws CacheWriterException {
        // test for key type
        if (!(key instanceof Integer)) {
            throw new CacheWriterException("Illegal key type");
        }
        // remove user using dao
        userDao.removeUser((Integer) key);
    }

    @Override
    public void deleteAll(Collection&lt;?&gt; keys) throws CacheWriterException {
        // retrieve the iterator to clean up the collection from written keys in case of an exception
        Iterator&lt;?&gt; iterator = keys.iterator();
        while (iterator.hasNext()) {
            // write entry using dao
            delete(iterator.next());
            // remove from collection of keys
            iterator.remove();
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Again, the implementation is pretty straightforward and
also as above all exceptions thrown by the external resource,
like <code>java.sql.SQLException</code> has to be wrapped into a
<code>javax.cache.integration.CacheWriterException</code>. Note this is a different
exception from the one thrown by <code>CacheLoader</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_entryprocessor"><a class="anchor" href="#_implementing_entryprocessor"></a>Implementing EntryProcessor</h4>
<div class="paragraph">
<p>With <code>javax.cache.processor.EntryProcessor</code>, you can apply an
atomic function to a cache entry. In a distributed
environment like Hazelcast, you can move the mutating function
to the member that owns the key. If the value
object is big, it might prevent traffic by sending the object
to the mutator and sending it back to the owner to update it.</p>
</div>
<div class="paragraph">
<p>By default, Hazelcast JCache sends the complete changed value
to the backup partition. Again, this can cause a lot of traffic if
the object is big. The Hazelcast ICache extension can also prevent this.
Further information is available at
<a href="#implementing-backupawareentryprocessor">Implementing BackupAwareEntryProcessor</a>.</p>
</div>
<div class="paragraph">
<p>An arbitrary number of arguments can be passed to the
<code>Cache.invoke()</code> and <code>Cache.invokeAll()</code> methods. All of those
arguments need
to be fully serializable because in a distributed environment
like Hazelcast, it is very likely that these arguments have to be passed around the cluster.</p>
</div>
<div class="paragraph">
<p>The following example performs the following tasks.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It implements <code>EntryProcessor</code>.</p>
</li>
<li>
<p>It overrides the <code>process</code> method to process an entry.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserUpdateEntryProcessor implements EntryProcessor&lt;Integer, User, User&gt; {

    @Override
    public User process(MutableEntry&lt;Integer, User&gt; entry, Object... arguments) throws EntryProcessorException {
        // test arguments length
        if (arguments.length &lt; 1) {
            throw new EntryProcessorException("One argument needed: username");
        }

        // get first argument and test for String type
        Object argument = arguments[0];
        if (!(argument instanceof String)) {
            throw new EntryProcessorException("First argument has wrong type, required java.lang.String");
        }

        // retrieve the value from the MutableEntry
        User user = entry.getValue();

        // retrieve the new username from the first argument
        String newUsername = (String) arguments[0];

        // set the new username
        user.setUsername(newUsername);

        // set the changed user to mark the entry as dirty
        entry.setValue(user);

        // return the changed user to return it to the caller
        return user;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
By executing the bulk <code>Cache.invokeAll()</code> operation,
atomicity is only guaranteed for a
single cache entry. No transactional rules are applied to the bulk operation.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
JCache <code>EntryProcessor</code> implementations are not allowed to call
<code>javax.cache.Cache</code> methods. This prevents operations from
deadlocking between different calls.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition, when using a <code>Cache.invokeAll()</code> method, a
<code>java.util.Map</code> is returned that maps the key to its
<code>javax.cache.processor.EntryProcessorResult</code>, which itself
wraps the actual result or a thrown
<code>javax.cache.processor.EntryProcessorException</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_cacheentrylistener"><a class="anchor" href="#_cacheentrylistener"></a>CacheEntryListener</h4>
<div class="paragraph">
<p>The <code>javax.cache.event.CacheEntryListener</code> implementation is
straight forward. <code>CacheEntryListener</code> is a super-interface that
is used as a marker for listener classes in JCache. The specification
brings a set of sub-interfaces.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>CacheEntryCreatedListener</code>: Fires after a cache entry is
added (even on read-through by a <code>CacheLoader</code>) to the cache.</p>
</li>
<li>
<p><code>CacheEntryUpdatedListener</code>: Fires after an already existing
cache entry updates.</p>
</li>
<li>
<p><code>CacheEntryRemovedListener</code>: Fires after a cache entry
was removed (not expired) from the cache.</p>
</li>
<li>
<p><code>CacheEntryExpiredListener</code>: Fires after a cache entry
has been expired. Expiry does not have to be a parallel
process-- Hazelcast JCache implementation detects and
removes expired entries periodically. Therefore, the expiration
event may not be fired as soon as the entry expires.
See <a href="#_expirypolicy">ExpiryPolicy</a> for details.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To configure <code>CacheEntryListener</code>, add a
<code>javax.cache.configuration.CacheEntryListenerConfiguration</code> instance to
the JCache configuration class, as seen in the above example
configuration. In addition, listeners can be configured to be
executed synchronously (blocking the calling thread) or asynchronously
(fully running in parallel).</p>
</div>
<div class="paragraph">
<p>In this example application, the listener is implemented to
print event information on the console. That visualizes what is
going on in the cache. This application performs the following tasks:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It implements the <code>CacheEntryCreatedListener.onCreated</code> method
to call after an entry is created.</p>
</li>
<li>
<p>It implements the <code>CacheEntryUpdatedListener.onUpdated</code> method
to call after an entry is updated.</p>
</li>
<li>
<p>It implements the <code>CacheEntryRemovedListener.onRemoved</code> method
to call after an entry is removed.</p>
</li>
<li>
<p>It implements the <code>CacheEntryExpiredListener.onExpired</code> method
to call after an entry expires.</p>
</li>
<li>
<p>It implements <code>printEvents</code> to print event information on the
console.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class UserCacheEntryListener implements CacheEntryCreatedListener&lt;Integer, User&gt;,
        CacheEntryUpdatedListener&lt;Integer, User&gt;,
        CacheEntryRemovedListener&lt;Integer, User&gt;,
        CacheEntryExpiredListener&lt;Integer, User&gt; {

    @Override
    public void onCreated(Iterable&lt;CacheEntryEvent&lt;? extends Integer, ? extends User&gt;&gt; cacheEntryEvents)
            throws CacheEntryListenerException {

        printEvents(cacheEntryEvents);
    }

    @Override
    public void onUpdated(Iterable&lt;CacheEntryEvent&lt;? extends Integer, ? extends User&gt;&gt; cacheEntryEvents)
            throws CacheEntryListenerException {

        printEvents(cacheEntryEvents);
    }

    @Override
    public void onRemoved(Iterable&lt;CacheEntryEvent&lt;? extends Integer, ? extends User&gt;&gt; cacheEntryEvents)
            throws CacheEntryListenerException {

        printEvents(cacheEntryEvents);
    }

    @Override
    public void onExpired(Iterable&lt;CacheEntryEvent&lt;? extends Integer, ? extends User&gt;&gt; cacheEntryEvents)
            throws CacheEntryListenerException {

        printEvents(cacheEntryEvents);
    }

    private void printEvents(Iterable&lt;CacheEntryEvent&lt;? extends Integer, ? extends User&gt;&gt; cacheEntryEvents) {
        for (CacheEntryEvent&lt;? extends Integer, ? extends User&gt; event : cacheEntryEvents) {
            System.out.println(event.getEventType());
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_expirypolicy"><a class="anchor" href="#_expirypolicy"></a>ExpiryPolicy</h4>
<div class="paragraph">
<p>In JCache, <code>javax.cache.expiry.ExpiryPolicy</code> implementations are
used to automatically expire cache entries based on different rules.</p>
</div>
<div class="paragraph">
<p>JCache does not require expired entries to be removed from the cache
immediately. It only enforces that expired entries are not returned from cache.
Therefore, exact time of removal is implementation specific.
Hazelcast complies JCache by checking the entries for expiration
at the time of
get operations (lazy expiration). In addition to that, Hazelcast
uses a periodic task to detect and remove expired entries as soon as possible
(eager expiration).
Thanks to eager expiry, all expired entries are removed from the memory
eventually even when they are not touched again. So the space
used by such entries are released as well.</p>
</div>
<div class="paragraph">
<p>For a detailed explanation of interaction between expiry policies and
JCache API, see the table in the <code>Expiry Policies</code> section of
<a href="https://www.jcp.org/en/jsr/detail?id=107" target="_blank" rel="noopener">JCache documentation</a>.</p>
</div>
<div class="paragraph">
<p>Expiry timeouts are defined using <code>javax.cache.expiry.Duration</code>,
which is a pair of <code>java.util.concurrent.TimeUnit</code>, that
describes a time unit and a long, defining the timeout value.
The minimum allowed <code>TimeUnit</code> is <code>TimeUnit.MILLISECONDS</code>.
The long value <code>durationAmount</code> must be equal or greater than zero.
A value of zero (or <code>Duration.ZERO</code>) indicates that the
cache entry expires immediately.</p>
</div>
<div class="paragraph">
<p>By default, JCache delivers a set of predefined expiry strategies
in the standard API.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>AccessedExpiryPolicy</code>: Expires after a given set of time measured
from creation of the cache entry. The expiry timeout is updated on accessing the key.</p>
</li>
<li>
<p><code>CreatedExpiryPolicy</code>: Expires after a given set of time measured
from creation of the cache entry. The expiry timeout is never updated.</p>
</li>
<li>
<p><code>EternalExpiryPolicy</code>: Never expires. This is the default behavior,
similar to <code>ExpiryPolicy</code> being set to null.</p>
</li>
<li>
<p><code>ModifiedExpiryPolicy</code>: Expires after a given set of time measured
from creation of the cache entry. The expiry timeout is updated on updating the key.</p>
</li>
<li>
<p><code>TouchedExpiryPolicy</code>: Expires after a given set of time measured
from creation of the cache entry. The expiry timeout is updated on accessing or updating the key.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Because <code>EternalExpiryPolicy</code> does not expire cache entries,
it is still possible to evict values from memory if an underlying
<code>CacheLoader</code> is defined.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_jcache_hazelcast_instance_integration"><a class="anchor" href="#_jcache_hazelcast_instance_integration"></a>JCache - Hazelcast Instance Integration</h3>
<div class="paragraph">
<p>You can retrieve <code>javax.cache.Cache</code> instances using the
interface <code>ICacheManager</code> of <code>HazelcastInstance</code>. This
interface has the method <code>getCache(String name)</code> where <code>name</code>
is the prefixed cache name. The prefixes in the cache name are
URI and classloader prefixes, which are optional.</p>
</div>
<div class="paragraph">
<p>If you create a cache through a <code>ICacheManager</code> which has its own
specified URI scope (and/or specified classloader),
it must be prepended to the pure cache name as a prefix while
retrieving the cache through <code>getCache(String name)</code>.
Prefix generation for full cache name is exposed through
<code>com.hazelcast.cache.CacheUtil.getPrefixedCacheName(String name,
java.net.URI uri, ClassLoader classloader)</code>.
If the URI scope and classloader is not specified, the pure cache
name can be used directly while retrieving cache over <code>ICacheManager</code>.</p>
</div>
<div class="paragraph">
<p>If you have a cache which is not created, but is defined/exists
(cache is specified in Hazelcast configuration but not created yet),
you can retrieve this cache by its name.  This also triggers cache
creation before retrieving it. This retrieval is supported through
<code>HazelcastInstance</code>. However, <code>HazelcastInstance</code> <strong><strong>does not</strong></strong> support
creating a cache by specifying configuration; this is supported by
Hazelcast&#8217;s <code>ICacheManager</code> as it is.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If a valid (rather than <strong>1.0.0-PFD</strong> or <strong>0.x</strong> versions)
JCache library does not exist on the classpath, <code>IllegalStateException</code>
is thrown.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_jcache_and_hazelcast_instance_awareness"><a class="anchor" href="#_jcache_and_hazelcast_instance_awareness"></a>JCache and Hazelcast Instance Awareness</h4>
<div class="paragraph">
<p><code>HazelcastInstance</code> is injected into the following cache API interfaces
(provided by <code>javax.cache.Cache</code> and <code>com.hazelcast.cache.ICache</code>)
if they implement <code>HazelcastInstanceAware</code> interface:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ExpiryPolicyFactory</code> and <code>ExpiryPolicy</code> [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>CacheLoaderFactory</code> and <code>CacheLoader</code> [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>CacheWriteFactory</code> and <code>CacheWriter</code> [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>EntryProcessor</code> [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>CacheEntryListener</code> (<code>CacheEntryCreatedListener</code>, <code>CacheEntryUpdatedListener</code>,
<code>CacheEntryRemovedListener</code>, <code>CacheEntryExpiredListener</code>) [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>CacheEntryEventFilter</code> [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>CompletionListener</code> [provided by <code>javax.cache.Cache</code>]</p>
</li>
<li>
<p><code>CachePartitionLostListener</code> [provided by <code>com.hazelcast.cache.ICache</code>]</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_hazelcast_jcache_extension_icache"><a class="anchor" href="#_hazelcast_jcache_extension_icache"></a>Hazelcast JCache Extension - ICache</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast provides extension methods to Cache API through
the interface <code>com.hazelcast.cache.ICache</code>.</p>
</div>
<div class="paragraph">
<p>It has two sets of extensions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Asynchronous version of all cache operations.
See <a href="#icache-async-methods">Async Operations</a>.</p>
</li>
<li>
<p>Cache operations with custom <code>ExpiryPolicy</code> parameter
to apply on that specific operation. See <a href="#defining-a-custom-expirypolicy">Custom ExpiryPolicy</a>.</p>
</li>
</ul>
</div>
<hr>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
ICache data structure can also be used by
<a href="https://jet.hazelcast.org/" target="_blank" rel="noopener">Hazelcast Jet</a> for Real-Time Stream Processing
(by enabling the Event Journal on your cache) and Fast Batch Processing.
Hazelcast Jet uses ICache as a source (reads data from ICache) and as a sink
(writes data to ICache). See the <a href="https://jet.hazelcast.org/use-cases/fast-batch-processing/" target="_blank" rel="noopener">Fast Batch Processing</a>
and <a href="https://jet.hazelcast.org/use-cases/real-time-stream-processing/" target="_blank" rel="noopener">Real-Time Stream Processing</a>
use cases for Hazelcast Jet. See also
<a href="https://docs.hazelcast.org/docs/jet/latest/manual/index.html#connector-imdg" target="_blank" rel="noopener">here</a> in the
Hazelcast Jet Reference Manual to learn how Jet uses ICache, i.e., how it can
read from and write to ICache.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="_scoping_to_join_clusters"><a class="anchor" href="#_scoping_to_join_clusters"></a>Scoping to Join Clusters</h3>
<div class="paragraph">
<p>A <code>CacheManager</code>, started either as a client or as an embedded member,
can be configured to start a new Hazelcast instance or reuse an already
existing one to connect to a Hazelcast cluster. To achieve this, request
a <code>CacheManager</code> by passing a <code>java.net.URI</code> instance to <code>CachingProvider.getCacheManager()</code>.
The <code>java.net.URI</code> instance must point to either a Hazelcast configuration or to the name of a named
<code>com.hazelcast.core.HazelcastInstance</code> instance. In addition to the above,
the same can be achieved by passing Hazelcast-specific properties to
<code>CachingProvider.getCacheManager(URI, ClassLoader, Properties)</code> as detailed in the
sections that follow.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Multiple requests for the same <code>java.net.URI</code> result in returning a <code>CacheManager</code>
instance that shares the same <code>HazelcastInstance</code> as the <code>CacheManager</code>
returned by the previous call.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_examples"><a class="anchor" href="#_examples"></a>Examples</h4>
<div class="paragraph">
<p>The following examples illustrate how <code>HazelcastInstance</code>s are created
or reused during the creation of a new <code>CacheManager</code>. Complete reference
on the <code>HazelcastInstance</code> lookup mechanism is provided in the sections that follow.</p>
</div>
<div class="sect4">
<h5 id="_starting_the_default_cachemanager"><a class="anchor" href="#_starting_the_default_cachemanager"></a>Starting the Default <code>CacheManager</code></h5>
<div class="paragraph">
<p>Assuming no other <code>HazelcastInstance</code> exists in the same JVM, the
<code>cacheManager</code> below starts a new <code>HazelcastInstance</code>, configured
according to the configuration lookup rules as defined for <code>Hazelcast.newHazelcastInstance()</code>
in case of an embedded member or <code>HazelcastClient.newHazelcastClient()</code>
for a client-side <code>CacheManager</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider caching = Caching.getCachingProvider();
CacheManager cacheManager = caching.getCacheManager();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_reusing_existing_hazelcastinstance_with_the_default_cachemanager"><a class="anchor" href="#_reusing_existing_hazelcastinstance_with_the_default_cachemanager"></a>Reusing Existing <code>HazelcastInstance</code> with the Default <code>CacheManager</code></h5>
<div class="paragraph">
<p>When using both Hazelcast-specific features and JCache, a <code>HazelcastInstance</code>
might be already available to your JCache configuration.
By configuring an instance name in <code>hazelcast.xml</code> in the classpath root,
the <code>CacheManager</code> locates the existing instance by name and reuses it.</p>
</div>
<div class="paragraph">
<p><code>hazelcast.xml/yaml</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;instance-name&gt;hz-member-1&lt;/instance-name&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  instance-name: hz-member-1</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>HazelcastInstance</code> &amp; <code>CacheManager</code> startup:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// start hazelcast, configured with default hazelcast.xml
HazelcastInstance hz = Hazelcast.newHazelcastInstance();
// start the default CacheManager -- it locates the default hazelcast.xml configuration
// and identify the existing HazelcastInstance by its name
CachingProvider caching = Caching.getCachingProvider();
CacheManager cacheManager = caching.getCacheManager();</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_starting_a_cachemanager_with_a_new_hazelcastinstance_configured_with_a_non_default_configuration_file"><a class="anchor" href="#_starting_a_cachemanager_with_a_new_hazelcastinstance_configured_with_a_non_default_configuration_file"></a>Starting a <code>CacheManager</code> with a New <code>HazelcastInstance</code> Configured with a Non-default Configuration File</h5>
<div class="paragraph">
<p>Given a configuration file named <code>hazelcast-jcache.xml</code> in the package
<code>com.domain</code>, a <code>CacheManager</code> can be configured to start a new <code>HazelcastInstance</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By passing the <code>URI</code> to the configuration file as the <code>CacheManager&#8217;s `URI</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider caching = Caching.getCachingProvider();
CacheManager cacheManager = caching.getCacheManager(new URI("classpath:com/domain/hazelcast-jcache.xml"), null);</code></pre>
</div>
</div>
</li>
<li>
<p>By specifying the configuration file location as a property:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Properties properties = HazelcastCachingProvider.propertiesByLocation("classpath:com/domain/aaa-hazelcast.xml");
CachingProvider caching = Caching.getCachingProvider();
CacheManager cacheManager = caching.getCacheManager(new URI("any-uri-will-do"), null, properties);</code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that if the Hazelcast configuration file does specify an
instance name, then any <code>CacheManager</code>s referencing the
same configuration file locates by name and reuses the same
<code>HazelcastInstance</code>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_reusing_an_existing_named_hazelcastinstance"><a class="anchor" href="#_reusing_an_existing_named_hazelcastinstance"></a>Reusing an Existing Named <code>HazelcastInstance</code></h5>
<div class="paragraph">
<p>Assuming a <code>HazelcastInstance</code> named <code>hc-instance</code> is already
started, it can be used as the <code>HazelcastInstance</code> to back a
<code>CacheManager</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>By using the instance&#8217;s name as the <code>CacheManager&#8217;s `URI</code>:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider caching = Caching.getCachingProvider();
CacheManager cacheManager = caching.getCacheManager(new URI("hc-instance"), null);</code></pre>
</div>
</div>
</li>
<li>
<p>By specifying the instance name as a property:</p>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Properties properties = HazelcastCachingProvider.propertiesByInstanceName("hc-instance");
CachingProvider caching = Caching.getCachingProvider();
CacheManager cacheManager = caching.getCacheManager(new URI("any-uri-will-do"), null, properties);</code></pre>
</div>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_applying_configuration_scope"><a class="anchor" href="#_applying_configuration_scope"></a>Applying Configuration Scope</h4>
<div class="paragraph">
<p>To connect or join different clusters, apply a configuration
scope to the <code>CacheManager</code>. If the same <code>URI</code> is
used to request a <code>CacheManager</code> that was created previously,
those <code>CacheManager</code>s share the same underlying <code>HazelcastInstance</code>.</p>
</div>
<div class="paragraph">
<p>To apply configuration scope you can do either one of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>pass the path to the configuration file using the location property
<code>HazelcastCachingProvider#HAZELCAST_CONFIG_LOCATION</code> (which
resolves to <code>hazelcast.config.location</code>) as a mapping inside a
<code>java.util.Properties</code> instance to the
<code>CachingProvider.getCacheManager(uri, classLoader, properties)</code> call.</p>
</li>
<li>
<p>use directly the configuration path as the <code>CacheManager</code>'s <code>URI</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If both <code>HazelcastCachingProvider#HAZELCAST_CONFIG_LOCATION</code> property is set
and the <code>CacheManager</code> <code>URI</code> resolves to a valid config file location, then
the property value is used to obtain the configuration for the <code>HazelcastInstance</code>
the first time a <code>CacheManager</code> is created for the given <code>URI</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example of using configuration scope:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider cachingProvider = Caching.getCachingProvider();

// Create Properties instance pointing to a Hazelcast config file
Properties properties = new Properties();
// "scope-hazelcast.xml" resides in package com.domain.config
properties.setProperty( HazelcastCachingProvider.HAZELCAST_CONFIG_LOCATION,
    "classpath:com/domain/config/scoped-hazelcast.xml" );

URI cacheManagerName = new URI( "my-cache-manager" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null, properties );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example using <code>HazelcastCachingProvider.propertiesByLocation()</code> helper method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider cachingProvider = Caching.getCachingProvider();

// Create Properties instance pointing to a Hazelcast config file in root package
String configFile = "classpath:scoped-hazelcast.xml";
Properties properties = HazelcastCachingProvider
    .propertiesByLocation( configFile );

URI cacheManagerName = new URI( "my-cache-manager" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null, properties );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The retrieved <code>CacheManager</code> is scoped to use the <code>HazelcastInstance</code>
that was just created and configured using the given XML
configuration file.</p>
</div>
<div class="paragraph">
<p>Available protocols for config file URL include <code>classpath</code> to point to
a classpath location, <code>file</code> to point to a filesystem
location and <code>http</code> and <code>https</code> for remote web locations. In addition,
everything that does not specify a protocol is recognized
as a placeholder that can be configured using a system property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String configFile = "my-placeholder";
Properties properties = HazelcastCachingProvider
    .propertiesByLocation( configFile );</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can set this on the command line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>-Dmy-placeholder=classpath:my-configs/scoped-hazelcast.xml</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should consider the following rules about the Hazelcast instance name
when you specify the configuration file location using
<code>HazelcastCachingProvider#HAZELCAST_CONFIG_LOCATION</code> (which resolves to
<code>hazelcast.config.location</code>):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If you also specified the <code>HazelcastCachingProvider#HAZELCAST_INSTANCE_NAME</code>
(which resolves to <code>hazelcast.instance.name</code>) property, this property is used
as the instance name even though you configured the instance name in the configuration file.</p>
</li>
<li>
<p>If you do not specify <code>HazelcastCachingProvider#HAZELCAST_INSTANCE_NAME</code>
but you configure the instance name in the configuration file using the element
<code>&lt;instance-name&gt;</code>, then this element&#8217;s value is used as the instance name.</p>
</li>
<li>
<p>If you do not specify an instance name via property or in the configuration
file, the URL of the configuration file location is used as the instance name.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
No check is performed to prevent creating multiple <code>CacheManager</code>s
with the same cluster
configuration on different configuration files. If the same cluster is
referred from different configuration files, multiple
cluster members or clients are created.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The configuration file location will not be a part of
the resulting identity of the
<code>CacheManager</code>. An attempt to create a <code>CacheManager</code> with a
different set of properties but an already used name results in
an undefined behavior.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_binding_to_a_named_instance"><a class="anchor" href="#_binding_to_a_named_instance"></a>Binding to a Named Instance</h4>
<div class="paragraph">
<p>You can bind <code>CacheManager</code> to an existing and named <code>HazelcastInstance</code>
instance. If the <code>instanceName</code> is specified in <code>com.hazelcast.config.Config</code>,
it can be used directly by passing it to <code>CachingProvider</code> implementation.
Otherwise (<code>instanceName</code> not set or instance is a client instance) you must
get the instance name from the <code>HazelcastInstance</code> instance via the <code>String getName()</code>
method to pass the <code>CachingProvider</code> implementation. Please note that
<code>instanceName</code> is not configurable for the client side <code>HazelcastInstance</code>
instance and is auto-generated by using cluster name (if it is specified).
In general, <code>String getName()</code> method over <code>HazelcastInstance</code> is safer and
the preferable way to get the name of the instance. Multiple <code>CacheManager</code>s
created using an equal <code>java.net.URI</code> share the same <code>HazelcastInstance</code>.</p>
</div>
<div class="paragraph">
<p>A named scope is applied nearly the same way as the configuration scope.
Pass the instance name using:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>either the property <code>HazelcastCachingProvider#HAZELCAST_INSTANCE_NAME</code>
(which resolves to <code>hazelcast.instance.name</code>) as a mapping inside a <code>java.util.Properties</code>
instance to the <code>CachingProvider.getCacheManager(uri, classLoader, properties)</code> call.</p>
</li>
<li>
<p>or use the instance name when specifying the <code>CacheManager&#8217;s `URI</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If a valid instance name is provided both as property and as <code>URI</code>, then the
property value takes precedence and is used to resolve the <code>HazelcastInstance</code>
the first time a <code>CacheManager</code> is created for the given <code>URI</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example of Named Instance Scope with specified name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.setInstanceName( "my-named-hazelcast-instance" );
// Create a named HazelcastInstance
Hazelcast.newHazelcastInstance( config );

CachingProvider cachingProvider = Caching.getCachingProvider();

// Create Properties instance pointing to a named HazelcastInstance
Properties properties = new Properties();
properties.setProperty( HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME,
     "my-named-hazelcast-instance" );

URI cacheManagerName = new URI( "my-cache-manager" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null, properties );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of Named Instance Scope with specified name passed as <code>URI</code>
of the <code>CacheManager</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.setInstanceName( "my-named-hazelcast-instance" );
// Create a named HazelcastInstance
Hazelcast.newHazelcastInstance( config );

CachingProvider cachingProvider = Caching.getCachingProvider();
URI cacheManagerName = new URI( "my-named-hazelcast-instance" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of Named Instance Scope with auto-generated name:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
// Create a auto-generated named HazelcastInstance
HazelcastInstance instance = Hazelcast.newHazelcastInstance( config );
String instanceName = instance.getName();

CachingProvider cachingProvider = Caching.getCachingProvider();

// Create Properties instance pointing to a named HazelcastInstance
Properties properties = new Properties();
properties.setProperty( HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME,
     instanceName );

URI cacheManagerName = new URI( "my-cache-manager" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null, properties );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example of Named Instance Scope with auto-generated name on client instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ClientConfig clientConfig = new ClientConfig();
ClientNetworkConfig networkConfig = clientConfig.getNetworkConfig();
networkConfig.addAddress("127.0.0.1", "127.0.0.2");

// Create a client side HazelcastInstance
HazelcastInstance instance = HazelcastClient.newHazelcastClient( clientConfig );
String instanceName = instance.getName();

CachingProvider cachingProvider = Caching.getCachingProvider();

// Create Properties instance pointing to a named HazelcastInstance
Properties properties = new Properties();
properties.setProperty( HazelcastCachingProvider.HAZELCAST_INSTANCE_NAME,
     instanceName );

URI cacheManagerName = new URI( "my-cache-manager" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null, properties );</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is an example using <code>HazelcastCachingProvider.propertiesByInstanceName()</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.setInstanceName( "my-named-hazelcast-instance" );
// Create a named HazelcastInstance
Hazelcast.newHazelcastInstance( config );

CachingProvider cachingProvider = Caching.getCachingProvider();

// Create Properties instance pointing to a named HazelcastInstance
Properties properties = HazelcastCachingProvider
    .propertiesByInstanceName( "my-named-hazelcast-instance" );

URI cacheManagerName = new URI( "my-cache-manager" );
CacheManager cacheManager = cachingProvider
    .getCacheManager( cacheManagerName, null, properties );</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The <code>instanceName</code> will not be a part of the resulting identity of
the <code>CacheManager</code>.
An attempt to create a <code>CacheManager</code> with a different set of properties
but an already used name will result in undefined behavior.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_binding_to_an_existing_hazelcast_instance_object"><a class="anchor" href="#_binding_to_an_existing_hazelcast_instance_object"></a>Binding to an Existing Hazelcast Instance Object</h4>
<div class="paragraph">
<p>When an existing <code>HazelcastInstance</code> object is available, it can be
passed to the <code>CacheManager</code> by setting the property
<code>HazelcastCachingProvider#HAZELCAST_INSTANCE_ITSELF</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a member HazelcastInstance
HazelcastInstance instance = Hazelcast.newHazelcastInstance();

Properties properties = new Properties();
properties.put( HazelcastCachingProvider.HAZELCAST_INSTANCE_ITSELF,
     instance );

CachingProvider cachingProvider = Caching.getCachingProvider();
// cacheManager initialized for uri will be bound to instance
CacheManager cacheManager = cachingProvider.getCacheManager(uri, classLoader, properties);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_namespacing"><a class="anchor" href="#_namespacing"></a>Namespacing</h3>
<div class="paragraph">
<p>The <code>java.net.URI</code>s that don&#8217;t use the above-mentioned
Hazelcast-specific schemes are recognized as namespacing. Those
<code>CacheManager</code>s share the same underlying default <code>HazelcastInstance</code>
created (or set) by the <code>CachingProvider</code>, but they cache with the
same names and different namespaces on the <code>CacheManager</code> level, and
therefore they won&#8217;t share the same data. This is useful where multiple
applications might share the same Hazelcast JCache implementation, e.g.,
on application or OSGi servers, but are developed by
independent teams. To prevent interfering on caches using the same name,
every application can use its own namespace when
retrieving the <code>CacheManager</code>.</p>
</div>
<div class="paragraph">
<p>Here is an example of using namespacing.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider cachingProvider = Caching.getCachingProvider();

URI nsApp1 = new URI( "application-1" );
CacheManager cacheManagerApp1 = cachingProvider.getCacheManager( nsApp1, null );

URI nsApp2 = new URI( "application-2" );
CacheManager cacheManagerApp2 = cachingProvider.getCacheManager( nsApp2, null );</code></pre>
</div>
</div>
<div class="paragraph">
<p>That way both applications share the same <code>HazelcastInstance</code> instance but not the same caches.</p>
</div>
</div>
<div class="sect2">
<h3 id="_retrieving_an_icache_instance"><a class="anchor" href="#_retrieving_an_icache_instance"></a>Retrieving an ICache Instance</h3>
<div class="paragraph">
<p>Besides <a href="#scoping-to-join-clusters">Scoping to Join Clusters</a> and
<a href="#namespacing">Namespacing</a>, which are implemented using the URI feature of the
specification, all other extended operations are required to retrieve the
<code>com.hazelcast.cache.ICache</code> interface instance from
the JCache <code>javax.cache.Cache</code> instance. For Hazelcast, both interfaces are
implemented on the same object instance. It
is recommended that you stay with the specification method to retrieve the
<code>ICache</code> version, since <code>ICache</code> might be subject to change without notification.</p>
</div>
<div class="paragraph">
<p>To retrieve or unwrap the <code>ICache</code> instance, you can execute the following code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CachingProvider cachingProvider = Caching.getCachingProvider();
CacheManager cacheManager = cachingProvider.getCacheManager();
Cache&lt;Object, Object&gt; cache = cacheManager.getCache( ... );

ICache&lt;Object, Object&gt; unwrappedCache = cache.unwrap( ICache.class );</code></pre>
</div>
</div>
<div class="paragraph">
<p>After unwrapping the <code>Cache</code> instance into an <code>ICache</code> instance, you have
access to all of the following operations, e.g.,
<a href="#icache-async-methods">ICache Async Methods</a> and <a href="#icache-convenience-methods">ICache Convenience Methods</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="_icache_configuration"><a class="anchor" href="#_icache_configuration"></a>ICache Configuration</h3>
<div class="paragraph">
<p>As mentioned in the <a href="#jcache-declarative-configuration">JCache Declarative
Configuration section</a>, the Hazelcast ICache extension offers
additional configuration properties over the default JCache configuration.
These additional properties include internal storage format, backup counts,
eviction policy and split-brain protection reference.</p>
</div>
<div class="paragraph">
<p>The declarative configuration for ICache is a superset of the previously
discussed JCache configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="default"&gt;
        &lt;!-- ... default cache configuration goes here ... --&gt;
        &lt;backup-count&gt;1&lt;/backup-count&gt;
        &lt;async-backup-count&gt;1&lt;/async-backup-count&gt;
        &lt;in-memory-format&gt;BINARY&lt;/in-memory-format&gt;
        &lt;eviction size="10000" max-size-policy="ENTRY_COUNT" eviction-policy="LRU" /&gt;
        &lt;partition-lost-listeners&gt;
            &lt;partition-lost-listener&gt;CachePartitionLostListenerImpl&lt;/partition-lost-listener&gt;
        &lt;/partition-lost-listeners&gt;
        &lt;split-brain-protection-ref&gt;split-brain-protection-name&lt;/split-brain-protection-ref&gt;
        &lt;disable-per-entry-invalidation-events&gt;true&lt;/disable-per-entry-invalidation-events&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    default:
      backup-count: 1
      async-backup-count: 0
      in-memory-format: BINARY
      eviction:
        size: 10000
        max-size-policy: ENTRY_COUNT
        eviction-policy: LRU
      partition-lost-listeners:
        - CachePartitionLostListenerImpl
      split-brain-protection-ref: split-brain-protection-name
      disable-per-entry-invalidation-events: true</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>backup-count</code>: Number of synchronous backups. Those backups
are executed before the mutating cache operation is finished.
The mutating operation is blocked. Its default value is 1.</p>
</li>
<li>
<p><code>async-backup-count</code>: Number of asynchronous backups. Those
backups are executed asynchronously so the mutating operation
is not blocked and it is done immediately. Its default value is 0.</p>
</li>
<li>
<p><code>in-memory-format</code>: Internal storage format. For more information,
see the <a href="#setting-in-memory-format">in-memory format section</a>.
Its default value is <code>BINARY</code>.</p>
</li>
<li>
<p><code>eviction</code>: Defines the used eviction strategies and sizes for
the cache. For more information on eviction, see the
<a href="#jcache-eviction">JCache Eviction section</a>.</p>
<div class="ulist">
<ul>
<li>
<p><code>size</code>: Maximum number of records or maximum size in bytes
depending on the <code>max-size-policy</code> property. Size can be any
integer between <code>0</code> and <code>Integer.MAX_VALUE</code>. The default <code>max-size-policy</code>
is <code>ENTRY_COUNT</code> and its default size is <code>10.000</code>.</p>
</li>
<li>
<p><code>max-size-policy</code>: Maximum size. If maximum size is reached, the cache
is evicted based on the eviction policy. Default <code>max-size-policy</code> is <code>ENTRY_COUNT</code>
and its default size is <code>10.000</code>. The following eviction policies are available:</p>
<div class="ulist">
<ul>
<li>
<p><code>ENTRY_COUNT</code>: Maximum number of the entries in cache. Based on this
number, Hazelcast calculates an approximate maximum size for each partition.
See the <a href="#eviction-algorithm">Eviction Algorithm section</a> for more details.
<strong>Available on heap based cache record store only.</strong></p>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_SIZE</code>: Maximum used native memory size in megabytes
per cache for each Hazelcast instance. <strong>Available on High-Density Memory cache
record store only.</strong></p>
</li>
<li>
<p><code>USED_NATIVE_MEMORY_PERCENTAGE</code>: Maximum used native memory size percentage
per cache for each Hazelcast instance. <strong>Available on High-Density Memory cache record store only.</strong></p>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_SIZE</code>: Minimum free native memory size in megabytes for
each Hazelcast instance. <strong>Available on High-Density Memory cache record store only.</strong></p>
</li>
<li>
<p><code>FREE_NATIVE_MEMORY_PERCENTAGE</code>: Minimum free native memory size percentage
for each Hazelcast instance. <strong>Available on High-Density Memory cache record store only.</strong></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>eviction-policy</code>: Eviction policy that compares values to find the best
matching eviction candidate. Its default value is <code>LRU</code>.</p>
<div class="ulist">
<ul>
<li>
<p><code>LRU</code>: Less Recently Used - finds the best eviction candidate based on the <code>lastAccessTime</code>.</p>
</li>
<li>
<p><code>LFU</code>: Less Frequently Used - finds the best eviction candidate based
on the number of hits.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</li>
<li>
<p><code>partition-lost-listeners</code> : Defines listeners for dispatching partition lost events
for the cache. For more information, see the <a href="#icache-partition-lost-listener">ICache Partition Lost Listener section</a>.</p>
</li>
<li>
<p><code>split-brain-protection-ref</code> : Name of the split-brain protection configuration that you want this cache to use.</p>
</li>
<li>
<p><code>disable-per-entry-invalidation-events</code> : Disables invalidation events for
each entry; but full-flush invalidation events are still enabled. Full-flush
invalidation means the invalidation of events for all entries when <code>clear</code>
is called. Its default value is <code>false</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Since <code>javax.cache.configuration.MutableConfiguration</code> misses the above
additional configuration properties, Hazelcast ICache extension
provides an extended configuration class called <code>com.hazelcast.config.CacheConfig</code>.
This class is an implementation of <code>javax.cache.configuration.CompleteConfiguration</code>
and all the properties shown above can be configured
using its corresponding setter methods.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
ICache can be configured only programmatically on the client side.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_icache_async_methods"><a class="anchor" href="#_icache_async_methods"></a>ICache Async Methods</h4>
<div class="paragraph">
<p>As another addition of Hazelcast ICache over the normal JCache specification,
Hazelcast provides asynchronous versions of almost
all methods, returning a <code>java.util.concurrent.CompletionStage</code>. By using these
methods and the returned objects, you can use JCache in a reactive way by
registering dependent computation stages on the returned <code>CompletionStage</code>
to prevent blocking the current thread.</p>
</div>
<div class="paragraph">
<p>The asynchronous versions of the methods append the phrase <code>Async</code> to the method
name. The example code below uses the method <code>putAsync()</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ICache&lt;Integer, String&gt; unwrappedCache = cache.unwrap(ICache.class);
CompletionStage&lt;String&gt; stage = unwrappedCache.getAndPutAsync(1, "value");
stage.thenAcceptAsync(v -&gt; System.out.println("Previous value: " + v));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Following methods
are available in asynchronous versions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>get(key)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAsync(key)</code></p>
</li>
<li>
<p><code>getAsync(key, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>put(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>putAsync(key, value)</code></p>
</li>
<li>
<p><code>putAsync(key, value, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>putIfAbsent(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>putIfAbsentAsync(key, value)</code></p>
</li>
<li>
<p><code>putIfAbsentAsync(key, value, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>getAndPut(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAndPutAsync(key, value)</code></p>
</li>
<li>
<p><code>getAndPutAsync(key, value, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>remove(key)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>removeAsync(key)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>remove(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>removeAsync(key, value)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>getAndRemove(key)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAndRemoveAsync(key)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>replace(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>replaceAsync(key, value)</code></p>
</li>
<li>
<p><code>replaceAsync(key, value, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>replace(key, oldValue, newValue)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>replaceAsync(key, oldValue, newValue)</code></p>
</li>
<li>
<p><code>replaceAsync(key, oldValue, newValue, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>getAndReplace(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAndReplaceAsync(key, value)</code></p>
</li>
<li>
<p><code>getAndReplaceAsync(key, value, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The methods with a given <code>javax.cache.expiry.ExpiryPolicy</code> are further discussed in the
<a href="#defining-a-custom-expirypolicy">Defining a Custom ExpiryPolicy</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Asynchronous versions of the methods are not compatible with synchronous events.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_defining_a_custom_expirypolicy"><a class="anchor" href="#_defining_a_custom_expirypolicy"></a>Defining a Custom ExpiryPolicy</h4>
<div class="paragraph">
<p>The JCache specification has an option to configure a single <code>ExpiryPolicy</code>
per cache. Hazelcast ICache extension
offers the possibility to define a custom <code>ExpiryPolicy</code> per key by providing
a set of method overloads with an <code>expirePolicy</code>
parameter, as in the list of asynchronous methods in the <a href="#icache-async-methods">Async Methods section</a>. This means that you can pass custom expiry policies to
a cache operation.</p>
</div>
<div class="paragraph">
<p>Here is how an <code>ExpiryPolicy</code> is set on JCache configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CompleteConfiguration&lt;String, String&gt; config =
    new MutableConfiguration&lt;String, String&gt;()
        .setExpiryPolicyFactory(
            AccessedExpiryPolicy.factoryOf( Duration.ONE_MINUTE )
        );</code></pre>
</div>
</div>
<div class="paragraph">
<p>To pass a custom <code>ExpiryPolicy</code>, a set of overloads is provided. You can use
them as shown in the following code example.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ICache&lt;Integer, String&gt; unwrappedCache = cache.unwrap( ICache.class );
unwrappedCache.put( 1, "value", new AccessedExpiryPolicy( Duration.ONE_DAY ) );</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ExpiryPolicy</code> instance can be pre-created, cached and re-used, but only for
each cache instance. This is because <code>ExpiryPolicy</code>
implementations can be marked as <code>java.io.Closeable</code>. The following list shows
the provided method overloads over <code>javax.cache.Cache</code>
by <code>com.hazelcast.cache.ICache</code> featuring the <code>ExpiryPolicy</code> parameter:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>get(key)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>get(key, expiryPolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>getAll(keys)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAll(keys, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>put(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>put(key, value, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>getAndPut(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAndPut(key, value, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>putAll(map)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>putAll(map, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>putIfAbsent(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>putIfAbsent(key, value, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>replace(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>replace(key, value, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>replace(key, oldValue, newValue)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>replace(key, oldValue, newValue, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
<li>
<p><code>getAndReplace(key, value)</code>:</p>
<div class="ulist">
<ul>
<li>
<p><code>getAndReplace(key, value, expirePolicy)</code></p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Asynchronous method overloads are not listed here. See the <a href="#icache-async-methods">ICache Async Methods section</a> for the list of asynchronous method overloads.</p>
</div>
<div class="paragraph">
<p>ICache also offers <code>setExpiryPolicy(key, expirePolicy)</code> method to associate certain
keys with custom expiry policies.
Per key expiry policies defined by this method take precedence over cache policies,
but they are overridden by the expiry policies specified in above mentioned overloaded methods.</p>
</div>
</div>
<div class="sect3">
<h4 id="_jcache_eviction"><a class="anchor" href="#_jcache_eviction"></a>JCache Eviction</h4>
<div class="paragraph">
<p>Caches are generally not expected to grow to an infinite size. Implementing an
<a href="#defining-a-custom-expirypolicy">expiry policy</a> is one way you can
prevent infinite growth, but sometimes it is hard to define a meaningful expiration
timeout. Therefore, Hazelcast JCache provides the eviction feature. Eviction offers
the possibility of removing entries based on the cache size or amount of used memory
(Hazelcast IMDG Enterprise Only) and not based on timeouts.</p>
</div>
<div class="sect4">
<h5 id="_eviction_and_runtime"><a class="anchor" href="#_eviction_and_runtime"></a>Eviction and Runtime</h5>
<div class="paragraph">
<p>Since a cache is designed for high throughput and fast reads, Hazelcast put
a lot of effort into designing the eviction system to be as
predictable as possible. All built-in implementations provide an amortized O(1) runtime.
The default operation runtime is
rendered as O(1), but it can be faster than the normal runtime cost if the algorithm
finds an expired entry while sampling.</p>
</div>
</div>
<div class="sect4">
<h5 id="_cache_types"><a class="anchor" href="#_cache_types"></a>Cache Types</h5>
<div class="paragraph">
<p>Most importantly, typical production systems have two common types of caches:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Reference Caches</strong>: Caches for reference data are normally small and
are used to speed up the de-referencing as a lookup table. Those
caches are commonly tend to be small and contain a previously known,
fixed number of elements, e.g., states of the USA or
abbreviations of elements.</p>
</li>
<li>
<p><strong>Active DataSet Caches</strong>:  The other type of caches normally caches
an active data set. These caches run to their maximum
size and evict the oldest or not frequently used entries to keep in memory
bounds. They sit in front of a database or HTML
generators to cache the latest requested data.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Hazelcast JCache eviction supports both types of caches using a slightly
different approach based on the configured maximum size
of the cache. For detailed information, see the <a href="#eviction-algorithm">Eviction Algorithm section</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_configuring_eviction_policies"><a class="anchor" href="#_configuring_eviction_policies"></a>Configuring Eviction Policies</h5>
<div class="paragraph">
<p>Hazelcast JCache provides two commonly known eviction policies, LRU and LFU,
but loosens the rules for predictable runtime
behavior. LRU, normally recognized as <code>Least Recently Used</code>, is implemented
as <code>Less Recently Used</code> and LFU known as <code>Least Frequently Used</code> is implemented as
<code>Less Frequently Used</code>. The details about this difference are explained in the
<a href="#eviction-algorithm">Eviction Algorithm section</a>.</p>
</div>
<div class="paragraph">
<p>Eviction Policies are configured by providing the corresponding abbreviation
to the configuration as shown in the <a href="#icache-configuration">ICache Configuration
section</a>. As already mentioned, two built-in policies are available:</p>
</div>
<div class="paragraph">
<p>To configure the use of the LRU (Less Recently Used) policy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;eviction size="10000" max-size-policy="ENTRY_COUNT" eviction-policy="LRU" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>And to configure the use of the LFU (Less Frequently Used) policy:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>&lt;eviction size="10000" max-size-policy="ENTRY_COUNT" eviction-policy="LFU" /&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The default eviction policy is LRU. Therefore, Hazelcast JCache does not offer
the possibility of performing no eviction.</p>
</div>
<div class="sect5">
<h6 id="_custom_eviction_policies"><a class="anchor" href="#_custom_eviction_policies"></a>Custom Eviction Policies</h6>
<div class="paragraph">
<p>Besides the out-of-the-box eviction policies LFU and LRU, you can also specify
your custom eviction policies
through the eviction configuration either programmatically or declaratively.</p>
</div>
<div class="paragraph">
<p>You can provide your <code>com.hazelcast.cache.CacheEvictionPolicyComparator</code>
implementation to compare <code>com.hazelcast.cache.CacheEntryView</code>s. Supplied
<code>CacheEvictionPolicyComparator</code> is used to compare cache entry views to
select the one with higher priority to evict.</p>
</div>
<div class="paragraph">
<p>Here is an example for custom eviction policy comparator implementation for JCache:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyCacheEvictionPolicyComparator
        implements CacheEvictionPolicyComparator&lt;Long, String&gt; {

    @Override
    public int compare(CacheEntryView&lt;Long, String&gt; e1, CacheEntryView&lt;Long, String&gt; e2) {
        long id1 = e1.getKey();
        long id2 = e2.getKey();

        if (id1 &gt; id2) {
            // first entry has higher priority to be evicted
            return -1;
        }

        if (id1 &lt; id2) {
            // second entry has higher priority to be evicted
            return  1;
        }

        // both entries have same priority
        return 0;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Custom eviction policy comparator can be specified through the eviction configuration
by giving the full class name of the <code>EvictionPolicyComparator</code>
(<code>CacheEvictionPolicyComparator</code> for JCache and its Near Cache)
implementation or by specifying its instance itself.</p>
</div>
<div class="paragraph">
<p><strong>Programmatic Configuration:</strong></p>
</div>
<div class="paragraph">
<p>You can specify the full class name of custom <code>EvictionPolicyComparator</code>
(<code>CacheEvictionPolicyComparator</code> for JCache and its Near Cache) implementation
through <code>EvictionConfig</code>. This approach is useful when the eviction configuration
is specified on the client side
and the custom <code>EvictionPolicyComparator</code> implementation class itself does not
exist on the client but on the member side.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CacheConfig cacheConfig = new CacheConfig();
...
EvictionConfig evictionConfig =
    new EvictionConfig(50000,
                       MaxSizePolicy.ENTRY_COUNT,
                       "com.mycompany.MyEvictionPolicyComparator");
cacheConfig.setEvictionConfig(evictionConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can specify the custom <code>EvictionPolicyComparator</code> (<code>CacheEvictionPolicyComparator</code>
for JCache and its Near Cache) instance itself directly through <code>EvictionConfig</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CacheConfig cacheConfig = new CacheConfig();
...
EvictionConfig evictionConfig =
    new EvictionConfig(50000,
                       MaxSizePolicy.ENTRY_COUNT,
                       new MyEvictionPolicyComparator());
cacheConfig.setEvictionConfig(evictionConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Declarative Configuration:</strong></p>
</div>
<div class="paragraph">
<p>You can specify the full class name of custom <code>EvictionPolicyComparator</code>
(<code>CacheEvictionPolicyComparator</code> for JCache and its Near Cache) implementation
in the <code>&lt;eviction&gt;</code> tag through <code>comparator-class-name</code> or <code>comparator-bean</code> attributes in Hazelcast
configuration files:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;cache name="cacheWithCustomEvictionPolicyComparator"&gt;
        &lt;eviction size="50000" max-size-policy="ENTRY_COUNT" comparator-class-name="com.mycompany.MyEvictionPolicyComparator"/&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cache:
    cacheWithCustomEvictionPolicyComparator:
      eviction:
        size: 50000
        max-size-policy: ENTRY_COUNT
      expiry-policy-factory:
        class-name: com.mycompany.MyEvictionPolicyComparator</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Spring</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hz:cache name="cacheWithCustomEvictionPolicyComparator"&gt;
    &lt;hz:eviction size="50000" max-size-policy="ENTRY_COUNT" comparator-class-name="com.mycompany.MyEvictionPolicyComparator"/&gt;
&lt;/hz:cache&gt;</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_eviction_strategy"><a class="anchor" href="#_eviction_strategy"></a>Eviction Strategy</h5>
<div class="paragraph">
<p>Eviction strategies implement the logic of selecting one or more
eviction candidates from the underlying storage implementation and
passing them to the eviction policies. Hazelcast JCache provides an
amortized O(1) cost implementation for this strategy to select a
fixed number of samples from the current partition that it is executed against.</p>
</div>
<div class="paragraph">
<p>The default implementation is <code>com.hazelcast.cache.impl.eviction.impl.strategy.sampling.SamplingBasedEvictionStrategy</code> which, as
mentioned, samples 15 random elements. A detailed description
of the algorithm will be explained in the next section.</p>
</div>
</div>
<div class="sect4">
<h5 id="_eviction_algorithm"><a class="anchor" href="#_eviction_algorithm"></a>Eviction Algorithm</h5>
<div class="paragraph">
<p>The Hazelcast JCache eviction algorithm is specially designed for
the use case of high performance caches and with predictability
in mind. The built-in implementations provide an amortized O(1)
runtime and therefore provide a highly predictable runtime behavior
which does not rely on any kind of background threads to handle the eviction.
Therefore, the algorithm takes some assumptions into
account to prevent network operations and concurrent accesses.</p>
</div>
<div class="paragraph">
<p>As an explanation of how the algorithm works, let&#8217;s examine the following
flowchart step by step.</p>
</div>
<div class="paragraph">
<p><span class="image"><img src="../_images/EvictionFlowchart.png" alt="Hazelcast JCache Eviction Algorithm"></span></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>A new cache is created. Without any special settings, the eviction
is configured to kick in when the <strong>cache</strong> exceeds 10.000
elements and an LRU (Less Recently Used) policy is set up.</p>
</li>
<li>
<p>The user puts in a new entry, e.g., a key-value pair.</p>
</li>
<li>
<p>For every put, the eviction strategy evaluates the current cache
size and decides if an eviction is necessary or not. If not, the entry is stored in step 10.</p>
</li>
<li>
<p>If eviction is required, a new sampling is started. The built-in
sampler is implemented as a lazy iterator.</p>
</li>
<li>
<p>The sampling algorithm selects a random sample from the underlying data storage.</p>
</li>
<li>
<p>The eviction strategy tests whether the sampled entry is already
expired (lazy expiration). If expired, the sampling stops and the entry is removed in step 9.</p>
</li>
<li>
<p>If not yet expired, the entry (eviction candidate) is compared to
the last best matching candidate (based on the eviction policy) and the
new best matching candidate is remembered.</p>
</li>
<li>
<p>The sampling is repeated 15 times and then the best matching eviction
candidate is returned to the eviction strategy.</p>
</li>
<li>
<p>The expired or best matching eviction candidate is removed from the
underlying data storage.</p>
</li>
<li>
<p>The new put entry is stored.</p>
</li>
<li>
<p>The put operation returns to the user.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that expiration based eviction does not only occur for the
above scenario (Step 6). It is mentioned for the sake of explaining the eviction algorithm.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>As seen in the flowchart, the general eviction operation is easy.
As long as the cache does not reach its maximum capacity,
or you execute updates (put/replace), no eviction is executed.</p>
</div>
<div class="paragraph">
<p>To prevent network operations and concurrent access, as mentioned earlier,
the cache size is estimated based on the size of the
currently handled partition. Due to the imbalanced partitions, the single
partitions might start to evict
earlier than the other partitions.</p>
</div>
<div class="paragraph">
<p>As mentioned in the <a href="#cache-types">Cache Types section</a>, typically two types
of caches are found in the production systems. For small caches,
referred to as <strong>Reference Caches</strong>, the eviction algorithm has a special set
of rules depending on the maximum configured cache
size. See the <a href="#reference-caches">Reference Caches section</a> for details.
The other type of cache is referred to as an <strong>Active DataSet Cache</strong>,
which in most cases makes heavy use of the eviction to keep the most active
data set in the memory. Those kinds of caches use a very
simple but efficient way to estimate the cluster-wide cache size.</p>
</div>
<div class="paragraph">
<p>All of the following calculations have a well known set of fixed variables:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>GlobalCapacity</code>: User defined maximum cache size (cluster-wide).</p>
</li>
<li>
<p><code>PartitionCount</code>: Number of partitions in the cluster (defaults to 271).</p>
</li>
<li>
<p><code>BalancedPartitionSize</code>: Number of elements in a balanced partition state,
<code>BalancedPartitionSize := GlobalCapacity / PartitionCount</code>.</p>
</li>
<li>
<p><code>Deviation</code>: An approximated standard deviation (tests proofed it to be
pretty near), <code>Deviation := sqrt(BalancedPartitionSize)</code>.</p>
</li>
</ul>
</div>
<div class="sect5">
<h6 id="_reference_caches"><a class="anchor" href="#_reference_caches"></a>Reference Caches</h6>
<div class="paragraph">
<p>A Reference Cache is typically small and the number of elements
to store in the reference caches is normally
known prior to creating the cache. Typical examples of reference
caches are lookup tables for abbreviations or the states of a
country. They tend to have a fixed but small element number and
the eviction is an unlikely event and rather undesirable behavior.</p>
</div>
<div class="paragraph">
<p>Since an imbalanced partition is a worse problem in small and mid-sized
caches than in caches with millions of entries, the normal
estimation rule (as discussed in a bit) is not applied to these kinds
of caches. To prevent unwanted eviction on the small and
mid-sized caches, Hazelcast implements a special set of rules to estimate
the cluster size.</p>
</div>
<div class="paragraph">
<p>To adjust the imbalance of partitions as found in the typical runtime,
the actual calculated maximum cache size (known as the eviction
threshold) is slightly higher than the user defined size. That means more
elements can be stored into the cache
than expected by the user. This needs to be taken into account especially
for large objects, since those can easily exceed the
expected memory consumption!</p>
</div>
<div class="paragraph">
<p><strong>Small caches:</strong></p>
</div>
<div class="paragraph">
<p>If a cache is configured with no more than <code>4.000</code> elements, this cache
is considered to be a small cache. The actual partition
size is derived from the number of elements (<code>GlobalCapacity</code>) and
the deviation using the following formula:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>MaxPartitionSize := Deviation * 5 + BalancedPartitionSize</code></pre>
</div>
</div>
<div class="paragraph">
<p>This formula ends up with big partition sizes which, summed up,
exceed the expected maximum cache size (set by the user).
Since the small caches typically have a well known maximum number
of elements, this is not a big
issue. Only if the small caches are used for a use case other than
as a reference cache, this needs to be taken into account.</p>
</div>
<div class="paragraph">
<p><strong>Mid-sized caches</strong></p>
</div>
<div class="paragraph">
<p>A mid-sized cache is defined as a cache with a maximum number of
elements that is bigger than <code>4.000</code> but not bigger than
<code>1.000.000</code> elements. The calculation of mid-sized caches is similar
to that of the small caches but with a different
multiplier. To calculate the maximum number of elements per partition,
the following formula is used:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>MaxPartitionSize := Deviation * 3 + BalancedPartitionSize</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_active_dataset_caches"><a class="anchor" href="#_active_dataset_caches"></a>Active DataSet Caches</h6>
<div class="paragraph">
<p>For large caches, where the maximum cache size is bigger than
<code>1.000.000</code> elements, there is no additional calculation needed. The maximum
partition size is considered to be equal to <code>BalancedPartitionSize</code>
since statistically big partitions are expected to almost
balance themselves. Therefore, the formula is as easy as the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>MaxPartitionSize := BalancedPartitionSize</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="_cache_size_estimation"><a class="anchor" href="#_cache_size_estimation"></a>Cache Size Estimation</h6>
<div class="paragraph">
<p>As mentioned earlier, Hazelcast JCache provides an estimation algorithm
to prevent cluster-wide network operations, concurrent
access to other partitions and background tasks. It also offers a highly
predictable operation runtime when the eviction is necessary.</p>
</div>
<div class="paragraph">
<p>The estimation algorithm is based on the previously calculated maximum
partition size (see the <a href="#reference-caches">Reference Caches</a> and
<a href="#active-dataset-caches">Active DataSet Caches</a> sections) and is calculated
against the current partition only.</p>
</div>
<div class="paragraph">
<p>The algorithm to reckon the number of stored entries in the cache
(cluster-wide) and decide if the eviction is necessary is shown in the
following pseudo-code example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>RequiresEviction[Boolean] := CurrentPartitionSize &gt;= MaxPartitionSize</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_jcache_near_cache"><a class="anchor" href="#_jcache_near_cache"></a>JCache Near Cache</h4>
<div class="paragraph">
<p>The Hazelcast JCache implementation supports a local Near Cache for remotely
stored entries to increase the performance of local read operations. See the <a href="#near-cache">Near Cache section</a> for a detailed explanation of the Near Cache feature and its configuration.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Near Cache for JCache is only available for clients, NOT members.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_icache_convenience_methods"><a class="anchor" href="#_icache_convenience_methods"></a>ICache Convenience Methods</h4>
<div class="paragraph">
<p>In addition to the operations explained in <a href="#icache-async-methods">ICache Async Methods</a>
and <a href="#defining-a-custom-expirypolicy">Defining a Custom ExpiryPolicy</a>, Hazelcast ICache
also provides a set of convenience methods. These methods are not part of the JCache specification.</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>size()</code>: Returns the total entry count of the distributed cache.</p>
</li>
<li>
<p><code>destroy()</code>: Destroys the cache and removes its data, which makes it different from the
method <code>javax.cache.Cache.close()</code>; the <code>close</code> method closes the cache so no further
operational methods (get, put, remove, etc. See Section 4.1.6 in JCache Specification which
can be downloaded from <a href="http://download.oracle.com/otndocs/jcp/jcache-1_0-fr-eval-spec/index.html" target="_blank" rel="noopener">here</a>)
can be executed on it - data is not necessarily destroyed, if you get again the same <code>Cache</code> from the
same <code>CacheManager</code>, the data will be there. In the case of <code>destroy()</code>, both the cache is
destroyed and cache&#8217;s data is removed.</p>
</li>
<li>
<p><code>isDestroyed()</code>: Determines whether the ICache instance is destroyed or not.</p>
</li>
<li>
<p><code>getLocalCacheStatistics()</code>: Returns a <code>com.hazelcast.cache.CacheStatistics</code> instance,
both on Hazelcast members and clients, providing the same statistics data as the JMX beans.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>See the <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/cache/ICache.html" target="_blank" rel="noopener">ICache Javadoc</a>
to see all the methods provided by ICache.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementing_backupawareentryprocessor"><a class="anchor" href="#_implementing_backupawareentryprocessor"></a>Implementing BackupAwareEntryProcessor</h4>
<div class="paragraph">
<p>Another feature, especially interesting for distributed environments
like Hazelcast, is the JCache specified
<code>javax.cache.processor.EntryProcessor</code>. For more general information,
see the <a href="#implementing-entryprocessor">Implementing EntryProcessor section</a>.</p>
</div>
<div class="paragraph">
<p>Since Hazelcast provides backups of cached entries on other members,
the default way to backup an object changed by an
<code>EntryProcessor</code> is to serialize the complete object and send it to the
backup partition. This can be a huge network overhead for big objects.</p>
</div>
<div class="paragraph">
<p>Hazelcast offers a sub-interface for <code>EntryProcessor</code> called
<code>com.hazelcast.cache.BackupAwareEntryProcessor</code>. This allows
you to create or pass another <code>EntryProcessor</code> to run on backup
partitions and apply delta changes to the backup entries.</p>
</div>
<div class="paragraph">
<p>The backup partition <code>EntryProcessor</code> can either be the currently
running processor (by returning <code>this</code>) or it can be
a specialized <code>EntryProcessor</code> implementation (different from the
currently running one) that does different operations or leaves
out operations, e.g., sending emails.</p>
</div>
<div class="paragraph">
<p>If we again take the <code>EntryProcessor</code> example from the
demonstration application provided in the <a href="#implementing-entryprocessor">Implementing EntryProcessor section</a>,
the changed code looks like the following snippet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class UserUpdateEntryProcessor
    implements BackupAwareEntryProcessor&lt;Integer, User, User&gt; {

    @Override
    public User process( MutableEntry&lt;Integer, User&gt; entry, Object... arguments )
        throws EntryProcessorException {

        // Test arguments length
        if ( arguments.length &lt; 1 ) {
            throw new EntryProcessorException( "One argument needed: username" );
        }

        // Get first argument and test for String type
        Object argument = arguments[0];
        if ( !( argument instanceof String ) ) {
            throw new EntryProcessorException(
            "First argument has wrong type, required java.lang.String" );
        }

        // Retrieve the value from the MutableEntry
        User user = entry.getValue();

        // Retrieve the new username from the first argument
        String newUsername = ( String ) arguments[0];

        // Set the new username
        user.setUsername( newUsername );

        // Set the changed user to mark the entry as dirty
        entry.setValue( user );

        // Return the changed user to return it to the caller
        return user;
    }

    public EntryProcessor&lt;Integer, User, User&gt; createBackupEntryProcessor() {
        return this;
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can use the additional method
<code>BackupAwareEntryProcessor.createBackupEntryProcessor()</code>
to create or return the <code>EntryProcessor</code>
implementation to run on the backup partition (in the
example above, the same processor again).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
For the backup runs, the returned value from the
backup processor is ignored and not
returned to the user.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_icache_partition_lost_listener"><a class="anchor" href="#_icache_partition_lost_listener"></a>ICache Partition Lost Listener</h4>
<div class="paragraph">
<p>You can listen to <code>CachePartitionLostEvent</code> instances
by registering an implementation
of <code>CachePartitionLostListener</code>, which is also a
sub-interface of <code>java.util.EventListener</code>
from <code>ICache</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s consider the following example code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class PartitionLostListenerUsage {


    public static void main(String[] args) {

        String cacheName1 = "myCache1";

        CachingProvider cachingProvider = Caching.getCachingProvider();
        CacheManager cacheManager = cachingProvider.getCacheManager();

        CacheConfig&lt;Integer, String&gt; config1 = new CacheConfig&lt;Integer, String&gt;();
        Cache&lt;Integer, String&gt; cache1 = cacheManager.createCache(cacheName1, config1);



        ICache&lt;Object, Object&gt; unwrappedCache = cache1.unwrap( ICache.class );

        unwrappedCache.addPartitionLostListener(new CachePartitionLostListener() {
            @Override
            public void partitionLost(CachePartitionLostEvent event) {
                System.out.println(event);
            }
        });
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Within this example code, a <code>CachePartitionLostListener</code> implementation
is registered to a cache and assumes that this cache is configured with
one backup. For this particular cache and any of the partitions in the
system, if the partition owner member and its first backup member
crash simultaneously, the
given <code>CachePartitionLostListener</code> receives a
corresponding <code>CachePartitionLostEvent</code>. If only a single member
crashes in the cluster,
a <code>CachePartitionLostEvent</code> is not fired for this cache since
backups for the partitions
owned by the crashed member are kept on other members.</p>
</div>
<div class="paragraph">
<p>See the <a href="#listening-for-partition-lost-events">Partition Lost Listener section</a> for more
information about partition lost detection and partition lost events.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_testing_for_jcache_specification_compliance"><a class="anchor" href="#_testing_for_jcache_specification_compliance"></a>Testing for JCache Specification Compliance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Hazelcast JCache is fully compliant with the JSR 107 TCK
(Technology Compatibility Kit), and therefore is officially a JCache
implementation.</p>
</div>
<div class="paragraph">
<p>You can test Hazelcast JCache for compliance by executing the TCK.
Just perform the instructions below:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Checkout tag <code>1.1.1</code> of the TCK from
<a href="https://github.com/jsr107/jsr107tck/releases/tag/1.1.1" target="_blank" rel="noopener">https://github.com/jsr107/jsr107tck</a>.</p>
</li>
<li>
<p>Change the properties in <a href="https://github.com/jsr107/jsr107tck/blob/master/pom.xml" target="_blank" rel="noopener">pom.xml</a>
as shown below. Alternatively, you can set the values of these properties directly on the
maven command line without editing any files as shown in the command line example below.</p>
</li>
<li>
<p>Run the TCK using the command <code>mvn clean install</code>. This runs the tests using an
embedded Hazelcast member.</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;properties&gt;
    &lt;jcache.version&gt;1.1.1&lt;/jcache.version&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;

    &lt;CacheInvocationContextImpl&gt;
        javax.cache.annotation.impl.cdi.CdiCacheKeyInvocationContextImpl
    &lt;/CacheInvocationContextImpl&gt;

    &lt;domain-lib-dir&gt;${project.build.directory}/domainlib&lt;/domain-lib-dir&gt;
    &lt;domain-jar&gt;domain.jar&lt;/domain-jar&gt;


    &lt;!-- ################################################################# --&gt;
    &lt;!-- Change the following properties on the command line
       to override with the coordinates for your implementation--&gt;
    &lt;implementation-groupId&gt;com.hazelcast&lt;/implementation-groupId&gt;
    &lt;implementation-artifactId&gt;hazelcast&lt;/implementation-artifactId&gt;
    &lt;implementation-version&gt;3.10&lt;/implementation-version&gt;

    &lt;!-- Change the following properties to your CacheManager and
       Cache implementation. Used by the unwrap tests. --&gt;
    &lt;CacheManagerImpl&gt;
        com.hazelcast.client.cache.impl.HazelcastServerCacheManager
    &lt;/CacheManagerImpl&gt;
    &lt;CacheImpl&gt;com.hazelcast.cache.ICache&lt;/CacheImpl&gt;
    &lt;CacheEntryImpl&gt;
        com.hazelcast.cache.impl.CacheEntry
    &lt;/CacheEntryImpl&gt;
    &lt;!-- ################################################################# --&gt;
&lt;/properties&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Complete command line example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-sh hljs" data-lang="sh">$ git clone https://github.com/jsr107/jsr107tck
(clones JSR107 TCK repository to local directory jsr107tck)

$ cd jsr107tck

$ git checkout 1.1.1
(checkout 1.1.1 tag)

$ mvn -Dimplementation-groupId=com.hazelcast -Dimplementation-artifactId=hazelcast \
     -Dimplementation-version=3.10 \
     -DCacheManagerImpl=com.hazelcast.cache.impl.HazelcastServerCacheManager \
     -DCacheImpl=com.hazelcast.cache.ICache -DCacheEntryImpl=com.hazelcast.cache.impl.CacheEntry \
     clean install</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the <a href="https://docs.google.com/document/d/1m8d1Z44IFGAd20bXEvT2G--vWXbxaJctk16M2rmbM24/edit?ts=59fdff73" target="_blank" rel="noopener">TCK 1.1.0 User Guide</a> or <a href="https://docs.google.com/document/d/1w3Ugj_oEqjMlhpCkGQOZkd9iPf955ZWHAVdZzEwYYdU/edit" target="_blank" rel="noopener">TCK 1.0.0 User Guide</a>
for more information on the testing instructions.</p>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/develop/jcache.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
