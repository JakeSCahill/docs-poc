<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>WAN Replication Hazelcast Documentation</title>
    <link rel="canonical" href="https://JakeSCahill.github.io/hazelcast/4.1/deploy/wan.html">
    <meta name="generator" content="Antora 2.3.4">
    <link rel="stylesheet" href="../../../_/css/site.css">
<link rel="stylesheet" href="../../../_/css/search.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=GTM-M267KFN"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','GTM-M267KFN')</script>
  </head>
  <body class="article">
<header class="header" role="banner">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://JakeSCahill.github.io">Hazelcast Documentation</a>
        <div class="navbar-item">
          <input id="search-input" type="text" placeholder="Search docs">
        </div>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Hazelcast IMDG</a>
            <a class="navbar-item" href="#">Hazelcast Jet</a>
            <a class="navbar-item" href="#">Hazelcast Cloud</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Use cases</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Resources</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Demos</a>
            <a class="navbar-item" href="#">GitHub</a>
            <a class="navbar-item" href="#">Community</a>
            <a class="navbar-item" href="#">Blog</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="hazelcast" data-version="4.1">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../hazelcast_overview.html">Hazelcast IMDG</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../hazelcast_overview.html">Overview</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../get-started/getting_started.html">Get Started</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../get-started/glossary.html">Glossary</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../develop/hazelcast_clients.html">Develop Solutions</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/jcache.html">JCache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/performance.html">Performance</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/serialization.html">Serialization</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/striim_cdc.html">Striim Hot Cache</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/transactions.html">Transactions</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_query.html">Distributed Query</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_sql.html">Distributed SQL</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_events.html">Distributed Events</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../develop/distributed_computing.html">Distributed Computing</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="installing_upgrading.html">Deploy Clusters</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="starting_members_clients.html">Starting Members and Clients</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="setting_up_clusters.html">Setting Up Clusters</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="management.html">Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="security.html">Security</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="simulator.html">Hazelcast Simulator</a>
  </li>
  <li class="nav-item is-current-page" data-depth="1">
    <a class="nav-link" href="wan.html">WAN Replication</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="network_partitioning.html">Network Partitioning</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../migrate/migration_guides.html">Migrate</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../troubleshoot/common_exception_types.html">Troubleshooting</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../reference/faq.html">Reference</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/dds.html">Distributed data structures</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/system_properties.html">System properties</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/understanding_configuration.html">Configuration</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/phone_homes.html">Phone homes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../reference/hazelcast_plugins.html">Plugins</a>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../contribute/extending_hazelcast.html">Contribute</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/licenses.html">Licenses</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../contribute/revision_history.html">Documentation changes</a>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Hazelcast IMDG</span>
    <span class="version">4.1</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <span class="title">Hazelcast IMDG</span>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../hazelcast_overview.html">4.1</a>
        </li>
      </ul>
    </li>
    <li class="component">
      <span class="title">Home</span>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../home/index.html">master</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../home/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../hazelcast_overview.html">Hazelcast IMDG</a></li>
    <li><a href="installing_upgrading.html">Deploy Clusters</a></li>
    <li><a href="wan.html">WAN Replication</a></li>
  </ul>
</nav>
  <div class="edit-this-page"><a class="git" href="file:///C:/Users/Jake%20Cahill/Documents/code-playground/docs/hazelcast-docs/modules/deploy/pages/wan.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<article class="doc">
<h1 class="page">WAN Replication</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p><strong class="blue">Hazelcast IMDG Enterprise Feature</strong></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction-to-wr"><a class="anchor" href="#introduction-to-wr"></a>Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>You can use Hazelcast&#8217;s WAN Replication feature when you need
to synchronize multiple Hazelcast clusters, which are connected by WANs, to the same state.
It allows replicating updates in your data structures across the clusters. For now,
Hazelcast WAN Replication supports the map and cache data structures.</p>
</div>
<div class="paragraph">
<p>Assume that you have data centers in different cities each running an independent
Hazelcast IMDG cluster. You can reliably use the WAN Replication feature
to synchronize all of these clusters by replicating the updates to each of them.</p>
</div>
<div class="paragraph">
<p>WAN Replication provides more control compared to the replication mechanism between
the members in a single cluster. It has the following features and capabilities:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It gracefully detects if there is a connectivity issue between the clusters, buffering any updates
that are not yet replicated and attempts to re-establish a connection to resume the replication.</p>
</li>
<li>
<p>It allows you to permanently pause, stop and resume the replication. This is most useful when you know
that one of the clusters is temporarily (e.g., due to an upgrade),
or permanently (e.g., due to removing a cluster out of service) unavailable.</p>
</li>
<li>
<p>It allows you to dynamically add new target clusters without any restarts.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This chapter explains how you can replicate the state of your clusters over wide area
networks through Hazelcast&#8217;s WAN Replication.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
WAN Replication is a Hazelcast IMDG Enterprise Edition feature. However,
its API is available publicly <a href="https://docs.hazelcast.org/docs/latest/javadoc/com/hazelcast/wan/package-summary.html" target="_blank" rel="noopener">here</a> and,
benefiting from it, you may write your own replication logic.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="wr-concepts"><a class="anchor" href="#wr-concepts"></a>Concepts</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s first define several important terms before we discuss WAN Replication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Active cluster: The user updates performed on the cluster are replicated to other clusters connected through
WAN Replication. In another words, this cluster can be seen as the "source" cluster which generates WAN update
events and replicates them actively to other clusters.</p>
</li>
<li>
<p>Passive cluster: The user updates performed on this cluster are not replicated to other clusters. In another words,
this cluster can be seen as the "target" cluster which is capable of receiving, applying and possibly forwarding
WAN events from other ("active") clusters. It does not generate any WAN update events because of user interaction.</p>
</li>
<li>
<p>WAN publisher: A publisher is a sink for WAN events and an implementation of <code>WanReplicationPublisher</code>.
Most often, this is a single, entire target Hazelcast IMDG cluster but you can also define custom publishers which
may transmit WAN events to other systems such as messaging queues, Kafka or even persist events on disk.</p>
</li>
<li>
<p>WAN endpoint: when a publisher is replicating events to another Hazelcast cluster, an endpoint is a single member
in that target cluster. That means that a WAN publisher replicates to multiple WAN endpoints.</p>
</li>
<li>
<p>WAN replication scheme: a named collection of WAN publishers. Hazelcast maps and caches are configured to
replicate to a WAN replication scheme, meaning that a single map/cache update can be replicated to multiple target
clusters or multiple external systems.</p>
</li>
<li>
<p>WAN publisher ID: A unique identifier for a specific WAN replication publisher in a WAN replication scheme. This
identifier can then be used to control the behavior of a WAN replication publisher while the source/active cluster is
running. For instance, you can use this identifier in combination with the WAN replication scheme name to pause, stop or
resume WAN replication for that specific publisher. Or, you can trigger synchronization with a specific target cluster
and so on.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_wan_replication_modes"><a class="anchor" href="#_wan_replication_modes"></a>WAN Replication Modes</h3>
<div class="paragraph">
<p>In clusters connected with WAN Replication, a cluster can have one of two roles:
Active or Passive, conceptually explained in the previous section above.</p>
</div>
<div class="paragraph">
<p>With these roles, there are two modes of WAN Replication:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="active-passive"></a><strong>Active-Passive:</strong> This mode can be used for failover scenarios where you want to replicate an active
cluster to one or more passive clusters, for the purpose of maintaining a backup.
If the active cluster becomes unavailable, you may redirect user traffic to the passive clusters. Once the active
cluster becomes available again, you may again redirect user traffic to the active cluster. The active cluster may have
however been started empty or might have simply missed any updates that have happened on the passive clusters.
Any updates made on the passive clusters will not be replicated back to the active cluster and if the data is out-of-sync,
it will not be synchronized. If you require that these updates be copied back to the active cluster, you may consider
using active-active mode instead.</p>
</li>
<li>
<p><a id="active-active"></a><strong>Active-Active:</strong> Every cluster is equal, each cluster replicates to all other clusters.
This is normally used to connect different clients to different clusters for the sake of
the shortest path between client and server, hence gaining increased performance. An example use case would be geographically
distributed applications.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_quick_start"><a class="anchor" href="#_quick_start"></a>Quick Start</h3>
<div class="paragraph">
<p>This section provides information on how you can
start using WAN Replication with a minimal setup for both
<a href="#active-passive">Active-Passive</a> and <a href="#active-active">Active-Active</a> modes.</p>
</div>
<div class="sect3">
<h4 id="_setting_up_an_active_passive_mode"><a class="anchor" href="#_setting_up_an_active_passive_mode"></a>Setting Up an Active-Passive Mode</h4>
<div class="paragraph">
<p>This mode usually requires configuration only on one of the clusters.
Let&#8217;s say you have two clusters, one in London and the other in Tokyo.
You want to replicate the updates between each other and use the one in Tokyo
as the active cluster.</p>
</div>
<div class="paragraph">
<p>1 - Add the following configuration example on your cluster in Tokyo:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;10.3.5.1:5701&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
    &lt;/map&gt;

&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
WanBatchPublisherConfig batchPublisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setTargetEndpoints("10.3.5.1:5701");

WanReplicationConfig wrConfig = new WanReplicationConfig()
        .setName("london-wan-rep")
        .addBatchReplicationPublisherConfig(batchPublisherConfig);

config.addWanReplicationConfig(wrConfig);

config.getMapConfig("replicatedMap").setWanReplicationRef(new WanReplicationRef().setName("london-wan-rep"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 - Start your clusters to start using Active-Passive WAN Replication.</p>
</div>
<div class="paragraph">
<p>Basically, what we did here is defining a WAN Replication configuration (<code>wan-replication</code>)
and configuring our map to use it (<code>wan-replication-ref</code>). As mentioned, this is the minimal
configuration example, which is fine for most use cases. There are more configuration options for
tuning the WAN Replication; see the <a href="#tuning-wr">Tuning WAN Replication section</a>.</p>
</div>
<div class="paragraph">
<p>In the above example, we have configured the map named <code>replicatedMap</code> to
replicate to the target cluster named <code>london</code> on a single endpoint, as specified with
the <code>target-endpoints</code> element. Notice that the name of <code>wan-replication</code>
configuration (<code>london-wan-rep</code>) is referenced in
the <code>map</code> configuration using the <code>wan-replication-ref</code> element; this is how
you make your map to use the WAN Replication feature. For now, only Hazelcast maps
and caches support this feature.</p>
</div>
<div class="paragraph">
<p>The <code>london</code> cluster might have more members than the one specified in this example, but only
that endpoint will receive the WAN events. In that case
and if you want the events to be forwarded to the other cluster members, see the <code>republishing-enabled</code>
element description in the <a href="#configuring-wan-replication-for-imap-and-icache">Configuring for IMap and ICache section</a>.</p>
</div>
<div class="paragraph">
<p>This example configuration defines a static endpoint to specify the target cluster member, using the <code>target-endpoints</code> element or <code>setTargetEndpoints()</code> method, respectively.
You can also use Hazelcast&#8217;s Discovery SPI for WAN Replication to specify endpoints on various
cloud infrastructures. See the <a href="#wanbatchreplication-discovery-spi">Using Discovery SPI section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_setting_up_an_active_active_mode"><a class="anchor" href="#_setting_up_an_active_active_mode"></a>Setting Up an Active-Active Mode</h4>
<div class="paragraph">
<p>Using the above scenario, this mode requires configuration on both clusters.</p>
</div>
<div class="paragraph">
<p>1 - Add the following configuration example on your cluster in Tokyo:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;tokyo&lt;/cluster-name&gt;
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;10.3.5.1:5701&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
    &lt;/map&gt;

&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.setClusterName("tokyo");
WanBatchPublisherConfig batchPublisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setTargetEndpoints("10.3.5.1:5701");

WanReplicationConfig wrConfig = new WanReplicationConfig()
        .setName("london-wan-rep")
        .addBatchReplicationPublisherConfig(batchPublisherConfig);

config.addWanReplicationConfig(wrConfig);

config.getMapConfig("replicatedMap").setWanReplicationRef(new WanReplicationRef().setName("london-wan-rep"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 - Add the following configuration example on your cluster in London:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;london&lt;/cluster-name&gt;
    &lt;wan-replication name="tokyo-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;tokyo&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;32.1.1.1:5701&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="tokyo-wan-rep"/&gt;
    &lt;/map&gt;

&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">Java</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
config.setClusterName("london");
WanBatchPublisherConfig batchPublisherConfig = new WanBatchPublisherConfig()
        .setClusterName("tokyo")
        .setTargetEndpoints("32.1.1.1:5701");

WanReplicationConfig wrConfig = new WanReplicationConfig()
        .setName("tokyo-wan-rep")
        .addBatchReplicationPublisherConfig(batchPublisherConfig);

config.addWanReplicationConfig(wrConfig);

config.getMapConfig("replicatedMap").setWanReplicationRef(new WanReplicationRef().setName("tokyo-wan-rep"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>3 - Start your clusters to start using Active-Active WAN Replication.</p>
</div>
<div class="paragraph">
<p>Notice the <code>cluster-name</code> configuration element (not the one under the <code>batch-publisher</code> element, but
the one under the <code>hazelcast</code> element).
These are the names specifying the IMDG members' clusters on their locals. So, the name
of the cluster in one location should be mentioned on the cluster in the other location, as shown above.</p>
</div>
<div class="paragraph">
<p>As in the Active-Passive example shown in the previous section, this example configuration
also uses a static endpoint to specify the target cluster member.
See the <a href="#wanbatchreplication-discovery-spi">Using Discovery SPI section</a> for information
on using the Discovery SPI to specify target members.</p>
</div>
<div class="paragraph">
<p>As mentioned previously, the above configurations are the minimal ones
to get you started. In case you need to configure some additional aspects of your maps or caches that use WAN Replication, see the <a href="#configuring-wan-replication-for-imap-and-icache">Configuring for IMap and ICache section</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_configuring_wan_replication"><a class="anchor" href="#_configuring_wan_replication"></a>Configuring WAN Replication</h3>
<div class="paragraph">
<p>WAN Replication is defined and configured using the <code>wan-replication</code> configuration
element as can be seen in the above examples.</p>
</div>
<div class="paragraph">
<p>In this section you learn how to establish the connection between WAN
replicated clusters and configure the behavior of WAN replication mechanism.</p>
</div>
<div class="paragraph">
<p>For establishing the connection, you have the following options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>using static endpoints (when you want to provide the IP addresses of target IMDG members)</p>
</li>
<li>
<p>using Discovery SPI (when you want to target IMDG members on various cloud infrastructures)</p>
<div class="paragraph">
<p>You can use only one of these (not both) when defining a single WAN publisher.</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The examples in this section uses Hazelcast&#8217;s built-in WAN replication implementation.
This implementation meets most of your WAN replication needs and is configured using the
<code>batch-publisher</code> element, which you will see in the below examples. Hazelcast also allows you
to build your own implementation; see the <a href="#defining-custom-wr">Advanced Features section</a>
for details in case you need more custom configurations.</p>
</div>
<div class="paragraph">
<p>The default settings for WAN Replication configuration suit most use cases. If, however, you have specific needs or if you
would like to fine-tune the behavior of WAN Replication for your application, see the
<a href="#tuning-wr">Fine-Tuning WAN Replication section</a>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see how we configure a simple WAN replication using the static endpoints and Discovery SPI, and
then let&#8217;s see the configuration details of Hazelcast&#8217;s built-in WAN replication implementation.</p>
</div>
<div class="sect3">
<h4 id="wanbatchreplication-static-endpoints"><a class="anchor" href="#wanbatchreplication-static-endpoints"></a>Using the Static Endpoints</h4>
<div class="paragraph">
<p>This is most suitable when the endpoints have static IP addresses which will not change for
the duration of the lifecycle of the source cluster. You will then list these addresses in the WAN publisher
configuration and WAN Replication will try to keep a stable connection to each of those.</p>
</div>
<div class="paragraph">
<p>Below is an example of declarative configuration of WAN Replication between two Hazelcast clusters. Here, we show the
configuration that is needed on the source ("active") cluster. In most cases, the target ("passive") cluster does not
need any kind of configuration and configuring the source cluster is enough for WAN Replication to function normally.</p>
</div>
<div class="paragraph">
<p>Here, we show the simplest working configurations to replicate to a target cluster with the cluster-name <code>london</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;10.3.5.1:5701, 10.3.5.2:5701&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        target-endpoints: 10.3.5.1:5701, 10.3.5.2:5701
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();
WanBatchPublisherConfig batchPublisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setTargetEndpoints("10.3.5.1:5701,10.3.5.2:5701");

WanConsumerConfig consumerConfig = new WanConsumerConfig()
        .setPersistWanReplicatedData(false);

WanReplicationConfig wrConfig = new WanReplicationConfig()
        .setName("london-wan-rep")
        .addBatchReplicationPublisherConfig(batchPublisherConfig)
        .setConsumerConfig(consumerConfig);

config.addWanReplicationConfig(wrConfig);

config.getMapConfig("replicatedMap").setWanReplicationRef(new WanReplicationRef().setName("london-wan-rep"));
config.getCacheConfig("replicatedCache").setWanReplicationRef(new WanReplicationRef().setName("london-wan-rep"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>We can see that we have configured the map named <code>replicatedMap</code> and cache named <code>replicatedCache</code> to
replicate to the cluster named <code>london</code> on two endpoints - <code>10.3.5.1:5701, 10.3.5.2:5701</code>. The <code>london</code> cluster
might have more members than these two but only these two will receive WAN events and forward them to other
members in the <code>london</code> cluster or to other clusters if WAN event forwarding is enabled.
Please notice that the WAN Replication configuration is referenced in map and cache configuration by name, here
<code>london-wan-rep</code>.</p>
</div>
<div class="paragraph">
<p>The default settings for WAN Replication will suit most use cases. If, however, you have specific needs or if you
would like to fine-tune the behavior of WAN Replication for your application, please refer to the
<a href="#tuning-wr">Fine-Tuning WAN Replication</a> section for more information.</p>
</div>
</div>
<div class="sect3">
<h4 id="wanbatchreplication-discovery-spi"><a class="anchor" href="#wanbatchreplication-discovery-spi"></a>Using the Discovery SPI</h4>
<div class="paragraph">
<p>In addition to defining target cluster endpoints with static IP addresses,
you can configure WAN to work with the Discovery SPI and determine the endpoint IP addresses at runtime.
It may be suitable when you don&#8217;t know the list of static IP addresses of the target cluster at
startup time or in cases when the list of available target endpoints is subject to change during the lifecycle of the
source cluster.</p>
</div>
<div class="paragraph">
<p>In relation to the above, using the Discovery SPI allows you to use WAN with endpoints on various cloud
infrastructures (such as Amazon EC2 or GCP Compute) where
the IP address is not known in advance. Typically you use a readily available Discovery SPI plugin such as
<a href="https://github.com/hazelcast/hazelcast-aws" target="_blank" rel="noopener">Hazelcast AWS discovery plugin</a>,
<a href="https://github.com/hazelcast/hazelcast-azure" target="_blank" rel="noopener">Hazelcast Azure discovery plugin</a>,
<a href="https://github.com/hazelcast/hazelcast-gcp" target="_blank" rel="noopener">Hazelcast GCP discovery plugin</a>, or similar.
You can store the list of IP addresses in those infrastructures and use these plugins
to read from that list.</p>
</div>
<div class="paragraph">
<p>For more advanced cases, you can provide your own <a href="#discovery-spi">Discovery SPI</a> implementation with custom logic for
determining the WAN target endpoints such as looking up the endpoints in some service registry or even
reading the endpoint addresses from a file.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using the Discovery SPI, WAN always connects to the public address of the members returned by
the Discovery SPI implementation. This is opposite to the cluster membership mechanism using
the Discovery SPI where a member connects to a different member in the same cluster through its private address.
Should you prefer for WAN to use the private address of the discovered member as well,
please use the <code>use-endpoint-private-address</code> publisher element, described in the following paragraphs.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The following is an example of setting up the WAN replication with the AWS discovery plugin.
Note that you must have <code>hazelcast-all</code> (or <code>hazelcast-aws</code>) JAR on the classpath.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;discovery-strategies&gt;
                &lt;discovery-strategy enabled="true" class="com.hazelcast.aws.AwsDiscoveryStrategy"&gt;
                    &lt;properties&gt;
                        &lt;property name="access-key"&gt;test-access-key&lt;/property&gt;
                        &lt;property name="secret-key"&gt;test-secret-key&lt;/property&gt;
                        &lt;property name="region"&gt;test-region&lt;/property&gt;
                        &lt;property name="iam-role"&gt;test-iam-role&lt;/property&gt;
                        &lt;property name="host-header"&gt;ec2.test-host-header&lt;/property&gt;
                        &lt;property name="security-group-name"&gt;test-security-group-name&lt;/property&gt;
                        &lt;property name="tag-key"&gt;test-tag-key&lt;/property&gt;
                        &lt;property name="tag-value"&gt;test-tag-value&lt;/property&gt;
                        &lt;property name="connection-timeout-seconds"&gt;10&lt;/property&gt;
                        &lt;property name="hz-port"&gt;5701&lt;/property&gt;
                    &lt;/properties&gt;
                &lt;/discovery-strategy&gt;
            &lt;/discovery-strategies&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        discovery-strategies:
          discovery-strategy:
            - enabled: true
              class: com.hazelcast.aws.AwsDiscoveryStrategy
              properties:
                access-key: test-access-key
                secret-key: test-secret-key
                region: test-region
                iam-role: test-iam-role
                host-header: ec2.test-host-header
                security-group-name: test-security-group-name
                tag-key: test-tag-key
                tag-value: test-tag-value
                connection-timeout-seconds: 10
                hz-port: 5701</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Config config = new Config();

WanBatchPublisherConfig batchPublisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london");

DiscoveryStrategyConfig discoveryStrategyConfig = new DiscoveryStrategyConfig("com.hazelcast.aws.AwsDiscoveryStrategy");
discoveryStrategyConfig.addProperty("access-key","test-access-key");
discoveryStrategyConfig.addProperty("secret-key","test-secret-key");
discoveryStrategyConfig.addProperty("region","test-region");
discoveryStrategyConfig.addProperty("iam-role","test-iam-role");
discoveryStrategyConfig.addProperty("host-header","ec2.test-host-header");
discoveryStrategyConfig.addProperty("security-group-name","test-security-group-name");
discoveryStrategyConfig.addProperty("tag-key","test-tag-key");
discoveryStrategyConfig.addProperty("tag-value","test-tag-value");
discoveryStrategyConfig.addProperty("hz-port",5702);

DiscoveryConfig discoveryConfig = new DiscoveryConfig()
        .addDiscoveryStrategyConfig(discoveryStrategyConfig);
batchPublisherConfig.setDiscoveryConfig(discoveryConfig);

WanReplicationConfig wrConfig = new WanReplicationConfig()
        .setName("london-wan-rep")
        .addBatchReplicationPublisherConfig(batchPublisherConfig);
config.addWanReplicationConfig(wrConfig);

config.getMapConfig("replicatedMap").setWanReplicationRef(new WanReplicationRef().setName("london-wan-rep"));
config.getCacheConfig("replicatedCache").setWanReplicationRef(new WanReplicationRef().setName("london-wan-rep"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>hz-port</code> property defines the port or the port range on which the target endpoint is running.
The default port range 5701-5708 is used if this property is not defined.
This is needed because the Amazon API which the AWS plugin uses does not provide
the port on which Hazelcast is running, only the IP address. For some other Discovery SPI implementations,
this might not be necessary and it might discover the port as well, e.g., by looking up in a service registry.</p>
</div>
<div class="paragraph">
<p>The other properties are the same as when using the <code>aws</code> element. In case of AWS discovery you can configure
the WAN replication using the <code>aws</code> element. You may use either the <code>discovery-strategies</code> or <code>aws</code>
element, but not both at the same time.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;use-endpoint-private-address&gt;false&lt;/use-endpoint-private-address&gt;
            &lt;aws enabled="true"&gt;
                &lt;access-key&gt;my-access-key&lt;/access-key&gt;
                &lt;secret-key&gt;my-secret-key&lt;/secret-key&gt;
                &lt;region&gt;us-west-1&lt;/region&gt;
                &lt;security-group-name&gt;hazelcast-sg&lt;/security-group-name&gt;
                &lt;tag-key&gt;type&lt;/tag-key&gt;
                &lt;tag-value&gt;hz-members&lt;/tag-value&gt;
                &lt;hz-port&gt;5701&lt;/hz-port&gt;
            &lt;/aws&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        use-endpoint-private-address: false
        aws:
          enabled: true
            access-key: my-access-key
            secret-key: my-secret-key
            region: us-west-1
            security-group-name: hazelcast-sg
            tag-key: type
            tag-value: hz-members
            hz-port: 5701
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the following for the configurations of WAN replications in other cloud infrastructures
that are supported by Discovery SPI:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-azure/blob/master/README.md#configuration-for-wan-replication-target-cluster-discovery" target="_blank" rel="noopener">Microsoft Azure</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-gcp/blob/master/README.md#configuration" target="_blank" rel="noopener">Google Cloud Platform (GCP)</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-kubernetes#configuration" target="_blank" rel="noopener">Kubernetes</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-openshift#wan-replication" target="_blank" rel="noopener">OpenShift</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-eureka#hazelcast-configuration" target="_blank" rel="noopener">Eureka</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-jclouds/blob/master/README.md#discovering-members-with-jclouds" target="_blank" rel="noopener">jclouds®</a></p>
</li>
<li>
<p><a href="https://github.com/bitsofinfo/hazelcast-etcd-discovery-spi/blob/master/README.md#usage" target="_blank" rel="noopener">etcd</a></p>
</li>
<li>
<p><a href="https://github.com/bitsofinfo/hazelcast-consul-discovery-spi#usage" target="_blank" rel="noopener">Consul</a></p>
</li>
<li>
<p><a href="https://github.com/hazelcast/hazelcast-zookeeper/blob/master/README.md#configuration" target="_blank" rel="noopener">Zookeeper</a></p>
</li>
<li>
<p><a href="https://github.com/jkutner/hazelcast-heroku-discovery/blob/master/README.md#configuration" target="_blank" rel="noopener">Heroku</a></p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="wanbatchreplication-implementation"><a class="anchor" href="#wanbatchreplication-implementation"></a>Using the Built-In WAN Batch Publisher</h4>
<div class="paragraph">
<p>Hazelcast IMDG offers the built-in WAN batch publisher implementation for WAN replication.</p>
</div>
<div class="paragraph">
<p>As you see in the above configuration examples, this implementation is specified simply by using
the <code>batch-publisher</code> element (in the declarative configuration) or the <code>WanBatchPublisherConfig</code>
class (in the programmatic configuration) when defining a WAN replication publisher.</p>
</div>
<div class="paragraph">
<p>The WAN batch publisher transmits WAN events (map and cache updates) between clusters in batches. It waits until:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>a pre-defined number of replication events are generated, (see the <a href="#batch-size">Batch Size section</a>)</p>
</li>
<li>
<p>or a pre-defined amount of time is passed (see the <a href="#batch-maximum-delay">Batch Maximum Delay section</a>).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is a declarative example on using and configuring <code>batch-publisher</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            ...
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
    &lt;/cache&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        ...
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>Above, you notice that we have configured the instance to replicate a map and a cache to a target cluster
with the cluster name <code>london</code>. WAN Replication will check that this cluster name matches during connection
establishment to each endpoint. This does not serve as a security measure though. This serves only to prevent
misconfiguration where the source cluster would mistakenly replicate to the wrong cluster and as an attempt to
detect and prevent loops where the same WAN event would be infinitely forwarded between the same clusters.</p>
</div>
<div class="paragraph">
<p>The <code>wan-replication</code> configuration element defines a single WAN replication scheme. Hazelcast maps and caches
are configured to replicate to a single WAN replication scheme and different maps and different caches can be
configured to replicate to different WAN replication schemes. Simply put, a WAN replication scheme may be viewed
as several target clusters and different Hazelcast structures can replicate to different target clusters
simultaneously. As such, a single WAN replication scheme can contain multiple WAN replication publishers.
It has the following essential sub-elements and attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of your WAN replication scheme. This name is referenced in IMap or ICache configuration when you want
to enable WAN Replication for these data structures (using the element <code>wan-replication-ref</code> in the configuration
of IMap or ICache).</p>
</li>
<li>
<p><code>batch-publisher</code>: Enables use of a WAN publisher which uses the built-in WAN replication implementation.
It defines how to connect to the target cluster and how WAN events are sent to a specific target
endpoint. As mentioned above, just before the configuration example, the target endpoints can be a different cluster
defined by static IPs or discovered using a cloud discovery mechanism.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>batch-publisher</code> has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>cluster-name</code>: Sets the cluster name used as an endpoint cluster name for authentication
on the target endpoint. If there is no separate publisher ID element defined, this cluster name
is also used as a WAN publisher ID. This ID is then used for identifying the publisher in a
WAN replication scheme. It is mandatory to set this attribute.</p>
</li>
<li>
<p><code>publisher-id</code>: Sets the publisher ID used to identify the publisher in a WAN replication scheme.
Setting this ID may be useful when the <code>wan-replication</code> element contains multiple WAN publishers and the
cluster names are not unique for all of the WAN replication publishers in a single WAN replication scheme.
It is optional to set this attribute. If this ID is not specified, the <code>cluster-name</code> is used as a publisher ID.</p>
</li>
<li>
<p><code>target-endpoints</code>: IP addresses and ports of the cluster members for which the WAN replication is implemented.
It is enough to specify some of the member IP/ports available in the target cluster, i.e., you don’t need to
provide the IP/ports of all members in there. WAN does not perform the discovery of other members in the target cluster;
it only expects that the IP addresses you provide are available.</p>
</li>
<li>
<p><code>sync</code>: Configuration for the WAN sync mechanism. See the <a href="#synchronizing-wan-clusters">Synchronizing WAN Clusters section</a>.</p>
</li>
<li>
<p><code>discovery-strategies</code>: Set its <code>enabled</code> attribute to true for discovery in various cloud infrastructures.
You can define multiple discovery strategies using the <code>discovery-strategy</code> sub-element and its elements.
See the <a href="#wanbatchreplication-discovery-spi">Using the Discovery SPI section</a> for this and the below elements.</p>
</li>
<li>
<p><code>aws</code>: Configuration for discovery strategy for Amazon EC2 discovery plugin.</p>
</li>
<li>
<p><code>gcp</code>: Configuration for discovery strategy for Google cloud platform discovery plugin.</p>
</li>
<li>
<p><code>azure</code>: Configuration for discovery strategy for Microsoft Azure discovery plugin.</p>
</li>
<li>
<p><code>kubernetes</code>: Configuration for discovery strategy for Kubernetes discovery plugin.</p>
</li>
<li>
<p><code>eureka</code>: Configuration for discovery strategy for Eureka discovery plugin.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using this configuration, the cluster replicates to a cluster with the name <code>london</code>.
The <code>london</code> cluster should have a similar configuration if you want to run in Active-Active mode.</p>
</div>
<div class="paragraph">
<p>You can achieve various WAN topologies using different configurations on different clusters. For instance,
if the New York and London cluster configurations contain the <code>wan-replication</code> element and the Tokyo cluster
does not, it might mean that the New York and London clusters are active endpoints and Tokyo is a passive endpoint.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-wan-replication-for-imap-and-icache"><a class="anchor" href="#configuring-wan-replication-for-imap-and-icache"></a>Configuring for IMap and ICache</h3>
<div class="paragraph">
<p>As mentioned before, for now Hazelcast&#8217;s map (<code>IMap</code>) and cache (<code>ICache</code>)
data structures support WAN Replication. After you define and configure the WAN Replication
as explained in previous sections above, you need to bind it to your maps and/or caches.</p>
</div>
<div class="paragraph">
<p>To enable WAN replication for an <code>IMap</code> or <code>ICache</code> instance, you can use the <code>wan-replication-ref</code>
configuration element. Each instance can have a different WAN replication configuration.</p>
</div>
<div class="paragraph">
<p><strong>Enabling WAN Replication for IMap:</strong></p>
</div>
<div class="paragraph">
<p>Imagine you have different distributed maps, however only one of those maps should be replicated to a target cluster.
To achieve this, configure the map that you want to be replicated by adding the <code>wan-replication-ref</code> element in
the map configuration as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        ...
    &lt;/wan-replication&gt;
    &lt;map name="my-shared-map"&gt;
        &lt;wan-replication-ref name="london-wan-rep"&gt;
            &lt;merge-policy&gt;com.hazelcast.spi.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
            &lt;republishing-enabled&gt;false&lt;/republishing-enabled&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      ...
  map:
    my-shared-map:
      wan-replication-ref:
        london-wan-rep:
          merge-policy: com.hazelcast.spi.merge.PassThroughMergePolicy
          republishing-enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent programmatic configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();

        WanReplicationConfig wrConfig = new WanReplicationConfig();
        wrConfig.setName("my-wan-cluster");

        config.addWanReplicationConfig(wrConfig);

        WanReplicationRef wanRef = new WanReplicationRef();
        wanRef.setName("my-wan-cluster");
        wanRef.setMergePolicyClassName(PassThroughMergePolicy.class.getName());
        wanRef.setRepublishingEnabled(false);
        config.getMapConfig("my-shared-map").setWanReplicationRef(wanRef);</code></pre>
</div>
</div>
<div class="paragraph">
<p>You see that we have <code>my-shared-map</code> configured to replicate itself to the cluster targets defined in the earlier
<code>wan-replication</code> element.</p>
</div>
<div class="paragraph">
<p><code>wan-replication-ref</code> has the following elements;</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>name</code>: Name of the <code>wan-replication</code> configuration. <code>IMap</code> or <code>ICache</code> instance uses this <code>wan-replication</code> configuration.</p>
</li>
<li>
<p><code>merge-policy</code>: Policy to resolve conflicts that occur when the target cluster already has the replicated entry key.
This configuration element is optional. If it is not specified, <code>com.hazelcast.spi.merge.PassThroughMergePolicy</code>
will be used as the merge policy.</p>
</li>
<li>
<p><code>republishing-enabled</code>: When enabled, an incoming event to a member is forwarded to target cluster of that member.
Enabling the event republishing is useful in a scenario where cluster A replicates to cluster B and
cluster B replicates to cluster C. You do not need to enable republishing when all your clusters
replicate to each other.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When using Active-Active Replication, multiple clusters can simultaneously update the same
entry in a distributed data structure. You can configure a merge policy to resolve these potential
conflicts, as shown in the above example configuration (using the <code>merge-policy</code> sub-element under
the <code>wan-replication-ref</code> element).</p>
</div>
<div class="paragraph">
<p>Hazelcast provides the following merge policies for <code>IMap</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.spi.merge.PutIfAbsentMergePolicy</code>: Incoming entry merges from the source map to
the target map if it does not exist in the target map.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.HigherHitsMergePolicy</code>: Incoming entry merges from the source map to
the target map if the source entry has more hits than the target one.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.PassThroughMergePolicy</code>: Incoming entry merges from the source map to
the target map unless the incoming entry is not null.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.ExpirationTimeMergePolicy</code>: Incoming entry merges from the source map to
the target map if the source entry will expire later than the destination entry.
Please note that this merge policy can only be used when the clusters' clocks are in sync.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.LatestAccessMergePolicy</code>: Incoming entry merges from the source map to
the target map if the source entry has been accessed more recently than the destination entry.
Please note that this merge policy can only be used when the clusters' clocks are in sync.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.LatestUpdateMergePolicy</code>: Incoming entry merges from the source map to
the target map if the source entry has been updated more recently than the target entry.
Please note that this merge policy can only be used when the clusters' clocks are in sync.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
When using WAN replication, please note that the key based operations are replicated to the target cluster,
except <code>evict()</code>. Also the results of entry processors are also replicated.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Note that WAN replication does not replicate configurations, but only the events, i.e., data inserts,
updates and removals. When a map or cache is replicated and the target cluster does not have a configuration
for that map or cache, the default configuration will apply on the target cluster.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><strong>Enabling WAN Replication for <code>ICache</code>:</strong></p>
</div>
<div class="paragraph">
<p>The following is a declarative configuration example for enabling WAN Replication for <code>ICache</code>:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        ...
    &lt;/wan-replication&gt;
    &lt;cache name="my-shared-cache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"&gt;
            &lt;merge-policy&gt;com.hazelcast.spi.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
            &lt;republishing-enabled&gt;true&lt;/republishing-enabled&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      ...
  cache:
    my-shared-cache:
      wan-replication-ref:
        london-wan-rep:
          merge-policy: com.hazelcast.spi.merge.PassThroughMergePolicy
          republishing-enabled: true</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the equivalent programmatic configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">        Config config = new Config();

        WanReplicationConfig wrConfig = new WanReplicationConfig();
        wrConfig.setName("my-wan-cluster");

        config.addWanReplicationConfig(wrConfig);

        WanReplicationRef cacheWanRef = new WanReplicationRef();
        cacheWanRef.setName("my-wan-cluster");
        cacheWanRef.setMergePolicyClassName("com.hazelcast.spi.merge.PassThroughMergePolicy");
        cacheWanRef.setRepublishingEnabled(true);
        config.getCacheConfig("my-shared-cache").setWanReplicationRef(cacheWanRef);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Caches that are created dynamically do not support WAN replication functionality.
Cache configurations should be defined either declaratively (by XML) or programmatically on both
source and target clusters.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Hazelcast provides the following merge policies for <code>ICache</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>com.hazelcast.spi.merge.PutIfAbsentMergePolicy</code>: Incoming entry merges from the source cache to
the target cache if it does not exist in the target cache.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.HigherHitsMergePolicy</code>: Incoming entry merges from the source cache to
the target cache if the source entry has more hits than the target one.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.PassThroughMergePolicy</code>: Incoming entry merges from the source cache to
the target cache unless the incoming entry is not null.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.ExpirationTimeMergePolicy</code>: Incoming entry merges from the source cache to
the target cache if the source entry will expire later than the destination entry.
Please note that this merge policy can only be used when the clusters' clocks are in sync.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.LatestAccessMergePolicy</code>: Incoming entry merges from the source cache to
the target cache if the source entry has been accessed more recently than the destination entry.
Please note that this merge policy can only be used when the clusters' clocks are in sync.</p>
</li>
<li>
<p><code>com.hazelcast.spi.merge.LatestUpdateMergePolicy</code>: Incoming entry merges from the source cache to
the target cache if the source entry has been updated more recently than the target entry.
Please note that this merge policy can only be used when the clusters' clocks are in sync.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="wr-advanced"><a class="anchor" href="#wr-advanced"></a>Advanced Features</h3>
<div class="paragraph">
<p>This section describes how you can synchronize your WAN replicated clusters,
change their configurations dynamically and intercept WAN replication events using
the event filtering API.</p>
</div>
<div class="sect3">
<h4 id="_synchronizing_wan_clusters"><a class="anchor" href="#_synchronizing_wan_clusters"></a>Synchronizing WAN Clusters</h4>
<div class="paragraph">
<p>WAN Replication replicates mutation events that happen on the source
cluster as they happen. The events are queued up, collected in a batch
and sent to the target cluster to be applied, without any user interaction.</p>
</div>
<div class="paragraph">
<p>However, Hazelcast clusters connected over WAN may become out-of-sync because of various reasons
including but not limited to the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Member failures</p>
</li>
<li>
<p>Concurrent updates</p>
</li>
<li>
<p>Target cluster freshly starts with no data</p>
</li>
<li>
<p>Target cluster experiences problems and some operations fail</p>
</li>
<li>
<p>Two sides disconnect and the in-memory buffer of the source
cluster gets full (the behavior in this case is <a href="#queue-full-behavior">configurable</a>)</p>
</li>
<li>
<p>The WAN link can&#8217;t keep up with the burst that the source cluster experiences
and its in-memory buffer gets full (the behavior in this case is <a href="#queue-full-behavior">configurable</a>)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To overcome this out-of-sync issue, you have the
following options to synchronize your WAN replicated clusters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Full synchronization</p>
</li>
<li>
<p>Delta synchronization</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following sections describe each.</p>
</div>
<div class="sect4">
<h5 id="synchronizing-wan-target-cluster"><a class="anchor" href="#synchronizing-wan-target-cluster"></a>Full WAN Synchronization</h5>
<div class="paragraph">
<p>Full WAN synchronization sends all the data of an IMap to a target cluster to align the state of target IMap with source IMap.
It is useful if two remote clusters lost their synchronizations due to overflow in the WAN queue or in restart scenarios.
This is the default synchronization option.</p>
</div>
<div class="paragraph">
<p>Full WAN Synchronization can be initiated through
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#wan-sync" target="_blank" rel="noopener">Management Center</a> and
Hazelcast&#8217;s REST API.</p>
</div>
<div class="paragraph">
<p>Below is the URL for the REST call;</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to add URL-encoded parameters to the request in the following order separated by "&amp;";</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster name</p>
</li>
<li>
<p>Cluster password</p>
</li>
<li>
<p>Name of the WAN replication configuration</p>
</li>
<li>
<p>WAN replication publisher ID/target cluster name</p>
</li>
<li>
<p>Map name to be synchronized</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Assume that you have configured an IMap with a WAN replication configuration as follows:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;istanbul&lt;/cluster-name&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    &lt;map name="my-map"&gt;
        &lt;wan-replication-ref name="london-wan-rep"&gt;
            &lt;merge-policy&gt;com.hazelcast.spi.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication name: london-wan-rep
    batch-publisher:
      cluster-name: istanbul
  map:
    my-map:
      wan-replication-ref:
        london-wan-rep:
          merge-policy: com.hazelcast.spi.merge.PassThroughMergePolicy</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then, an example curl command to initiate the synchronization for "my-map" would be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterName}&amp;{clusterPassword}&amp;london-wan-rep&amp;istanbul&amp;my-map" --URL http://127.0.0.1:5701/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can also synchronize all maps in the source and target clusters.
In that case the curl command using the above parameters becomes as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterName}&amp;{clusterPassword}&amp;london-wan-rep&amp;istanbul" --URL http://127.0.0.1:5701/hazelcast/rest/wan/sync/allMaps</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Synchronization for a target cluster operates only with
the data residing in the memory. Therefore, evicted entries are not
synchronized, not even if <code>MapLoader</code> is configured.
</td>
</tr>
</table>
</div>
</div>
<div class="sect4">
<h5 id="_delta_wan_synchronization"><a class="anchor" href="#_delta_wan_synchronization"></a>Delta WAN Synchronization</h5>
<div class="paragraph">
<p>As explained in the previous section, the default <a href="#synchronizing-wan-target-cluster">Full WAN Synchronization</a> feature
synchronizes  the maps in different clusters by transferring all the entries from the source to the target cluster.
This may be not efficient since some of the entries have remained unchanged on both clusters and
do not require to be transferred. Also, for the entries to be transferred, they need to be copied to
on-heap on the source cluster. This may cause spikes in the heap usage, especially if using large off-heap stores.</p>
</div>
<div class="paragraph">
<p>In addition to the default Full WAN Synchronization, Hazelcast provides Delta WAN Synchronization which uses
<a href="https://en.wikipedia.org/wiki/Merkle_tree" target="_blank" rel="noopener">Merkle tree</a> for the same purpose.
It is a data structure used for efficient comparison of the difference in the contents of large data structures.
The precision of this comparison is defined by Merkle tree&#8217;s depth.
Merkle tree hash exchanges can detect inconsistencies in the map data and
synchronize only the different entries when using WAN synchronization, instead of sending all the map entries.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Currently, Delta WAN Synchronization is implemented only for Hazelcast IMap.
It will be implemented also for ICache in the future releases.
</td>
</tr>
</table>
</div>
<div class="sect5">
<h6 id="requirements-for-delta-wan-sync"><a class="anchor" href="#requirements-for-delta-wan-sync"></a>Requirements</h6>
<div class="paragraph">
<p>To be able to use Delta WAN synchronization, the following must be met:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Source and target cluster versions must be at least Hazelcast 3.11.</p>
</li>
<li>
<p>Both clusters must have the same number of partitions.</p>
</li>
<li>
<p>Both clusters must use the same partitioning strategy.</p>
</li>
<li>
<p>Both clusters must have the Merkle tree structure enabled.</p>
</li>
</ul>
</div>
</div>
<div class="sect5">
<h6 id="_using_delta_wan_synchronization"><a class="anchor" href="#_using_delta_wan_synchronization"></a>Using Delta WAN Synchronization</h6>
<div class="paragraph">
<p>To be able to use Delta WAN synchronization for a Hazelcast data structure:</p>
</div>
<div class="paragraph">
<p>1 - Configure the WAN synchronization mechanism for your WAN publisher so that
it uses the Merkle tree: If configuring declaratively, you can use the <code>consistency-check-strategy</code> sub-element of
the <code>sync</code> element. If configuring programmatically, you can use the setter of the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/WanSyncConfig.html" target="_blank" rel="noopener">WanSyncConfig</a> object.
Here is a declarative example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
     &lt;wan-replication name="wanReplicationScheme"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;clusterName&lt;/cluster-name&gt;
            &lt;sync&gt;
                &lt;consistency-check-strategy&gt;MERKLE_TREES&lt;/consistency-check-strategy&gt;
            &lt;/sync&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    wanReplicationScheme:
      batch-publisher:
        cluster-name: clusterName
        sync:
          consistency-check-strategy: MERKLE_TREES</code></pre>
</div>
</div>
<div class="paragraph">
<p>2 - Bind that WAN synchronization configuration to the data structure (currently IMap):
Simply set the WAN replication reference of your map to the name of the WAN replication
configuration which uses the Merkle tree.
Here is a declarative example:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;wan-replication-ref name="wanReplicationScheme"&gt;
          ...
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      wan-replication-ref:
        wanReplicationScheme:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>3 - Finally, configure the Merkle tree using the <code>merkle-tree</code> element which is contained
in the <code>map</code> configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;merkle-tree enabled="true"&gt;
            &lt;depth&gt;5&lt;/depth&gt;
        &lt;/merkle-tree&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      merkle-tree:
        enabled: true
        depth: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can programmatically configure it, too, using the
<a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/config/MerkleTreeConfig.html" target="_blank" rel="noopener">MerkleTreeConfig</a> object.</p>
</div>
<div class="paragraph">
<p>Here is the full declarative configuration example showing how to
enable Delta WAN Synchronization, bind it to a Hazelcast data structure (an IMap in this case) and specify its depth:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="myMap"&gt;
        &lt;wan-replication-ref name="wanReplicationScheme"&gt;
            ...
        &lt;/wan-replication-ref&gt;
        &lt;merkle-tree enabled="true"&gt;
            &lt;depth&gt;10&lt;/depth&gt;
        &lt;/merkle-tree&gt;
    &lt;/map&gt;

    &lt;wan-replication name="wanReplicationScheme"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;clusterName&lt;/cluster-name&gt;
            &lt;sync&gt;
                &lt;consistency-check-strategy&gt;MERKLE_TREES&lt;/consistency-check-strategy&gt;
            &lt;/sync&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    myMap:
      wan-replication-ref:
        wanReplicationScheme:
          ...
      merkle-tree:
        enabled: true
        depth: 10
  wan-replication:
    wanReplicationScheme:
      batch-publisher:
        cluster-name: clusterName
        sync:
          consistency-check-strategy: MERKLE_TREES</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the element <code>consistency-check-strategy</code> sets the strategy for
checking the consistency of data between the source and target clusters.
You must initiate the WAN synchronization (via Management Center or REST API as explained in
<a href="#synchronizing-wan-target-cluster">Synchronizing WAN clusters</a>) to let this strategy reconcile the inconsistencies.
The element <code>consistency-check-strategy</code> has currently two values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>NONE</code>: Means that there are no consistency checks. This is the default value.</p>
</li>
<li>
<p><code>MERKLE_TREES</code>: Means that WAN synchronization uses Merkle tree structure.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Merkle tree structure is enabled using its <code>enabled</code> attribute (default is <code>true</code>).
Its  <code>depth</code> element specifies the depth of Merkle tree. Valid values are between 2 and 27 (exclusive).
Its default value is <code>10</code>.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>A larger depth means that a data synchronization mechanism is able to pinpoint a smaller subset of
the data structure (e.g., IMap) contents in which a change has occurred.
This causes the synchronization mechanism to be more efficient.
However, keep in mind that a large depth means that the Merkle tree will consume more memory.
As the comparison mechanism is iterative, a larger depth also prolongs the comparison duration.
Therefore, it is recommended not to have large tree depths if the latency of the comparison operation is high.</p>
</li>
<li>
<p>A smaller depth means that the Merkle tree is shallower and the data synchronization mechanism transfers
larger chunks of the data structure (e.g., IMap) in which a possible change has happened.
As you can imagine, a shallower Merkle tree will consume less memory.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Also see the <a href="#defining-the-depth">Defining the Depth section</a> for more insights.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you do not specifically configure the <code>merkle-tree</code> in your
Hazelcast configuration, Hazelcast uses the default Merkle tree structure values
(i.e., it is enabled by default and its default depth is 10) when there is a WAN publisher using
the Merkle tree (i.e., <code>consistency-check-strategy</code> for a WAN replication configuration is set as
<code>MERKLE_TREES</code> and there is a data structure using that WAN replication configuration).
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Merkle trees are created for each partition holding IMap data.
Therefore, increasing the partition count also
increases the efficiency of the Delta WAN Synchronization.
</td>
</tr>
</table>
</div>
</div>
<div class="sect5">
<h6 id="_the_process"><a class="anchor" href="#_the_process"></a>The Process</h6>
<div class="paragraph">
<p>Synchronizing the maps based on Merkle trees consists of two phases:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>Consistency check</em>: Process of exchanging and comparing the hashes stored in the Merkle tree structures in the
source and target clusters. The check starts with the root node and continues recursively with the children with different
hash codes. Both sides send the children of the nodes that the other side sent, hence the comparison is done by <code>depth/2</code>
steps. After this check, the tree leaves holding different entries are identified.</p>
</li>
<li>
<p><em>Synchronization</em>: Process of transferring the entries belong to the leaves identified by the <em>consistency
check</em> from the source to target cluster. On the target cluster the configured merge policy is applied for each entry that
is in both the source and target clusters.</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
If you only need the differences between the clusters, you can trigger the consistency check without performing
synchronization.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The two phases of the Merkle tree based synchronization can be triggered by the REST calls, as it can be done with the
full synchronization.</p>
</div>
<div class="paragraph">
<p>The URL for the consistency check REST call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/consistencyCheck/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>The URL for the synchronization REST call - the same as it is for the default synchronization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the REST call details <a href="#synchronizing-the-clusters">here</a>.</p>
</div>
</div>
<div class="sect5">
<h6 id="_memory_consumption"><a class="anchor" href="#_memory_consumption"></a>Memory Consumption</h6>
<div class="paragraph">
<p>Since Merkle trees are built for each partition and each map, the memory overhead of the trees with high entry count and deep
trees can be significant. The trees are maintained on-heap, therefore - besides the memory consumption - garbage collection could be another
concern.</p>
</div>
<div class="paragraph">
<p>The table below shows a few examples for what the memory overhead could be.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 1. Merkle trees memory overhead for a member, for one map</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Partitions Owned</th>
<th class="tableblock halign-left valign-top">Depth</th>
<th class="tableblock halign-left valign-top">Memory Overhead</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.27 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">271</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">68 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">157 MB</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5009</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1252 MB</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect5">
<h6 id="_defining_the_depth"><a class="anchor" href="#_defining_the_depth"></a>Defining the Depth</h6>
<div class="paragraph">
<p>The efficiency of the Delta WAN Synchronization (WAN synchronization based on Merkle trees) is determined by the average number of entries per the tree
leaves that is proportionate to the number of entries in the map. The bigger this average the more entries are getting
synchronized for the same difference. Raising the depth decreases this average at the cost of increasing the memory overhead.</p>
</div>
<div class="paragraph">
<p>This average can be calculated for a map as <code>avgEntriesPerLeaf = mapEntryCount / totalLeafCount</code>, where <code>totalLeafCount =
partitionCount * 2<sup>depth-1</sup></code>. The ideal value is 1, however this may come at significant memory overhead as shown in the
table above.</p>
</div>
<div class="paragraph">
<p>In order to specify the tree depth, a trade-off between memory consumption and effectiveness might be needed.</p>
</div>
<div class="paragraph">
<p>Even if the map is huge and the Merkle trees are configured to be relatively shallow, the Merkle tree based synchronization
may be leveraged if only a small subset of the whole map is expected to be synchronized. The table below illustrates the
efficiency of the Merkle tree based synchronization compared to the default synchronization mechanism.</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">Table 2. Efficiency examples</caption>
<colgroup>
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2857%;">
<col style="width: 14.2858%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Map entry count</th>
<th class="tableblock halign-left valign-top">Depth</th>
<th class="tableblock halign-left valign-top">Memory consumption</th>
<th class="tableblock halign-left valign-top">Avg entries / leaf</th>
<th class="tableblock halign-left valign-top">Difference count</th>
<th class="tableblock halign-left valign-top">Entries synced</th>
<th class="tableblock halign-left valign-top">Efficiency</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">39 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">78 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">100%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">20 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">150%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">160K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6150%</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">10M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">78 MB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10K</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">99900%</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>The <code>Difference count</code> column shows the number of the entries different in the source and the target clusters.
This is the minimum number of the entries that need to be synchronized to make the clusters consistent. The <code>Entries synced</code>
column shows how many entries are synchronized in the given case, calculated as <code>Entries synced</code> = <code>Difference count</code>
* <code>Avg entries / leaf</code>.</p>
</div>
<div class="paragraph">
<p>As shown in the last two rows, the Merkle tree based synchronization transfers significantly less entries than what the
default mechanism does even with 8 deep trees. The efficiency with depth 12 is even better but consumes much more memory.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The averages in the table are calculated with 5009 partitions.
</td>
</tr>
</table>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The average entries per leaf number above assumes perfect distribution of the entries amongst the leaves. Since this is
typically not true in real-life scenarios the efficiency can be slightly worse. The statistics section below describes how to
get the actual average for the leaves involved in the synchronization.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_wan_synchronization_statistics"><a class="anchor" href="#_wan_synchronization_statistics"></a>WAN Synchronization Statistics</h5>
<div class="paragraph">
<p>Both Full and Delta WAN Synchronization processes write statistics into the
<a href="#diagnostics-2">diagnostics</a> subsystem and send them to Hazelcast Management
Center. Using these statistics you can measure the efficiency of your configuration.</p>
</div>
<div class="paragraph">
<p>Full WAN Synchronization reports the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duration of the synchronization</p>
</li>
<li>
<p>Count of the synchronized entries</p>
</li>
<li>
<p>Total count of the synchronized partitions</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">Synchronization statistics:
	 Synchronization UUID: 8af2f9e7-3f9f-4c31-b594-47c421bfb33c
	 Duration: 0 secs
	 Total records synchronized: 448
	 Total partitions synchronized: 5</code></pre>
</div>
</div>
<div class="paragraph">
<p>Delta WAN Synchronization reports the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Duration of the synchronization</p>
</li>
<li>
<p>Count of the synchronized entries</p>
</li>
<li>
<p>Total count of the synchronized partitions</p>
</li>
<li>
<p>Merkle tree nodes checked</p>
</li>
<li>
<p>Merkle tree nodes found to be different</p>
</li>
<li>
<p>Count of the entries needed to be synchronized to make the clusters consistent</p>
</li>
<li>
<p>Average count of entries per tree leaves in the synchronized leaves</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Here is an example output:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-plain hljs" data-lang="plain">Merkle synchronization statistics:
	 Synchronization UUID: f49a25ba-dc57-4547-817b-bea67ff7f0fe
	 Duration: 0 secs
	 Total records synchronized: 528
	 Total partitions synchronized: 6
	 Total Merkle tree nodes synchronized: 178
	 Average records per Merkle tree node: 2.97
	 StdDev of records per Merkle tree node: 1.55
	 Minimum records per Merkle tree node: 1
	 Maximum records per Merkle tree node: 7</code></pre>
</div>
</div>
<div class="paragraph">
<p>See the <a href="#diagnostics-2">Diagnostics section</a> to learn how to enable
diagnostics and locate its log file to see the above statistics.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_dynamically_adding_wan_publishers"><a class="anchor" href="#_dynamically_adding_wan_publishers"></a>Dynamically Adding WAN Publishers</h4>
<div class="paragraph">
<p>When running clusters for an extensive period, you might need to
dynamically change the configuration while the cluster is running.
This includes dynamically adding new WAN replication publishers (new target clusters) and
replicating the subsequent map and cache updates to the new publishers without any manual intervention.</p>
</div>
<div class="paragraph">
<p>You can add new WAN publishers to an existing WAN replication using
almost all of the configuration options that are available when
configuring the WAN publishers in the static configuration (including using Discovery SPI).
The new configuration is not persisted but it is replicated to all existing and new members.
Once the cluster is completely restarted, the dynamically added publisher configuration is lost and
the updates are not replicated to the target cluster anymore until added again.</p>
</div>
<div class="paragraph">
<p>If you wish to preserve the new configuration over cluster restarts, you must add
the exact same configuration to the static configuration file after dynamically adding the publisher configuration to a running cluster.</p>
</div>
<div class="paragraph">
<p>You cannot remove the existing configurations but can put the publishers into
a STOPPED state which prevents the WAN events from being enqueued in the WAN queues and
prevents the replication, rendering the publisher idle. The configurations also cannot be changed.</p>
</div>
<div class="paragraph">
<p>You can dynamically add a WAN publisher configuration using the
following REST call URL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/addWanConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to add the following URL-encoded parameters to the request in the following order separated by "&amp;";</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster name</p>
</li>
<li>
<p>Cluster password</p>
</li>
<li>
<p>WAN replication configuration, serialized as JSON</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can, at any point, even when maps and caches are concurrently mutated, add a new WAN publisher to
an existing WAN replication configuration.
The limitation is that there must be an existing WAN replication configuration but
it can be empty, without any publishers (target clusters).
For instance, this is an example of an XML configuration to which you can dynamically add new publishers:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="myWanReplication"&gt;&lt;/wan-replication&gt;
    &lt;map name="my-map"&gt;
        &lt;wan-replication-ref name="myWanReplication"&gt;
            &lt;merge-policy&gt;com.hazelcast.spi.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
            &lt;republishing-enabled&gt;false&lt;/republishing-enabled&gt;
       &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    myWanReplication:
  map:
    myMap:
      wan-replication-ref:
        myWanReplication:
          merge-policy: com.hazelcast.spi.merge.PassThroughMergePolicy
          republishing-enabled: false</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the map has defined WAN replication but there is no target cluster yet.
You can then add the new WAN replication publishers (target clusters) by
performing an HTTP POST as shown below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "clusterName&amp;clusterPassword&amp;{...}" --URL http://127.0.0.1:5701/hazelcast/rest/wan/addWanConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can provide the full configuration as JSON as a parameter.
Any WAN configuration supported in the XML and programmatic configurations is also supported in this JSON format.
Below are some examples of JSON configuration for a WAN publisher using
the Discovery SPI and static IP configuration. Here are the integer values for <code>initialPublisherState</code>,
<code>queueFullBehavior</code> and <code>consistencyCheckStrategy</code>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>initialPublisherState</code>:</p>
<div class="ulist">
<ul>
<li>
<p>0: REPLICATING</p>
</li>
<li>
<p>1: PAUSED</p>
</li>
<li>
<p>2: STOPPED</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>queueFullBehavior</code>:</p>
<div class="ulist">
<ul>
<li>
<p>0: DISCARD_AFTER_MUTATION</p>
</li>
<li>
<p>1: THROW_EXCEPTION</p>
</li>
<li>
<p>2: THROW_EXCEPTION_ONLY_IF_REPLICATION_ACTIVE</p>
</li>
</ul>
</div>
</li>
<li>
<p><code>consistencyCheckStrategy</code>:</p>
<div class="ulist">
<ul>
<li>
<p>0: NONE</p>
</li>
<li>
<p>1: MERKLE_TREES</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>Below is an example using Discovery SPI (AWS configuration):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":10000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "discovery":{
            "nodeFilterClass":null,
            "discoveryStrategy":[
               {
                  "className":"com.hazelcast.aws.AwsDiscoveryStrategy",
                  "properties":{
                     "security-group-name":"hazelcast",
                     "tag-value":"cluster1",
                     "host-header":"ec2.amazonaws.com",
                     "tag-key":"aws-test-cluster",
                     "secret-key":"my-secret-key",
                     "iam-role":"s3access",
                     "access-key":"my-access-key",
                     "hz-port":"5701-5708",
                     "region":"us-west-1"
                  }
               }
            ]
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is an example with Discovery SPI (the new AWS configuration)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "aws":{
            "enabled":true,
            "usePublicIp":false,
            "properties":{
               "security-group-name":"hazelcast-sg",
               "tag-value":"hz-nodes",
               "host-header":"ec2.amazonaws.com",
               "tag-key":"type",
               "secret-key":"my-secret-key",
               "iam-role":"dummy",
               "access-key":"my-access-key",
               "region":"us-west-1"
            }
         },
         "sync":{
            "consistencyCheckStrategy":0
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is an example with static IP configuration (with some optional attributes):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "responseTimeoutMillis":5000,
         "targetEndpoints":"10.3.5.1:5701, 10.3.5.2:5701",
         "batchMaxDelayMillis":3000,
         "batchSize":50,
         "snapshotEnabled":false,
         "acknowledgeType":1,
         "sync":{
            "consistencyCheckStrategy":0
         }
      }
   ]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below is an XML configuration with two publishers and several (disabled) discovery strategy configurations:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>{
   "name":"wanReplication",
   "publishers":[
      {
         "clusterName":"tokyo",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "aws":{
            "enabled":true,
            "usePublicIp":false,
            "properties":{
               "security-group-name":"hazelcast-sg",
               "tag-value":"hz-nodes",
               "host-header":"ec2.amazonaws.com",
               "tag-key":"type",
               "secret-key":"my-secret-key",
               "iam-role":"dummy",
               "access-key":"my-access-key",
               "region":"us-west-1"
            }
         },
         "gcp":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "gcp-prop":"gcp-val"
            }
         },
         "azure":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "azure-prop":"azure-val"
            }
         },
         "kubernetes":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "k8s-prop":"k8s-val"
            }
         },
         "eureka":{
            "enabled":false,
            "usePublicIp":true,
            "properties":{
               "eureka-prop":"eureka-val"
            }
         },
         "discovery":{
            "nodeFilterClass":null,
            "discoveryStrategy":[

            ]
         },
         "sync":{
            "consistencyCheckStrategy":0
         }
      },
      {
         "clusterName":"london",
         "queueCapacity":1000,
         "queueFullBehavior":0,
         "initialPublisherState":0,
         "responseTimeoutMillis":5000,
         "targetEndpoints":"10.3.5.1:5701, 10.3.5.2:5701",
         "batchMaxDelayMillis":3000,
         "batchSize":50,
         "snapshotEnabled":false,
         "acknowledgeType":1,
         "aws":{
            "enabled":false,
            "usePublicIp":false
         },
         "gcp":{
            "enabled":false,
            "usePublicIp":false
         },
         "azure":{
            "enabled":false,
            "usePublicIp":false
         },
         "kubernetes":{
            "enabled":false,
            "usePublicIp":false
         },
         "eureka":{
            "enabled":false,
            "usePublicIp":false
         },
         "discovery":{
            "nodeFilterClass":null,
            "discoveryStrategy":[

            ]
         },
         "sync":{
            "consistencyCheckStrategy":1
         }
      }
   ]
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_event_filtering_api"><a class="anchor" href="#_event_filtering_api"></a>Event Filtering API</h4>
<div class="paragraph">
<p>WAN replication allows you to intercept WAN replication events before they are placed to
WAN event replication queues by providing a filtering API.
Using this API, you can monitor WAN replication events of each data structure
separately.</p>
</div>
<div class="paragraph">
<p>You can attach filters to your data structures using the <code>filter</code> element of
<code>wan-replication-ref</code> configuration inside <code>hazelcast.xml</code> as shown below.
You can also configure it using the programmatic configuration.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;map name="testMap"&gt;
        &lt;wan-replication-ref name="test"&gt;
            &lt;filters&gt;
                &lt;filter-impl&gt;com.example.MyFilter&lt;/filter-impl&gt;
                &lt;filter-impl&gt;com.example.MyFilter2&lt;/filter-impl&gt;
            &lt;/filters&gt;
        &lt;/wan-replication-ref&gt;
    &lt;/map&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  map:
    testMap:
      wan-replication-ref:
        test:
          filters:
            - com.example.MyFilter
            - com.example.MyFilter2</code></pre>
</div>
</div>
<div class="paragraph">
<p>As shown in the above configuration, you can define more than one filter. Filters are called in the order that they are introduced.
A WAN replication event is only eligible to publish if it passes all the filters.</p>
</div>
<div class="paragraph">
<p>Map and Cache have different filter interfaces: <code>MapWanEventFilter</code> and
<code>CacheWanEventFilter</code>. Both of these interfaces have the method <code>filter</code> which takes the following parameters:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>mapName</code>/<code>cacheName</code>: Name of the related data structure.</p>
</li>
<li>
<p><code>entryView</code>: <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/core/EntryView.html" target="_blank" rel="noopener">EntryView</a>
or <a href="https://docs.hazelcast.org/docs/4.1/javadoc/com/hazelcast/cache/CacheEntryView.html" target="_blank" rel="noopener">CacheEntryView</a> depending on the data structure.</p>
</li>
<li>
<p><code>eventType</code>: Enum type - <code>UPDATED(1)</code>, <code>REMOVED(2)</code> or <code>LOADED(3)</code> - depending on the event.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>LOADED</code> events are filtered out and not replicated to target cluster.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="defining-custom-wr"><a class="anchor" href="#defining-custom-wr"></a>Implementing a Custom WAN Publisher</h4>
<div class="paragraph">
<p>In addition to using the Hazelcast&#8217;s built-in WAN Replication implementation, you can implement your own replication mechanism using the WAN publisher SPI.</p>
</div>
<div class="paragraph">
<p>Following is the configuration snippet where <code>replicatedMap</code> and <code>replicatedCache</code> use the custom implementation
<code>com.my.WanPublisher</code> to replicate map and cache updates.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;custom-publisher&gt;
            &lt;publisher-id&gt;myCustomPublisher&lt;/publisher-id&gt;
            &lt;class-name&gt;com.my.WanPublisher&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="prop1"&gt;val1&lt;/property&gt;
                &lt;property name="prop2"&gt;val2&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/custom-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      custom-publisher:
        publisher-id: myCustomPublisher
        class-name: com.my.WanPublisher
        properties:
          prop1: val1
          prop2: val2
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>custom-publisher</code> is used to configure a custom implementation of a WAN replication implementing
<code>com.hazelcast.wan.WanPublisher</code>. For example, you might implement replication to Kafka or some JMS queue or even
write out map and cache event changes to a log on disk. It has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class-name</code>: Mandatory configuration value defining the fully qualified class name of the
WAN publisher implementation. The class must implement <code>com.hazelcast.wan.WanPublisher</code>.</p>
</li>
<li>
<p><code>publisher-id</code>: Mandatory configuration value for the publisher ID used for identifying the
publisher in a <code>WanReplicationConfig</code>. This ID will be used to refer to this specific WAN publisher in
a certain WAN replication scheme.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In some cases, specifying the configuration on the source/active cluster is enough to fully implement your use case.
This is the case when you don&#8217;t have any target/passive Hazelcast cluster which consumes these events. In cases when
you do have a target Hazelcast cluster and you wish to use a custom WAN Replication implementation, you will need to
configure the target cluster as well. For example, you might want to implement WAN Replication by transmitting WAN events
through some JMS queue like ActiveMQ. In this case, you need to implement both your custom WAN publisher and WAN consumer.</p>
</div>
<div class="paragraph">
<p>Below is a configuration example for specifying a custom WAN replication consumer on the target/passive cluster:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;consumer&gt;
            &lt;class-name&gt;com.my.WanConsumer&lt;/class-name&gt;
            &lt;properties&gt;
                &lt;property name="prop1"&gt;val1&lt;/property&gt;
                &lt;property name="prop2"&gt;val2&lt;/property&gt;
            &lt;/properties&gt;
        &lt;/consumer&gt;
    &lt;/wan-replication&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      consumer:
        class-name: com.my.WanConsumer
        properties:
          prop1: val1
          prop2: val2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>consumer</code> is used to configure the implementation of the <code>com.hazelcast.wan.WanConsumer</code> interface
which will be used to retrieve and process WAN events. A custom WAN consumer allows you to
define custom processing logic and is used in combination with a custom WAN publisher.</p>
</div>
<div class="paragraph">
<p>The <code>consumer</code> configuration element has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>class-name</code>: Name of the class implementing a custom WAN consumer (<code>com.hazelcast.wan.WanConsumer</code>).</p>
</li>
<li>
<p><code>properties</code>: Properties for the custom WAN consumer. These properties are accessible when initializing the WAN consumer.
You can define the host, username and password for the host, name of the queue to be polled by the consumer, etc.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_customizing_wan_event_processing_on_passivetarget_cluster"><a class="anchor" href="#_customizing_wan_event_processing_on_passivetarget_cluster"></a>Customizing WAN Event Processing on Passive/Target Cluster</h4>
<div class="paragraph">
<p>In addition to customizing behavior of the source cluster and how WAN events are sent and retained, you can also
configure some aspects of how WAN events are processed on the receiving (target/passive) cluster. In addition, you
can also define a custom implementation of a WAN event consumer. A custom WAN consumer allows you to define custom
processing logic and is usually used in combination with a custom WAN publisher. A custom consumer is optional and
you may simply omit defining it which causes the default processing logic to be used. See the
<a href="#defining-custom-wr">Using the WAN Custom Publisher section</a> for more information.</p>
</div>
<div class="paragraph">
<p>Below you can see an example configuration of the target/passive cluster where we configure how incoming WAN events
are processed.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...

    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;consumer&gt;
            &lt;persist-wan-replicated-data&gt;false&lt;/persist-wan-replicated-data&gt;
        &lt;/consumer&gt;
    &lt;/wan-replication&gt;

    &lt;map name="replicatedMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/map&gt;

    &lt;cache name="replicatedCache"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
        ...
    &lt;/cache&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      consumer:
        persist-wan-replicated-data: false
  map:
    replicatedMap:
      wan-replication-ref:
        london-wan-rep:
          ...
  cache:
    replicatedCache:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the configuration above you can see that the WAN Replication configuration is again matched by WAN replication
scheme name to the exact map and cache configuration. This means that different structures can process WAN events
differently.</p>
</div>
<div class="paragraph">
<p>The processing behavior is configured using the <code>consumer</code> element. It has the following sub-elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>persist-wan-replicated-data</code>: When set to <code>true</code>, an incoming event over WAN replication can be
persisted to a database for example, otherwise it is not persisted. Default value is <code>true</code>.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tuning-wr"><a class="anchor" href="#tuning-wr"></a>Fine-Tuning WAN Replication</h3>
<div class="paragraph">
<p>WAN Replication will work fine for most use cases with the default settings. However, there are some specific
use cases where you might want to change the behavior of WAN Replication to suit your needs. You might also
be interested in the details how WAN Replication works. If that is the case, this section is for you.</p>
</div>
<div class="sect3">
<h4 id="_batch_size"><a class="anchor" href="#_batch_size"></a>Batch Size</h4>
<div class="paragraph">
<p>The maximum size of events that are sent in a single batch can be changed depending on your needs.
The batch of events is not sent until this size is reached or enough time has elapsed. The default value for batch size is <code>500</code>.
The batch size can be set for each WAN publisher separately by modifying the related <code>WanBatchPublisherConfig</code>.</p>
</div>
<div class="paragraph">
<p>Below is the configuration for changing the value of the element:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;batch-size&gt;1000&lt;/batch-size&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        batch-size: 1000</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WanReplicationConfig wanConfig = config.getWanReplicationConfig("london-wan-rep");
WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setBatchSize(1000);
wanConfig.addWanPublisherConfig(publisherConfig);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_batch_maximum_delay"><a class="anchor" href="#_batch_maximum_delay"></a>Batch Maximum Delay</h4>
<div class="paragraph">
<p>When using the built-in WAN batch replication, if the number of WAN replication events generated does not
reach <a href="#batch-size">Batch Size</a>, they are sent to the target cluster after a certain amount of time is passed.
You can set this duration in milliseconds using this batch maximum delay configuration.
Default value of for this duration is 1 second (1000 milliseconds).</p>
</div>
<div class="paragraph">
<p>Maximum delay can be set for each target cluster by modifying related <code>WanBatchPublisherConfig</code>.</p>
</div>
<div class="paragraph">
<p>You can change this element using the configuration as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;batch-max-delay-millis&gt;2000&lt;/batch-max-delay-millis&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        batch-max-delay-millis: 2000</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WanReplicationConfig wanConfig = config.getWanReplicationConfig("london-wan-rep");
WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setBatchMaxDelayMillis(2000);
wanConfig.addWanPublisherConfig(publisherConfig);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_response_timeout"><a class="anchor" href="#_response_timeout"></a>Response Timeout</h4>
<div class="paragraph">
<p>After a replication event is sent to the target cluster, the source member waits for
an acknowledgement of the delivery of the event to the target.
If the confirmation is not received inside a timeout duration window, the event is resent to
the target cluster. Default value of this duration is <code>60000</code> milliseconds.</p>
</div>
<div class="paragraph">
<p>You can change this duration depending on your network latency for each target cluster by
modifying related <code>WanBatchPublisherConfig</code>.</p>
</div>
<div class="paragraph">
<p>Below is an example configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;response-timeout-millis&gt;5000&lt;/response-timeout-millis&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        response-timeout-millis: 5000</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WanReplicationConfig wanConfig = config.getWanReplicationConfig("london-wan-rep");
WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setResponseTimeoutMillis(5000);
wanConfig.addWanPublisherConfig(publisherConfig);</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_queue_capacity"><a class="anchor" href="#_queue_capacity"></a>Queue Capacity</h4>
<div class="paragraph">
<p>For clusters with high data mutation rates or with long expected periods of disrupted connectivity between clusters,
you might need to increase the replication queue size. The default queue size for replication queues is <code>10000</code>.
This means, if you have heavy put/update/remove rates or if the target/passive cluster is unavailable for too long,
you might exceed the queue size so that the oldest, not yet replicated, updates might get lost.
Note that a separate queue is used for each WAN Replication configured for IMap and ICache.</p>
</div>
<div class="paragraph">
<p>Queue capacity can be set for each target cluster by modifying the related <code>WanBatchPublisherConfig</code>.</p>
</div>
<div class="paragraph">
<p>You can change this element using the configuration as shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;queue-capacity&gt;15000&lt;/queue-capacity&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        queue-capacity: 15000</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WanReplicationConfig wanConfig = config.getWanReplicationConfig("london-wan-rep");
WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setQueueCapacity(15000);
wanConfig.addWanPublisherConfig(publisherConfig);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that you can clear a member&#8217;s WAN replication event queue.
It can be initiated through Management Center&#8217;s
<a href="https://docs.hazelcast.org/docs/management-center/latest/manual/html/index.html#monitoring-wan-replication" target="_blank" rel="noopener">Clear Queues action</a> or
Hazelcast’s REST API. Below is the URL for its REST call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://member_ip:port/hazelcast/rest/wan/clearWanQueues</code></pre>
</div>
</div>
<div class="paragraph">
<p>You need to add the following URL-encoded parameters to the request in the following order separated by "&amp;";</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Cluster name</p>
</li>
<li>
<p>Cluster password</p>
</li>
<li>
<p>Name of the WAN replication configuration</p>
</li>
<li>
<p>WAN replication publisher ID/target cluster name</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This may be useful, for instance, to release the consumed heap if you know that
the target cluster is being shut down, decommissioned, put out of use and it will never come back.
Or, when a failure happens and queues are not replicated anymore, you could clear the queues using this clearing action.</p>
</div>
</div>
<div class="sect3">
<h4 id="_queue_full_behavior"><a class="anchor" href="#_queue_full_behavior"></a>Queue Full Behavior</h4>
<div class="paragraph">
<p>You can also configure the policy to be applied when the WAN Replication event queues are full. The following policies
are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>DISCARD_AFTER_MUTATION</code>: If you select this option, the new WAN events generated by
the member are dropped and not replicated to the target cluster
when the WAN event queues are full.</p>
</li>
<li>
<p><code>THROW_EXCEPTION</code>: If you select this option, the WAN queue size is checked before
each supported mutating operation (like <code>IMap.put()</code>, <code>ICache.put()</code>).
If one the queues of target cluster is full, <code>WanReplicationQueueFullException</code> is thrown and
the operation is not allowed.</p>
</li>
<li>
<p><code>THROW_EXCEPTION_ONLY_IF_REPLICATION_ACTIVE</code>: Its effect is similar to that of <code>THROW_EXCEPTION</code>.
But, it  throws exception only when WAN replication is active. It discards the new events if WAN replication is stopped.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;queue-full-behavior&gt;DISCARD_AFTER_MUTATION&lt;/queue-full-behavior&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        queue-full-behavior: DISCARD_AFTER_MUTATION</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WanReplicationConfig wanConfig = config.getWanReplicationConfig("london-wan-rep");
WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setQueueFullBehavior("DISCARD_AFTER_MUTATION");
wanConfig.addWanPublisherConfig(publisherConfig);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>queue-full-behavior</code> configuration is optional. Its default value is <code>DISCARD_AFTER_MUTATION</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_acknowledgment_types"><a class="anchor" href="#_acknowledgment_types"></a>Acknowledgment Types</h4>
<div class="paragraph">
<p>WAN replication supports different acknowledgment (ACK) types for each target cluster. You can choose from two different
acknowledgement types depending on your consistency and performance requirements. The following ACK types are supported:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ACK_ON_RECEIPT</code>: A batch of replication events is considered successfully replicated as soon as it is received by
the target cluster. This option does not guarantee that the received update is actually applied but it is faster.</p>
</li>
<li>
<p><code>ACK_ON_OPERATION_COMPLETE</code>: This option guarantees that the event is received by the target cluster and it is
applied. It is more time consuming but it ensures that the updates have been successfully applied by the target cluster
before sending the next batch of events.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following is an example configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;acknowledge-type&gt;ACK_ON_OPERATION_COMPLETE&lt;/acknowledge-type&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        acknowledge-type: ACK_ON_OPERATION_COMPLETE</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">JAVA</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">WanReplicationConfig wanConfig = config.getWanReplicationConfig("london-wan-rep");
WanBatchPublisherConfig publisherConfig = new WanBatchPublisherConfig()
        .setClusterName("london")
        .setAcknowledgeType("ACK_ON_OPERATION_COMPLETE");
wanConfig.addWanPublisherConfig(publisherConfig);</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>acknowledge-type</code> configuration is optional. Its default value is <code>ACK_ON_OPERATION_COMPLETE</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_key_based_coalescing"><a class="anchor" href="#_key_based_coalescing"></a>Key-based Coalescing</h4>
<div class="paragraph">
<p>By default, WAN Replication will replicate all of the updates on map and cache entries. If you are updating a
single "hot" entry multiple times, WAN Replication will send an update event for every entry update. If you don&#8217;t need
to have all updates replicated and would like to simply replicate the latest update for a certain entry, you can
turn on key-based coalescing, thus saving on amounts of data replicated between clusters.</p>
</div>
<div class="paragraph">
<p>The following is an example configuration:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;snapshot-enabled&gt;true&lt;/snapshot-enabled&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        snapshot-enabled: true</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>snapshot-enabled</code> is optional. Its default value is <code>false</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="low-latency-higher-throughput"><a class="anchor" href="#low-latency-higher-throughput"></a>Achieving Lower Latencies and Higher Throughput</h4>
<div class="paragraph">
<p>The WAN replication mechanism allows
tuning for lower latencies of replication and higher throughput.
In most cases, WAN replication is sufficient with out-of-the-box settings which cause
WAN replication to replicate the map and cache events with little overhead.
However, there might be some use cases where the latency between a map/cache mutation on one cluster and
its visibility on the other cluster must be kept within some bounds.
To achieve such demands, you can first try tuning the WAN replication mechanism using the following publisher elements:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>batch-size</code></p>
</li>
<li>
<p><code>batch-max-delay-millis</code></p>
</li>
<li>
<p><code>idle-min-park-ns</code></p>
</li>
<li>
<p><code>idle-max-park-ns</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>To understand the implications of these elements, let&#8217;s first dive into how WAN replication works.</p>
</div>
<div class="paragraph">
<p>WAN replication runs in a separate thread and tries to send map and cache mutation events in batches to
the target endpoints for higher throughput. The target endpoints are usually members in
a target Hazelcast cluster but different WAN implementations may have different target endpoints.
The event batch is collected by iterating over the WAN queues for different partitions and, different maps and caches.
WAN replication tries and collects a batch of a size which can be configured using the <code>batch-size</code> element.</p>
</div>
<div class="paragraph">
<p>If enough time has passed and the WAN replication thread hasn&#8217;t collected enough events to fill
a batch, it sends what it has collected nevertheless.
This is controlled by the <code>batch-max-delay-millis</code> element.
The "enough time" precisely means that more than the configured amount of milliseconds has passed since
the time the last batch was sent to any target endpoint.</p>
</div>
<div class="paragraph">
<p>If there are no events in any of the WAN queues, the WAN replication thread goes into
the idle state by parking the WAN replication thread.
The minimum park time can be defined using the <code>idle-min-park-ns</code> element and
the maximum park time can be controlled using the <code>idle-max-park-ns</code> element.
If a WAN event is enqueued while the WAN replication thread is in the idle state, the latency for replication of that WAN event increases.</p>
</div>
<div class="paragraph">
<p>An example WAN replication configuration using the default values of the above elements is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep-batch"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;batch-size&gt;500&lt;/batch-size&gt;
            &lt;batch-max-delay-millis&gt;1000&lt;/batch-max-delay-millis&gt;
            &lt;idle-min-park-ns&gt;10000000&lt;/idle-min-park-ns&gt; &lt;!-- 10 ms --&gt;
            &lt;idle-max-park-ns&gt;250000000&lt;/idle-max-park-ns&gt; &lt;!-- 250 ms --&gt;
            ...
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        batch-size: 500
        batch-max-delay-millis: 1000
        idle-min-park-ns: 10000000
        idle-max-park-ns: 250000000</code></pre>
</div>
</div>
<div class="paragraph">
<p>We will now discuss tuning these elements. Unfortunately, the exact tuning parameters heavily depend
on the load, mutation rate, latency between the source and target clusters and even use cases.
We will thus discuss some general approaches and pointers.</p>
</div>
<div class="paragraph">
<p>When tuning for low latency, the first thing you might want to do is lower
the <code>idle-min-park-ns</code> and <code>idle-max-park-ns</code> element values.
This will affect the latencies that you see when having a low number of
operations per second, since this is when the WAN replication thread will be mostly in idle state.
Try lowering both elements but keep in mind that the lower the element value, the more time the WAN replication thread will
spend consuming CPU in a quiescent state - when there is no mutation on the maps or caches.</p>
</div>
<div class="paragraph">
<p>The next element you might lower is the <code>batch-max-delay-millis</code>. If you have a strict upper bound on
the latency for WAN replication, this element must be below that limit. Setting this value too low might
adversely affect the performance: in that case the WAN replication thread might send
smaller batches than what it would if the element was higher and it had waited for some more time.
You can even try setting this element to zero which instructs the WAN replication thread to
send batches as soon as it is able to collect any events; but keep in mind this will result in
many smaller batches instead of less bigger event batches.</p>
</div>
<div class="paragraph">
<p>When tuning for lower latencies, configuring the <code>batch-size</code> usually has little effect, especially at lower mutation rates.
At a low number of operations per second,  the event batches will usually be very small since
the WAN replication thread will not be able to collect the full batch and respect the required latencies for replication.
The <code>batch-size</code> element might have more effect at higher mutation rates. Here, you will probably want to use
bigger batches to avoid paying for the latencies when sending lots of smaller batches, so try increasing
the batch size and benchmarking at high load.</p>
</div>
<div class="paragraph">
<p>There are a couple of other configuration values that you might try changing but it depends on your use case.
The first one is adding a separate configuration for a WAN replication executor.
Collecting of WAN event batches and processing the responses from the target endpoints are done on a shared executor.
This executor is shared between the other parts of the Hazelcast system and all of the WAN replication publishers will use
the same executor. In some cases, you might want to create a dedicated executor for all WAN replication publishers.
The name of this executor is <code>hz:wan</code>. Below is an example of a concrete, dedicated executor for WAN replication.
See the <a href="#configuring-executor-service">Configuring Executor Service section</a> for more information on
the configuration options of the executor.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;executor-service name="hz:wan"&gt;
        &lt;pool-size&gt;16&lt;/pool-size&gt;
    &lt;/executor-service&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  executor-service:
    hz-wan:
      pool-size: 16</code></pre>
</div>
</div>
<div class="paragraph">
<p>The last two elements that you might want to change are <code>acknowledge-type</code> and <code>max-concurrent-invocations</code>.
Changing these elements allow you to get a greater throughput at the expense of event ordering.
This means that these elements may only be changed if your application can tolerate WAN events to be received out-of-order.
For instance, if you are updating or removing the existing map or cache entries, an out-of-order WAN event delivery would mean
that the event for the entry removal or update might be processed by the target cluster before the event is received to create that entry.
This does not causes exceptions but it causes the clusters to fall out-of-sync.
In these cases, you most probably will not be able to use these elements.
On the other hand, if you are only creating new, immutable entries (which are then removed by the expiration mechanism),
you can use these elements to achieve a greater throughput.</p>
</div>
<div class="paragraph">
<p>The <code>acknowledge-type</code> element controls at which time the target cluster will send a response for the received WAN event batch.
The default value is <code>ACK_ON_OPERATION_COMPLETE</code> which will ensure that all events are processed before
the response is sent to the source cluster.
The value <code>ACK_ON_RECEIPT</code> instructs the target cluster to send a response as soon as
it has received the WAN event batch but before it has been processed.
This has two implications. One is that events can now be processed out-of-order (see the previous paragraph) and
the other is that the exceptions thrown on processing the WAN event batch will not be received by
the source cluster and the WAN event batch will not be retried.
As such, some events might get lost in case of errors and the clusters may fall out-of-sync.
WAN sync can help bring those clusters in-sync.
The benefit of the <code>ACK_ON_RECEIPT</code> value is that now the source cluster can
send a new batch sooner, without waiting for the previous batch to be processed fully.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
WAN synchronization strategies (neither the default nor the <a href="#delta-wan-synchronization">[delta-wan-synchronization]</a>)
don&#8217;t synchronize the deletions since they are not yet tracked under WAN.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <code>max-concurrent-invocations</code> element controls the maximum number of
WAN event batches being sent to the target cluster concurrently.
Setting this element to anything less than 2 will only allow a single batch of
events to be sent to each target endpoint and will maintain causality of events for
a single partition (events are not received out-of-order).
Setting this element to 2 or higher will allow multiple batches of WAN events to be sent to
each target endpoint. Since this allows reordering of batches due to the network conditions, causality and
ordering of events for a single partition is lost and batches for a single partition are now sent randomly to
any available target endpoint. This, however, does present a faster WAN replication for certain scenarios such as
replicating immutable, independent map entries which are only added once and where
ordering, when these entries are added, is not necessary.
Keep in mind that if you set this element to a value which is less than the target endpoint count,
you will lose performance as not all target endpoints will be used at any point in time to process the WAN event batches.
So, for instance, if you have a target cluster with 3 members (target endpoints) and you want to use
this element, it only makes sense to set it to a value higher than 3. Otherwise, you can simply disable it by
setting it to less than 2 in which case WAN will use the default replication strategy and adapt to
the target endpoint count while maintaining causality.</p>
</div>
<div class="paragraph">
<p>An example WAN replication configuration using the default values of
the aforementioned elements is shown below.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep-batch"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;acknowledge-type&gt;ACK_ON_OPERATION_COMPLETE&lt;/acknowledge-type&gt;
            &lt;max-concurrent-invocations&gt;-1&lt;/max-concurrent-invocations&gt;
            ...
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep-batch:
      cluster-name: london
      acknowledge-type: ACK_ON_OPERATION_COMPLETE
      max-concurrent-invocations: -1</code></pre>
</div>
</div>
<div class="paragraph">
<p>Finally, as we&#8217;ve mentioned, the exact values which will give you the optimal performance depend on your environment and use case.
Please benchmark and try out different values to find out the right values for you.</p>
</div>
</div>
<div class="sect3">
<h4 id="_discovery_period"><a class="anchor" href="#_discovery_period"></a>Discovery Period</h4>
<div class="paragraph">
<p>When using WAN Replication with Discovery SPI, you can set the period in seconds in which WAN tries to
discover new target endpoints and reestablish connections to failed endpoints using the <code>discovery-period-seconds</code>
property. The default value is 10 seconds.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep-batch"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;discovery-period-seconds&gt;20&lt;/discovery-period-seconds&gt;
            ...
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_maximum_number_of_target_endpoints"><a class="anchor" href="#_maximum_number_of_target_endpoints"></a>Maximum Number of Target Endpoints</h4>
<div class="paragraph">
<p>When using WAN Replication with Discovery SPI, you can set the maximum number of endpoints that WAN connects to
at any point using the <code>max-target-endpoints</code> property. This element has no effect when static endpoint addresses
are defined using <code>target-endpoints</code>. Default is <code>Integer.MAX_VALUE</code>.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep-batch"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;max-target-endpoints&gt;5&lt;/max-target-endpoints&gt;
            ...
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep-batch:
      batch-publisher:
        cluster-name: london
        max-target-endpoints: 5</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_use_endpoint_private_address"><a class="anchor" href="#_use_endpoint_private_address"></a>Use Endpoint Private Address</h4>
<div class="paragraph">
<p>When using WAN Replication with Discovery SPI, you can set whether the WAN connection manager should connect to the
endpoint on the private address returned by the Discovery SPI using the <code>use-endpoint-private-address</code> property.
By default this element is <code>false</code> which means the WAN connection manager always uses the public address.</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    ...
    &lt;wan-replication name="london-wan-rep-batch"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;use-endpoint-private-address&gt;true&lt;/use-endpoint-private-address&gt;
            ...
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;
    ...
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  wan-replication:
    london-wan-rep-batch:
      batch-publisher:
        cluster-name: london
        use-endpoint-private-address: true</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wan-replication-failure-detection-and-recovery"><a class="anchor" href="#wan-replication-failure-detection-and-recovery"></a>Failure Detection and Recovery</h3>
<div class="paragraph">
<p>The failure detection and recovery mechanisms in WAN handle failures during WAN replication and
they closely interact with the list of endpoints that WAN is replicating to.
There might be some small differences when using static endpoints or the Discovery SPI but
here we will outline the general mechanism of failure detection and recovery.</p>
</div>
<div class="sect3">
<h4 id="_wan_target_endpoint_list"><a class="anchor" href="#_wan_target_endpoint_list"></a>WAN Target Endpoint List</h4>
<div class="paragraph">
<p>The WAN connection manager maintains a list of public addresses that it can replicate to at any moment.
This list may change over time as failures are detected or as new addresses are discovered when using the Discovery SPI.
The connection manager does not eagerly create connections to these addresses as
they are added to the list to avoid overloading the endpoint with connections from all members using
the same configuration. It tries to connect to the endpoint just before WAN events are about to be transmitted.
This means that if there are no updates on the map or cache using WAN replication, there are no
WAN events and the connection will not be established to the endpoint.</p>
</div>
<div class="paragraph">
<p>When more than one endpoint is configured, traffic is load balanced between them using
the partition, so that the same partitions are always sent to the same target member, ensuring ordering by partition.</p>
</div>
</div>
<div class="sect3">
<h4 id="_wan_failure_detection"><a class="anchor" href="#_wan_failure_detection"></a>WAN Failure Detection</h4>
<div class="paragraph">
<p>If using the Hazelcast IMDG Enterprise edition class <code>WanBatchReplication</code>
(see the <a href="#defining-wan-replication">Defining WAN replication section</a>), the WAN replication catches
any exceptions when sending the WAN events to the endpoint. In the case of an exception,
the endpoint is removed from the endpoint list to which WAN replicates and the WAN events are resent to
a different address. The replication is retried until it is successful.</p>
</div>
</div>
<div class="sect3">
<h4 id="_wan_endpoint_recovery"><a class="anchor" href="#_wan_endpoint_recovery"></a>WAN Endpoint Recovery</h4>
<div class="paragraph">
<p>The WAN connection manager tries to "rediscover" new endpoints periodically.
The period is 10 seconds by default but can be configured using the <code>discovery-period-seconds</code> element
(see the <a href="#defining-wan-replication">Defining WAN replication section</a>).</p>
</div>
<div class="paragraph">
<p>The discovered endpoints depend on the configuration used to define WAN replication.
If using static WAN endpoints (by using the <code>target-endpoints</code> element), the discovered endpoints are always the same and
are equal to the values defined in the configuration.
If using Discovery SPI with WAN, the discovered endpoints may be different each time.</p>
</div>
<div class="paragraph">
<p>When the discovery returns a list of endpoints (addresses), the WAN target endpoint list is updated.
Newly discovered endpoints are added and endpoints which are no longer in the discovered list are removed.
Newly discovered endpoints may include addresses to which WAN replication has previously failed.
This means that once a new WAN event is about to be sent, a connection is reestablished to
the previously failed endpoint and WAN replication is retried. The endpoint can later
be again removed from the target endpoint list if the replication again encounters failure.</p>
</div>
</div>
<div class="sect3">
<h4 id="_backing_up_event_queues"><a class="anchor" href="#_backing_up_event_queues"></a>Backing Up Event Queues</h4>
<div class="paragraph">
<p>WAN replication backs up its event queues to other members to prevent event loss
in case of member failures.</p>
</div>
<div class="paragraph">
<p>WAN replication&#8217;s backup mechanism depends on the related data structures' backup operations.
Note that, WAN replication is supported for IMap and ICache.
That means, as far as you set a backup count for your IMap or ICache instances,
WAN replication events generated by these instances are also replicated.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wr-rest"><a class="anchor" href="#wr-rest"></a>REST API Wrap-Up</h3>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
To be able to use the REST calls related to WAN Replication
mentioned in this section, you need to enable the <code>WAN</code> REST endpoint group.
See the <a href="#using-the-rest-endpoint-groups">Using the REST Endpoint Groups section</a> on
how to enable it.
</td>
</tr>
</table>
</div>
<div class="sect3">
<h4 id="_parameters"><a class="anchor" href="#_parameters"></a>Parameters</h4>
<div class="paragraph">
<p>Here is the list of parameters used in the WAN Replication REST calls, which
are shown as placeholders in the REST calls:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>member IP address and port: IP address and port number of the
member on which you run the REST calls.</p>
</li>
<li>
<p><code>clusterOnSource</code>: Name of your local (source) cluster.</p>
</li>
<li>
<p><code>clusterPassword</code>: Password, if set, of your source cluster.
Note that you need to enable the <a href="#enabling-jaas-security">security</a>
when you need a cluster password. If not set, the parameter is empty.</p>
</li>
<li>
<p><code>wanRepName</code>: Name of the WAN Replication configuration.</p>
</li>
<li>
<p><code>publisherId</code>: WAN replication publisher ID. If not set,
<code>cluster-name</code> under the <code>batch-publisher</code> element is used.</p>
</li>
<li>
<p><code>mapName</code>: Name of the map to be synchronized.</p>
</li>
<li>
<p><code>wanConfig</code>: WAN publisher configuration file, as a JSON string,
to be added dynamically.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The parameters in the below curl commands need to be provided
in the given order, separated by <code>&amp;</code>.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s use the following declarative configuration as the example to
be used in the curl commands described in the sections below, and
let&#8217;s assume that our source cluster does not have a password:</p>
</div>
<div class="listingblock primary">
<div class="title">XML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;hazelcast&gt;
    &lt;cluster-name&gt;tokyo&lt;/cluster-name&gt;
    &lt;wan-replication name="london-wan-rep"&gt;
        &lt;batch-publisher&gt;
            &lt;cluster-name&gt;london&lt;/cluster-name&gt;
            &lt;target-endpoints&gt;10.3.5.1:5701, 10.3.5.2:5701&lt;/target-endpoints&gt;
        &lt;/batch-publisher&gt;
    &lt;/wan-replication&gt;

    &lt;map name="myMap"&gt;
        &lt;wan-replication-ref name="london-wan-rep"/&gt;
    &lt;/map&gt;
&lt;/hazelcast&gt;</code></pre>
</div>
</div>
<div class="listingblock secondary">
<div class="title">YAML</div>
<div class="content">
<pre class="highlightjs highlight"><code class="language-yml hljs" data-lang="yml">hazelcast:
  cluster-name: tokyo
  wan-replication:
    london-wan-rep:
      batch-publisher:
        cluster-name: london
        target-endpoints: 10.3.5.1:5701, 10.3.5.2:5701
  map:
    myMap:
      wan-replication-ref:
        london-wan-rep:
          ...</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_clearing_the_queues"><a class="anchor" href="#_clearing_the_queues"></a>Clearing the Queues</h4>
<div class="paragraph">
<p>The URL for cleaning the WAN event queues is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/clearWanQueues</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the curl command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusteronSourceName}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}" --URL http://{member IP address:port}/hazelcast/rest/wan/clearWanQueues</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command according to the above example configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "tokyo&amp;&amp;london-wan-rep&amp;london" --URL http://127.0.0.1:5701/hazelcast/rest/wan/clearWanQueues</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_pausing_the_publisher"><a class="anchor" href="#_pausing_the_publisher"></a>Pausing the Publisher</h4>
<div class="paragraph">
<p>The URL for pausing the WAN publisher is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/pausePublisher</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the curl command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}" --URL http://{member IP address:port}/hazelcast/rest/wan/pausePublisher</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command according to the above example configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "tokyo&amp;&amp;london-wan-rep&amp;london" --URL http://127.0.0.1:5701/hazelcast/rest/wan/pausePublisher</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_resuming_the_publisher"><a class="anchor" href="#_resuming_the_publisher"></a>Resuming the Publisher</h4>
<div class="paragraph">
<p>The URL for resuming the WAN publisher is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/resumePublisher</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the curl command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}" --URL http://{member IP address:port}/hazelcast/rest/wan/resumePublisher</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command according to the above example configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "tokyo&amp;&amp;london-wan-rep&amp;london" --URL http://127.0.0.1:5701/hazelcast/rest/wan/resumePublisher</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_stopping_the_publisher"><a class="anchor" href="#_stopping_the_publisher"></a>Stopping the Publisher</h4>
<div class="paragraph">
<p>The URL for stopping the WAN publisher is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/stopPublisher</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the curl command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}" --URL http://{member IP address:port}/hazelcast/rest/wan/stopPublisher</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command according to the above example configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "tokyo&amp;&amp;london-wan-rep&amp;london" --URL http://127.0.0.1:5701/hazelcast/rest/wan/stopPublisher</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_synchronizing_the_clusters"><a class="anchor" href="#_synchronizing_the_clusters"></a>Synchronizing the Clusters</h4>
<div class="paragraph">
<p>For the full synchronization, the URLs for synchronizing a single map and all maps are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/sync/map
http://{member IP address:port}/hazelcast/rest/wan/sync/allMaps</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following are the respective curl commands:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}&amp;{mapName}" --URL http://{member IP address:port}/hazelcast/rest/wan/sync/map

curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}" --URL http://{member IP address:port}/hazelcast/rest/wan/sync/allMaps</code></pre>
</div>
</div>
<div class="paragraph">
<p>The command according to the above example configuration is as follows (for that single map):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "tokyo&amp;&amp;london-wan-rep&amp;london&amp;myMap" --URL http://{member IP address:port}/hazelcast/rest/wan/sync/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the delta synchronization, you need to first perform a
consistency check, using the the following REST call URL:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/consistencyCheck/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here is the respective curl command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanRepName}&amp;{publisherId}&amp;{mapName}" --URL http://{member IP address:port}/hazelcast/rest/wan/consistencyCheck/map</code></pre>
</div>
</div>
<div class="paragraph">
<p>After the consistency check, you can use the same REST calls
used in full synchronization in the same way to synchronize
a single map or all the maps.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Consistency check can be triggered only for one map.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="wr-dynamically-adding"><a class="anchor" href="#wr-dynamically-adding"></a>Dynamically Adding WAN Publishers</h4>
<div class="paragraph">
<p>The URL for dynamically adding a WAN publisher configuration is as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>http://{member IP address:port}/hazelcast/rest/wan/addWanConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following is the curl command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code>curl -X POST -d "{clusterOnSource}&amp;{clusterPassword}&amp;{wanConfig}" --URL http://127.0.0.1:5701/hazelcast/rest/wan/addWanConfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>wanConfig</code> parameter should be the full configuration as a JSON string.
See <a href="#dynamically-adding-wan-publishers">here</a> for configuration examples.</p>
</div>
</div>
</div>
</div>
</div>
</article>
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script src="../../../_/js/site.js"></script>
<link rel="shortcut icon" href="http://hazelcast.com/images/favicon.png">
<script src="../../../_/js/vendor/lunr.js"></script>
<script src="../../../_/js/vendor/search.js" id="search-script" data-base-path="../../.." data-page-path="/hazelcast/4.1/deploy/wan.html"></script>
<script async src="../../../_/../search-index.js"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
